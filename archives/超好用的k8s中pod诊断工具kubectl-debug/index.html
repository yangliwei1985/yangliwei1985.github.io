<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>超好用的k8s中pod诊断工具：kubectl-debug | ylw&#39;s blog</title>
<meta name="keywords" content="kubectl-debug" />
<meta name="description" content="背景 容器技术的一个最佳实践是构建尽可能精简的容器镜像。但这一实践却会给排查问题带来麻烦：精简后的容器中普遍缺失常用的排障工具，部分容器里甚至没有 shell (比如 FROM scratch ）。 在这种状况下，我们只能通过日志或者到宿主机上通过 docker-cli 或 nsenter 来排查问题，效率很低，在K8s环境部署应用后，经常遇到需要进入pod进行排错。除了查看pod logs和describe方式之外，传统的解决方式是在业务pod基础镜像中提前安装好procps、net-tools、tcpdump、vim等工具。但这样既不符合最小化镜像原则，又徒增Pod安全漏洞风险。
今天为大家推荐一款K8s pod诊断工具，kubectl-debug是一个简单、易用、强大的 kubectl 插件, 能够帮助你便捷地进行 Kubernetes 上的 Pod 排障诊断。它通过启动一个排错工具容器，并将其加入到目标业务容器的pid, network, user 以及 ipc namespace 中，这时我们就可以在新容器中直接用 netstat, tcpdump 这些熟悉的工具来解决问题了, 而业务容器可以保持最小化, 不需要预装任何额外的排障工具。 kubectl-debug 主要包含以下两部分:
 kubectl-debug：命令行工具 debug-agent：部署在K8s的node上，用于启动关联排错工具容器  工作原理 我们知道，容器本质上是带有 cgroup 资源限制和 namespace 隔离的一组进程。因此，我们只要启动一个进程，并且让这个进程加入到目标容器的各种 namespace 中，这个进程就能 “进入容器内部”（注意引号），与容器中的进程”看到”相同的根文件系统、虚拟网卡、进程空间了——这也正是 docker exec 和 kubectl exec 等命令的运行方式。
现在的状况是，我们不仅要 “进入容器内部”，还希望带一套工具集进去帮忙排查问题。那么，想要高效管理一套工具集，又要可以跨平台，最好的办法就是把工具本身都打包在一个容器镜像当中。 接下来，我们只需要通过这个”工具镜像”启动容器，再指定这个容器加入目标容器的的各种 namespace，自然就实现了 “携带一套工具集进入容器内部”。事实上，使用 docker-cli 就可以实现这个操作：
export TARGET_ID=666666666 # 加入目标容器的 network, pid 以及 ipc namespace docker run -it --network=container:$TARGET_ID --pid=container:$TARGET_ID --ipc=container:$TARGET_ID busybox 这就是 kubectl-debug 的出发点： 用工具容器来诊断业务容器 。背后的设计思路和 sidecar 等模式是一致的：每个容器只做一件事情。">
<meta name="author" content="">
<link rel="canonical" href="https://iblog.zone/archives/%E8%B6%85%E5%A5%BD%E7%94%A8%E7%9A%84k8s%E4%B8%ADpod%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7kubectl-debug/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7af5e4f048c756d5896f15b3f7cd7ee898ea1b3b101fcb40abfb5216ca230ecf.css" integrity="sha256-evXk8EjHVtWJbxWz981&#43;6JjqGzsQH8tAq/tSFsojDs8=" rel="preload stylesheet" as="style">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://iblog.zone/images/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://iblog.zone/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="https://iblog.zone/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="https://iblog.zone/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="https://iblog.zone/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel='stylesheet' href='//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>

<meta property="og:title" content="超好用的k8s中pod诊断工具：kubectl-debug" />
<meta property="og:description" content="背景 容器技术的一个最佳实践是构建尽可能精简的容器镜像。但这一实践却会给排查问题带来麻烦：精简后的容器中普遍缺失常用的排障工具，部分容器里甚至没有 shell (比如 FROM scratch ）。 在这种状况下，我们只能通过日志或者到宿主机上通过 docker-cli 或 nsenter 来排查问题，效率很低，在K8s环境部署应用后，经常遇到需要进入pod进行排错。除了查看pod logs和describe方式之外，传统的解决方式是在业务pod基础镜像中提前安装好procps、net-tools、tcpdump、vim等工具。但这样既不符合最小化镜像原则，又徒增Pod安全漏洞风险。
今天为大家推荐一款K8s pod诊断工具，kubectl-debug是一个简单、易用、强大的 kubectl 插件, 能够帮助你便捷地进行 Kubernetes 上的 Pod 排障诊断。它通过启动一个排错工具容器，并将其加入到目标业务容器的pid, network, user 以及 ipc namespace 中，这时我们就可以在新容器中直接用 netstat, tcpdump 这些熟悉的工具来解决问题了, 而业务容器可以保持最小化, 不需要预装任何额外的排障工具。 kubectl-debug 主要包含以下两部分:
 kubectl-debug：命令行工具 debug-agent：部署在K8s的node上，用于启动关联排错工具容器  工作原理 我们知道，容器本质上是带有 cgroup 资源限制和 namespace 隔离的一组进程。因此，我们只要启动一个进程，并且让这个进程加入到目标容器的各种 namespace 中，这个进程就能 “进入容器内部”（注意引号），与容器中的进程”看到”相同的根文件系统、虚拟网卡、进程空间了——这也正是 docker exec 和 kubectl exec 等命令的运行方式。
现在的状况是，我们不仅要 “进入容器内部”，还希望带一套工具集进去帮忙排查问题。那么，想要高效管理一套工具集，又要可以跨平台，最好的办法就是把工具本身都打包在一个容器镜像当中。 接下来，我们只需要通过这个”工具镜像”启动容器，再指定这个容器加入目标容器的的各种 namespace，自然就实现了 “携带一套工具集进入容器内部”。事实上，使用 docker-cli 就可以实现这个操作：
export TARGET_ID=666666666 # 加入目标容器的 network, pid 以及 ipc namespace docker run -it --network=container:$TARGET_ID --pid=container:$TARGET_ID --ipc=container:$TARGET_ID busybox 这就是 kubectl-debug 的出发点： 用工具容器来诊断业务容器 。背后的设计思路和 sidecar 等模式是一致的：每个容器只做一件事情。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://iblog.zone/archives/%E8%B6%85%E5%A5%BD%E7%94%A8%E7%9A%84k8s%E4%B8%ADpod%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7kubectl-debug/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-18T11:24:51&#43;00:00" />
<meta property="article:modified_time" content="2022-02-18T11:24:51&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="超好用的k8s中pod诊断工具：kubectl-debug"/>
<meta name="twitter:description" content="背景 容器技术的一个最佳实践是构建尽可能精简的容器镜像。但这一实践却会给排查问题带来麻烦：精简后的容器中普遍缺失常用的排障工具，部分容器里甚至没有 shell (比如 FROM scratch ）。 在这种状况下，我们只能通过日志或者到宿主机上通过 docker-cli 或 nsenter 来排查问题，效率很低，在K8s环境部署应用后，经常遇到需要进入pod进行排错。除了查看pod logs和describe方式之外，传统的解决方式是在业务pod基础镜像中提前安装好procps、net-tools、tcpdump、vim等工具。但这样既不符合最小化镜像原则，又徒增Pod安全漏洞风险。
今天为大家推荐一款K8s pod诊断工具，kubectl-debug是一个简单、易用、强大的 kubectl 插件, 能够帮助你便捷地进行 Kubernetes 上的 Pod 排障诊断。它通过启动一个排错工具容器，并将其加入到目标业务容器的pid, network, user 以及 ipc namespace 中，这时我们就可以在新容器中直接用 netstat, tcpdump 这些熟悉的工具来解决问题了, 而业务容器可以保持最小化, 不需要预装任何额外的排障工具。 kubectl-debug 主要包含以下两部分:
 kubectl-debug：命令行工具 debug-agent：部署在K8s的node上，用于启动关联排错工具容器  工作原理 我们知道，容器本质上是带有 cgroup 资源限制和 namespace 隔离的一组进程。因此，我们只要启动一个进程，并且让这个进程加入到目标容器的各种 namespace 中，这个进程就能 “进入容器内部”（注意引号），与容器中的进程”看到”相同的根文件系统、虚拟网卡、进程空间了——这也正是 docker exec 和 kubectl exec 等命令的运行方式。
现在的状况是，我们不仅要 “进入容器内部”，还希望带一套工具集进去帮忙排查问题。那么，想要高效管理一套工具集，又要可以跨平台，最好的办法就是把工具本身都打包在一个容器镜像当中。 接下来，我们只需要通过这个”工具镜像”启动容器，再指定这个容器加入目标容器的的各种 namespace，自然就实现了 “携带一套工具集进入容器内部”。事实上，使用 docker-cli 就可以实现这个操作：
export TARGET_ID=666666666 # 加入目标容器的 network, pid 以及 ipc namespace docker run -it --network=container:$TARGET_ID --pid=container:$TARGET_ID --ipc=container:$TARGET_ID busybox 这就是 kubectl-debug 的出发点： 用工具容器来诊断业务容器 。背后的设计思路和 sidecar 等模式是一致的：每个容器只做一件事情。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://iblog.zone/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "超好用的k8s中pod诊断工具：kubectl-debug",
      "item": "https://iblog.zone/archives/%E8%B6%85%E5%A5%BD%E7%94%A8%E7%9A%84k8s%E4%B8%ADpod%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7kubectl-debug/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "超好用的k8s中pod诊断工具：kubectl-debug",
  "name": "超好用的k8s中pod诊断工具：kubectl-debug",
  "description": "背景 容器技术的一个最佳实践是构建尽可能精简的容器镜像。但这一实践却会给排查问题带来麻烦：精简后的容器中普遍缺失常用的排障工具，部分容器里甚至没有 shell (比如 FROM scratch ）。 在这种状况下，我们只能通过日志或者到宿主机上通过 docker-cli 或 nsenter 来排查问题，效率很低，在K8s环境部署应用后，经常遇到需要进入pod进行排错。除了查看pod logs和describe方式之外，传统的解决方式是在业务pod基础镜像中提前安装好procps、net-tools、tcpdump、vim等工具。但这样既不符合最小化镜像原则，又徒增Pod安全漏洞风险。\n今天为大家推荐一款K8s pod诊断工具，kubectl-debug是一个简单、易用、强大的 kubectl 插件, 能够帮助你便捷地进行 Kubernetes 上的 Pod 排障诊断。它通过启动一个排错工具容器，并将其加入到目标业务容器的pid, network, user 以及 ipc namespace 中，这时我们就可以在新容器中直接用 netstat, tcpdump 这些熟悉的工具来解决问题了, 而业务容器可以保持最小化, 不需要预装任何额外的排障工具。 kubectl-debug 主要包含以下两部分:\n kubectl-debug：命令行工具 debug-agent：部署在K8s的node上，用于启动关联排错工具容器  工作原理 我们知道，容器本质上是带有 cgroup 资源限制和 namespace 隔离的一组进程。因此，我们只要启动一个进程，并且让这个进程加入到目标容器的各种 namespace 中，这个进程就能 “进入容器内部”（注意引号），与容器中的进程”看到”相同的根文件系统、虚拟网卡、进程空间了——这也正是 docker exec 和 kubectl exec 等命令的运行方式。\n现在的状况是，我们不仅要 “进入容器内部”，还希望带一套工具集进去帮忙排查问题。那么，想要高效管理一套工具集，又要可以跨平台，最好的办法就是把工具本身都打包在一个容器镜像当中。 接下来，我们只需要通过这个”工具镜像”启动容器，再指定这个容器加入目标容器的的各种 namespace，自然就实现了 “携带一套工具集进入容器内部”。事实上，使用 docker-cli 就可以实现这个操作：\nexport TARGET_ID=666666666 # 加入目标容器的 network, pid 以及 ipc namespace docker run -it --network=container:$TARGET_ID --pid=container:$TARGET_ID --ipc=container:$TARGET_ID busybox 这就是 kubectl-debug 的出发点： 用工具容器来诊断业务容器 。背后的设计思路和 sidecar 等模式是一致的：每个容器只做一件事情。",
  "keywords": [
    "kubectl-debug"
  ],
  "articleBody": "背景 容器技术的一个最佳实践是构建尽可能精简的容器镜像。但这一实践却会给排查问题带来麻烦：精简后的容器中普遍缺失常用的排障工具，部分容器里甚至没有 shell (比如 FROM scratch ）。 在这种状况下，我们只能通过日志或者到宿主机上通过 docker-cli 或 nsenter 来排查问题，效率很低，在K8s环境部署应用后，经常遇到需要进入pod进行排错。除了查看pod logs和describe方式之外，传统的解决方式是在业务pod基础镜像中提前安装好procps、net-tools、tcpdump、vim等工具。但这样既不符合最小化镜像原则，又徒增Pod安全漏洞风险。\n今天为大家推荐一款K8s pod诊断工具，kubectl-debug是一个简单、易用、强大的 kubectl 插件, 能够帮助你便捷地进行 Kubernetes 上的 Pod 排障诊断。它通过启动一个排错工具容器，并将其加入到目标业务容器的pid, network, user 以及 ipc namespace 中，这时我们就可以在新容器中直接用 netstat, tcpdump 这些熟悉的工具来解决问题了, 而业务容器可以保持最小化, 不需要预装任何额外的排障工具。 kubectl-debug 主要包含以下两部分:\n kubectl-debug：命令行工具 debug-agent：部署在K8s的node上，用于启动关联排错工具容器  工作原理 我们知道，容器本质上是带有 cgroup 资源限制和 namespace 隔离的一组进程。因此，我们只要启动一个进程，并且让这个进程加入到目标容器的各种 namespace 中，这个进程就能 “进入容器内部”（注意引号），与容器中的进程”看到”相同的根文件系统、虚拟网卡、进程空间了——这也正是 docker exec 和 kubectl exec 等命令的运行方式。\n现在的状况是，我们不仅要 “进入容器内部”，还希望带一套工具集进去帮忙排查问题。那么，想要高效管理一套工具集，又要可以跨平台，最好的办法就是把工具本身都打包在一个容器镜像当中。 接下来，我们只需要通过这个”工具镜像”启动容器，再指定这个容器加入目标容器的的各种 namespace，自然就实现了 “携带一套工具集进入容器内部”。事实上，使用 docker-cli 就可以实现这个操作：\nexport TARGET_ID=666666666 # 加入目标容器的 network, pid 以及 ipc namespace docker run -it --network=container:$TARGET_ID --pid=container:$TARGET_ID --ipc=container:$TARGET_ID busybox 这就是 kubectl-debug 的出发点： 用工具容器来诊断业务容器 。背后的设计思路和 sidecar 等模式是一致的：每个容器只做一件事情。\n具体到实现上，一条 kubectl debug命令背后逻辑流程是这样的：\n步骤分别是:\n 插件查询 ApiServer：demo-pod 是否存在，所在节点是什么 ApiServer 返回 demo-pod 所在所在节点 插件请求在目标节点上创建 Debug Agent Pod Kubelet 创建 Debug Agent Pod 插件发现 Debug Agent 已经 Ready，发起 debug 请求（长连接） Debug Agent 收到 debug 请求，创建 Debug 容器并加入目标容器的各个 Namespace 中，创建完成后，与 Debug 容器的 tty 建立连接  接下来，客户端就可以开始通过 5，6 这两个连接开始 debug 操作。操作结束后，Debug Agent 清理 Debug 容器，插件清理 Debug Agent，一次 Debug 完成\n安装 github地址：https://github.com/aylei/kubectl-debug\n Mac 可以直接使用 brew 安装  brew install aylei/tap/kubectl-debug  通过下载二进制文件安装  export PLUGIN_VERSION=0.1.1 # linux x86_64 curl -Lo kubectl-debug.tar.gz https://github.com/aylei/kubectl-debug/releases/download/v${PLUGIN_VERSION}/kubectl-debug_${PLUGIN_VERSION}_linux_amd64.tar.gz # macos curl -Lo kubectl-debug.tar.gz https://github.com/aylei/kubectl-debug/releases/download/v${PLUGIN_VERSION}/kubectl-debug_${PLUGIN_VERSION}_darwin_amd64.tar.gz  tar -zxvf kubectl-debug.tar.gz kubectl-debug sudo mv kubectl-debug /usr/local/bin/ Windows 用户可以在Release 页面选择进行下载windows版本，加入环境变量使用\n其中github上有提供debug agent以DaemonSet的方式安装在集群中，但是daemonset模式，agent pod预先部署在所有node上，会始终占用资源，对于排错调试频率不高的环境造成资源浪费\n日常用法说明 简单使用 1、kubectl 1.12.0 或更高的版本, 可以直接使用\n#查看常用命令参数 kubectl debug -h kubectl 从 1.12 版本之后开始支持从 PATH 中自动发现插件。1.12 版本之前的 kubectl 不支持这种插件机制，但也可以通过命令名 kubectl-debug 直接调用。\n2、假如安装了 debug-agent 的 daemonset, 可以略去 –agentless 来加快启动速度，之后的命令里会略去 –agentless\nkubectl debug POD_NAME --daemonset-ns=default --daemonset-name=debug-agent 其中github上有提供debug agent以DaemonSet的方式安装在集群中，但是daemonset模式，agent pod预先部署在所有node上，会始终占用资源，对于排错调试频率不高的环境造成资源浪费，部署方式：kubectl apply -f https://raw.githubusercontent.com/aylei/kubectl-debug/master/scripts/agent_daemonset.yml\n3、agentless模式，kubectl-debug执行命令后，才创建agent pod和排错工具容器，并在退出后删除工具容器和agent pod。由于每次执行都要重新拉起agent，启动会比daemon-set模式稍慢。使用-a, –agentless开启agentless模式：\nkubectl debug POD_NAME --agentless --port-forward 4、假如 Node 没有公网 IP 或无法直接访问(防火墙等原因), 请使用 port-forward 模式\nkubectl debug POD_NAME --agentless --port-forward 进阶使用 1、排错init-container\nkubectl debug POD_NAME --container=init-pod 2、假如 Pod 处于 CrashLookBackoff 状态无法连接, 可以复制一个完全相同的 Pod 来进行诊断\nkubectl debug POD_NAME --fork 自定义镜像配置 --image：可自定义排错工具容器镜像，改为私有镜像仓库，默认为nicolaka/netshoot:latest --agent-image：在agentless模式下，自定义debug-agent镜像，默认为aylei/debug-agent:latest。在daemon-set模式下，直接将debug-agent daemonset pod template修改为私有仓库镜像即可 配置文件 ~/.kube/debug-config，通过配置文件修改默认参数，免去使用命令时设置flag。\n# debug agent listening port(outside container) default to 10027 agentPort: 10027 whether using agentless mode default to false agentless: true namespace of debug-agent pod, used in agentless mode default to 'default' agentPodNamespace: default prefix of debug-agent pod, used in agentless mode default to 'debug-agent-pod' agentPodNamePrefix: debug-agent-pod image of debug-agent pod, used in agentless mode default to 'aylei/debug-agent:latest' agentImage: aylei/debug-agent:latest daemonset name of the debug-agent, used in port-forward default to 'debug-agent' debugAgentDaemonset: debug-agent daemonset namespace of the debug-agent, used in port-forwad default to 'default' debugAgentNamespace: kube-system whether using port-forward when connecting debug-agent default false portForward: true image of the debug container default as showed image: nicolaka/netshoot:latest start command of the debug container default ['bash'] command: - '/bin/bash' - '-l' 典型案例 使用 iftop查看pod的网络流量 比如查看POD_NAME是kube-flannel-ds-amd64-2xwqp的网络流量：\n ~  kubectl debug kube-flannel-ds-amd64-2xwqp -n kube-system Agent Pod info: [Name:debug-agent-pod-b14bd868-61a9-11ec-bc72-acbc328370f3, Namespace:default, Image:registry.cn-hangzhou.aliyuncs.com/querycapimages/kubectl-debug-agent:latest, HostPort:10027, ContainerPort:10027] Waiting for pod debug-agent-pod-b14bd868-61a9-11ec-bc72-acbc328370f3 to run... Forwarding from 127.0.0.1:10027 - 10027 Forwarding from [::1]:10027 - 10027 Handling connection for 10027  set container procfs correct false .. pulling image registry.cn-hangzhou.aliyuncs.com/querycapimages/netshoot:latest, skip TLS false... latest: Pulling from querycapimages/netshoot Digest: sha256:f0eba49c9bf66600788d58779e57c2d7334708e12cb292ff8ccc9414c1b6730c Status: Image is up to date for registry.cn-hangzhou.aliyuncs.com/querycapimages/netshoot:latest starting debug container... container created, open tty... bash-5.0# iftop -i eth0 interface: eth0 IP address is: 172.17.3.3 MAC address is: 52:54:be:83:3a:e4 使用 drill 诊断 DNS 解析 比如查看POD_NAME是kube-flannel-ds-amd64-2xwqp的网络流量：\nbash-5.0# drill any www.baidu.com ;; -HEADERde: QUERY, rcode: NOERROR, id: 3214 ;; flags: qr rd ra ; QUERY: 1, ANSWER: 1, AUTHORITY: 5, ADDITIONAL: 3 ;; QUESTION SECTION: ;; www.baidu.com. IN ANY  ;; ANSWER SECTION: www.baidu.com. 803 IN CNAME www.a.shifen.com.  ;; AUTHORITY SECTION: baidu.com. 38993 IN NS ns4.baidu.com. baidu.com. 38993 IN NS ns3.baidu.com. baidu.com. 38993 IN NS ns7.baidu.com. baidu.com. 38993 IN NS dns.baidu.com. baidu.com. 38993 IN NS ns2.baidu.com.  ;; ADDITIONAL SECTION: ns2.baidu.com. 19348 IN A 220.181.33.31 ns3.baidu.com. 23022 IN A 112.80.248.64 ns7.baidu.com. 20697 IN A 180.76.76.92  ;; Query time: 1 msec ;; SERVER: 100.64.9.5 ;; WHEN: Mon Dec 20 15:37:35 2021 ;; MSG SIZE rcvd: 196 drill 命令详解：https://commandnotfound.cn/linux/1/533/drill-%E5%91%BD%E4%BB%A4\n使用 tcpdump 抓包 比如查看POD_NAME是kube-flannel-ds-amd64-2xwqp的网络流量：\nbash-5.0# tcpdump -i eth0 -c 1 -Xvv tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes 15:39:27.577342 IP (tos 0x0, ttl 63, id 41476, offset 0, flags [DF], proto TCP (6), length 89)  198.19.116.60.16710  172.17.3.3.6443: Flags [P.], cksum 0xf831 (correct), seq 677521811:677521848, ack 1388710574, win 1037, options [nop,nop,TS val 2849535414 ecr 1924260089], length 37  0x0000: 4500 0059 a204 4000 3f06 b036 c613 743c E..Y..@.?..6..t 0x0010: ac11 0303 4146 192b 2862 2993 52c6 0aae ....AF.+(b).R...  0x0020: 8018 040d f831 0000 0101 080a a9d8 75b6 .....1........u.  0x0030: 72b1 e0f9 1703 0300 2047 49f1 8fbb 2835 r........GI...(5  0x0040: 059a 5e82 0746 afaf bd2d 5af3 c797 16b5 ..^..F...-Z.....  0x0050: 8709 4666 7e61 6f5a 0b ..Ff~aoZ. 1 packet captured 18 packets received by filter 0 packets dropped by kernel bash-5.0# tcpdump -n -vvv -w /tmp/kube-flannel-ds-amd64-2xwqp.pcap tcpdump: listening on veth19416cac, link-type EN10MB (Ethernet), capture size 262144 bytes 50 packets captured 50 packets received by filter 0 packets dropped by kernel 这里需要注意，如果是想拿到-w抓包保存的文件用wireshark工具分析，则需要去POD_NAME对应的宿主机上拷贝出来进行分析\n[root@k8s-demo-master-01-2 ~]# docker ps |grep netshoot 58b918b67b3f registry.cn-hangzhou.aliyuncs.com/querycapimages/netshoot:latest \"bash\" 15 minutes ago Up 15 minutes unruffled_fermat [root@k8s-demo-master-01-2 ~]# docker cp 58b918b67b3f:/tmp/kube-flannel-ds-amd64-2xwqp.pcap . [root@k8s-demo-master-01-2 ~]# ll |grep kube-flannel-ds-amd64-2xwqp.pcap -rw-r--r-- 1 root root 5404 12月 20 23:41 kube-flannel-ds-amd64-2xwqp.pcap 诊断 CrashLoopBackoff 排查 CrashLoopBackoff 是一个很麻烦的问题，Pod 可能会不断重启， kubectl exec 和 kubectl debug 都没法稳定进行排查问题，基本上只能寄希望于 Pod 的日志中打印出了有用的信息。 为了让针对 CrashLoopBackoff 的排查更方便， kubectl-debug 参考 oc debug 命令，添加了一个 –fork 参数。当指定 –fork 时，插件会复制当前的 Pod Spec，做一些小修改， 再创建一个新 Pod：\n 新 Pod 的所有 Labels 会被删掉，避免 Service 将流量导到 fork 出的 Pod 上 新 Pod 的 ReadinessProbe 和 LivnessProbe 也会被移除，避免 kubelet 杀死 Pod 新 Pod 中目标容器（待排障的容器）的启动命令会被改写，避免新 Pod 继续 Crash  接下来，我们就可以在新 Pod 中尝试复现旧 Pod 中导致 Crash 的问题，示例pod_name为srv-es-driver-7445f6cf48-ff7bq的go服务。为了保证操作的一致性，可以先 chroot 到目标容器的根文件系统中：\n ~  kubectl-debug srv-es-driver-7445f6cf48-ff7bq -n devops --agentless --port-forward Agent Pod info: [Name:debug-agent-pod-177482f4-61ad-11ec-b297-acbc328370f3, Namespace:default, Image:registry.cn-hangzhou.aliyuncs.com/querycapimages/kubectl-debug-agent:latest, HostPort:10027, ContainerPort:10027] Waiting for pod debug-agent-pod-177482f4-61ad-11ec-b297-acbc328370f3 to run... Forwarding from 127.0.0.1:10027 - 10027 Forwarding from [::1]:10027 - 10027 Handling connection for 10027  set container procfs correct false .. pulling image registry.cn-hangzhou.aliyuncs.com/querycapimages/netshoot:latest, skip TLS false... latest: Pulling from querycapimages/netshoot Digest: sha256:f0eba49c9bf66600788d58779e57c2d7334708e12cb292ff8ccc9414c1b6730c Status: Image is up to date for registry.cn-hangzhou.aliyuncs.com/querycapimages/netshoot:latest starting debug container... container created, open tty... bash-5.0# ls bin mnt sys dev opt termshark_2.1.1_linux_x64 etc proc tmp home root usr lib run var lib64 sbin media srv bash-5.0# chroot /proc/1/root root@srv-es-driver-7445f6cf48-ff7bq:/# ls bin dev go lib media opt root sbin sys usr boot etc home lib64 mnt proc run srv tmp var root@srv-es-driver-7445f6cf48-ff7bq:/# cd /go/bin/ root@srv-es-driver-7445f6cf48-ff7bq:/go/bin# ls openapi.json srv-es-driver root@srv-es-driver-7445f6cf48-ff7bq:/go/bin# ./srv-es-driver  # 观察执行启动脚本时的信息并根据信息进一步排障 自定义image作为sidercar安装命令行调试 对于没有安装yum,apt-get 的镜像可以挂载 centos或者ubuntu的sidercar镜像, 再进行操作, 如安装 redis 命令, 再使用redis-cli 命令\n ~  kubectl-debug srv-es-driver-7445f6cf48-ff7bq -n devops --agentless --port-forward --image centos Agent Pod info: [Name:debug-agent-pod-f5077b08-61ad-11ec-8728-acbc328370f3, Namespace:default, Image:registry.cn-hangzhou.aliyuncs.com/querycapimages/kubectl-debug-agent:latest, HostPort:10027, ContainerPort:10027] Waiting for pod debug-agent-pod-f5077b08-61ad-11ec-8728-acbc328370f3 to run... Forwarding from 127.0.0.1:10027 - 10027 Forwarding from [::1]:10027 - 10027 Handling connection for 10027  set container procfs correct false .. pulling image centos, skip TLS false... latest: Pulling from library/centos a1d0c7532777: Pull complete Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177 Status: Downloaded newer image for centos:latest starting debug container... container created, open tty... [root@srv-es-driver-7445f6cf48-ff7bq /]# yum install -y redis  参考链接：\nhttps://aleiwu.com/post/kubectl-debug-intro/\n",
  "wordCount" : "1061",
  "inLanguage": "zh",
  "datePublished": "2022-02-18T11:24:51Z",
  "dateModified": "2022-02-18T11:24:51Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://iblog.zone/archives/%E8%B6%85%E5%A5%BD%E7%94%A8%E7%9A%84k8s%E4%B8%ADpod%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7kubectl-debug/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "ylw's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://iblog.zone/images/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://iblog.zone" accesskey="h" title="ylw&#39;s blog (Alt + H)">ylw&#39;s blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://iblog.zone/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://iblog.zone/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://iblog.zone/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://iblog.zone/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://iblog.zone/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://iblog.zone">主页</a>&nbsp;»&nbsp;<a href="https://iblog.zone/posts/">Posts</a></div>
    <h1 class="post-title">
      超好用的k8s中pod诊断工具：kubectl-debug
    </h1>
    <div class="post-meta"><span title='2022-02-18 11:24:51 +0000 UTC'>2022-02-18</span>&nbsp;·&nbsp;5 分钟

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e8%83%8c%e6%99%af" aria-label="背景">背景</a></li>
                    <li>
                        <a href="#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" aria-label="工作原理">工作原理</a></li>
                    <li>
                        <a href="#%e5%ae%89%e8%a3%85" aria-label="安装">安装</a></li>
                    <li>
                        <a href="#%e6%97%a5%e5%b8%b8%e7%94%a8%e6%b3%95%e8%af%b4%e6%98%8e" aria-label="日常用法说明">日常用法说明</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#%e7%ae%80%e5%8d%95%e4%bd%bf%e7%94%a8" aria-label="简单使用">简单使用</a></li>
                    <li>
                        <a href="#%e8%bf%9b%e9%98%b6%e4%bd%bf%e7%94%a8" aria-label="进阶使用">进阶使用</a></li>
                    <li>
                        <a href="#%e8%87%aa%e5%ae%9a%e4%b9%89%e9%95%9c%e5%83%8f%e9%85%8d%e7%bd%ae" aria-label="自定义镜像配置">自定义镜像配置</a></li>
                    <li>
                        <a href="#%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" aria-label="配置文件">配置文件</a></li></ul>
                        </ul>
                    </li>
                    <li>
                        <a href="#%e5%85%b8%e5%9e%8b%e6%a1%88%e4%be%8b" aria-label="典型案例">典型案例</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#%e4%bd%bf%e7%94%a8-iftop%e6%9f%a5%e7%9c%8bpod%e7%9a%84%e7%bd%91%e7%bb%9c%e6%b5%81%e9%87%8f" aria-label="使用 iftop查看pod的网络流量">使用 <strong>iftop</strong>查看pod的网络流量</a></li>
                    <li>
                        <a href="#%e4%bd%bf%e7%94%a8-drill-%e8%af%8a%e6%96%ad-dns-%e8%a7%a3%e6%9e%90" aria-label="使用 drill 诊断 DNS 解析">使用 <strong>drill</strong> 诊断 DNS 解析</a></li>
                    <li>
                        <a href="#%e4%bd%bf%e7%94%a8-tcpdump-%e6%8a%93%e5%8c%85" aria-label="使用 tcpdump 抓包">使用 <strong>tcpdump</strong> 抓包</a></li>
                    <li>
                        <a href="#%e8%af%8a%e6%96%ad-crashloopbackoff" aria-label="诊断 CrashLoopBackoff">诊断 CrashLoopBackoff</a></li>
                    <li>
                        <a href="#%e8%87%aa%e5%ae%9a%e4%b9%89image%e4%bd%9c%e4%b8%basidercar%e5%ae%89%e8%a3%85%e5%91%bd%e4%bb%a4%e8%a1%8c%e8%b0%83%e8%af%95" aria-label="自定义image作为sidercar安装命令行调试">自定义image作为sidercar安装命令行调试</a>
                    </li>
                </ul>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script data-cfasync="false">
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>


  <div class="post-content"><h2 id="背景">背景<a hidden class="anchor" aria-hidden="true" href="#背景">#</a></h2>
<p>容器技术的一个最佳实践是构建尽可能精简的容器镜像。但这一实践却会给排查问题带来麻烦：精简后的容器中普遍缺失常用的排障工具，部分容器里甚至没有 shell (比如 FROM scratch ）。 在这种状况下，我们只能通过日志或者到宿主机上通过 docker-cli 或 nsenter 来排查问题，效率很低，在K8s环境部署应用后，经常遇到需要进入pod进行排错。除了查看pod logs和describe方式之外，传统的解决方式是在业务pod基础镜像中提前安装好procps、net-tools、tcpdump、vim等工具。但这样既不符合最小化镜像原则，又徒增Pod安全漏洞风险。</p>
<p>今天为大家推荐一款K8s pod诊断工具，kubectl-debug是一个简单、易用、强大的 kubectl 插件, 能够帮助你便捷地进行 Kubernetes 上的 Pod 排障诊断。它通过启动一个排错工具容器，并将其加入到目标业务容器的pid, network, user 以及 ipc namespace 中，这时我们就可以在新容器中直接用 netstat, tcpdump 这些熟悉的工具来解决问题了, 而业务容器可以保持最小化, 不需要预装任何额外的排障工具。 kubectl-debug 主要包含以下两部分:</p>
<ul>
<li>kubectl-debug：命令行工具</li>
<li>debug-agent：部署在K8s的node上，用于启动关联排错工具容器</li>
</ul>
<h2 id="工作原理">工作原理<a hidden class="anchor" aria-hidden="true" href="#工作原理">#</a></h2>
<p>我们知道，容器本质上是带有 cgroup 资源限制和 namespace 隔离的一组进程。因此，我们只要启动一个进程，并且让这个进程加入到目标容器的各种 namespace 中，这个进程就能 “进入容器内部”（注意引号），与容器中的进程”看到”相同的根文件系统、虚拟网卡、进程空间了——这也正是 docker exec 和 kubectl exec 等命令的运行方式。</p>
<p>现在的状况是，我们不仅要 “进入容器内部”，还希望带一套工具集进去帮忙排查问题。那么，想要高效管理一套工具集，又要可以跨平台，最好的办法就是把工具本身都打包在一个容器镜像当中。 接下来，我们只需要通过这个”工具镜像”启动容器，再指定这个容器加入目标容器的的各种 namespace，自然就实现了 “携带一套工具集进入容器内部”。事实上，使用 docker-cli 就可以实现这个操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>export TARGET_ID<span style="color:#f92672">=</span><span style="color:#ae81ff">666666666</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 加入目标容器的 network, pid 以及 ipc namespace</span>
</span></span><span style="display:flex;"><span>docker run -it --network<span style="color:#f92672">=</span>container:$TARGET_ID --pid<span style="color:#f92672">=</span>container:$TARGET_ID --ipc<span style="color:#f92672">=</span>container:$TARGET_ID busybox
</span></span></code></pre></div><p>这就是 kubectl-debug 的出发点： 用工具容器来诊断业务容器 。背后的设计思路和 sidecar 等模式是一致的：每个容器只做一件事情。</p>
<p>具体到实现上，一条 kubectl debug命令背后逻辑流程是这样的：</p>
<p><img loading="lazy" src="/images/%e8%b6%85%e5%a5%bd%e7%94%a8%e7%9a%84k8s%e4%b8%adpod%e8%af%8a%e6%96%ad%e5%b7%a5%e5%85%b7%ef%bc%9akubectl-debug/640.webp" alt=""  />
</p>
<p>步骤分别是:</p>
<ol>
<li>插件查询 ApiServer：demo-pod 是否存在，所在节点是什么</li>
<li>ApiServer 返回 demo-pod 所在所在节点</li>
<li>插件请求在目标节点上创建 Debug Agent Pod</li>
<li>Kubelet 创建 Debug Agent Pod</li>
<li>插件发现 Debug Agent 已经 Ready，发起 debug 请求（长连接）</li>
<li>Debug Agent 收到 debug 请求，创建 Debug 容器并加入目标容器的各个 Namespace 中，创建完成后，与 Debug 容器的 tty 建立连接</li>
</ol>
<p>接下来，客户端就可以开始通过 5，6 这两个连接开始 debug 操作。操作结束后，Debug Agent 清理 Debug 容器，插件清理 Debug Agent，一次 Debug 完成</p>
<h2 id="安装">安装<a hidden class="anchor" aria-hidden="true" href="#安装">#</a></h2>
<p>github地址：https://github.com/aylei/kubectl-debug</p>
<ul>
<li>Mac 可以直接使用 brew 安装</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>brew install aylei/tap/kubectl-debug
</span></span></code></pre></div><ul>
<li>通过下载二进制文件安装</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>export PLUGIN_VERSION<span style="color:#f92672">=</span>0.1.1
</span></span><span style="display:flex;"><span><span style="color:#75715e"># linux x86_64</span>
</span></span><span style="display:flex;"><span>curl -Lo kubectl-debug.tar.gz https://github.com/aylei/kubectl-debug/releases/download/v<span style="color:#e6db74">${</span>PLUGIN_VERSION<span style="color:#e6db74">}</span>/kubectl-debug_<span style="color:#e6db74">${</span>PLUGIN_VERSION<span style="color:#e6db74">}</span>_linux_amd64.tar.gz
</span></span><span style="display:flex;"><span><span style="color:#75715e"># macos</span>
</span></span><span style="display:flex;"><span>curl -Lo kubectl-debug.tar.gz https://github.com/aylei/kubectl-debug/releases/download/v<span style="color:#e6db74">${</span>PLUGIN_VERSION<span style="color:#e6db74">}</span>/kubectl-debug_<span style="color:#e6db74">${</span>PLUGIN_VERSION<span style="color:#e6db74">}</span>_darwin_amd64.tar.gz
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>tar -zxvf kubectl-debug.tar.gz kubectl-debug
</span></span><span style="display:flex;"><span>sudo mv kubectl-debug /usr/local/bin/
</span></span></code></pre></div><p>Windows 用户可以在Release 页面选择进行下载windows版本，加入环境变量使用</p>
<p>其中github上有提供debug agent以DaemonSet的方式安装在集群中，但是daemonset模式，agent pod预先部署在所有node上，会始终占用资源，对于排错调试频率不高的环境造成资源浪费</p>
<h2 id="日常用法说明">日常用法说明<a hidden class="anchor" aria-hidden="true" href="#日常用法说明">#</a></h2>
<h4 id="简单使用">简单使用<a hidden class="anchor" aria-hidden="true" href="#简单使用">#</a></h4>
<p>1、kubectl 1.12.0 或更高的版本, 可以直接使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#查看常用命令参数</span>
</span></span><span style="display:flex;"><span>kubectl debug -h
</span></span></code></pre></div><p>kubectl 从 1.12 版本之后开始支持从 PATH 中自动发现插件。1.12 版本之前的 kubectl 不支持这种插件机制，但也可以通过命令名 kubectl-debug 直接调用。</p>
<p>2、假如安装了 debug-agent 的 daemonset, 可以略去 &ndash;agentless 来加快启动速度，之后的命令里会略去 &ndash;agentless</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>kubectl debug POD_NAME --daemonset-ns<span style="color:#f92672">=</span>default --daemonset-name<span style="color:#f92672">=</span>debug-agent
</span></span></code></pre></div><p>其中github上有提供debug agent以DaemonSet的方式安装在集群中，但是daemonset模式，agent pod预先部署在所有node上，会始终占用资源，对于排错调试频率不高的环境造成资源浪费，部署方式：kubectl apply -f <a href="https://raw.githubusercontent.com/aylei/kubectl-debug/master/scripts/agent_daemonset.yml">https://raw.githubusercontent.com/aylei/kubectl-debug/master/scripts/agent_daemonset.yml</a></p>
<p>3、agentless模式，kubectl-debug执行命令后，才创建agent pod和排错工具容器，并在退出后删除工具容器和agent pod。由于每次执行都要重新拉起agent，启动会比daemon-set模式稍慢。使用-a, &ndash;agentless开启agentless模式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>kubectl debug POD_NAME --agentless --port-forward
</span></span></code></pre></div><p>4、假如 Node 没有公网 IP 或无法直接访问(防火墙等原因), 请使用 port-forward 模式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>kubectl debug POD_NAME --agentless --port-forward
</span></span></code></pre></div><h4 id="进阶使用">进阶使用<a hidden class="anchor" aria-hidden="true" href="#进阶使用">#</a></h4>
<p>1、排错init-container</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>kubectl debug POD_NAME --container<span style="color:#f92672">=</span>init-pod
</span></span></code></pre></div><p>2、假如 Pod 处于 CrashLookBackoff 状态无法连接, 可以复制一个完全相同的 Pod 来进行诊断</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>kubectl debug POD_NAME --fork
</span></span></code></pre></div><h4 id="自定义镜像配置">自定义镜像配置<a hidden class="anchor" aria-hidden="true" href="#自定义镜像配置">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>--image：可自定义排错工具容器镜像，改为私有镜像仓库，默认为nicolaka/netshoot:latest
</span></span><span style="display:flex;"><span>--agent-image：在agentless模式下，自定义debug-agent镜像，默认为aylei/debug-agent:latest。在daemon-set模式下，直接将debug-agent daemonset pod template修改为私有仓库镜像即可
</span></span></code></pre></div><h4 id="配置文件">配置文件<a hidden class="anchor" aria-hidden="true" href="#配置文件">#</a></h4>
<p>~/.kube/debug-config，通过配置文件修改默认参数，免去使用命令时设置flag。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># debug agent listening port(outside container)</span>
</span></span><span style="display:flex;"><span>default to <span style="color:#ae81ff">10027</span>
</span></span><span style="display:flex;"><span>agentPort: <span style="color:#ae81ff">10027</span>
</span></span><span style="display:flex;"><span>whether using agentless mode
</span></span><span style="display:flex;"><span>default to false
</span></span><span style="display:flex;"><span>agentless: true
</span></span><span style="display:flex;"><span>namespace of debug-agent pod, used in agentless mode
</span></span><span style="display:flex;"><span>default to <span style="color:#e6db74">&#39;default&#39;</span>
</span></span><span style="display:flex;"><span>agentPodNamespace: default
</span></span><span style="display:flex;"><span>prefix of debug-agent pod, used in agentless mode
</span></span><span style="display:flex;"><span>default to  <span style="color:#e6db74">&#39;debug-agent-pod&#39;</span>
</span></span><span style="display:flex;"><span>agentPodNamePrefix: debug-agent-pod
</span></span><span style="display:flex;"><span>image of debug-agent pod, used in agentless mode
</span></span><span style="display:flex;"><span>default to <span style="color:#e6db74">&#39;aylei/debug-agent:latest&#39;</span>
</span></span><span style="display:flex;"><span>agentImage: aylei/debug-agent:latest
</span></span><span style="display:flex;"><span>daemonset name of the debug-agent, used in port-forward
</span></span><span style="display:flex;"><span>default to <span style="color:#e6db74">&#39;debug-agent&#39;</span>
</span></span><span style="display:flex;"><span>debugAgentDaemonset: debug-agent
</span></span><span style="display:flex;"><span>daemonset namespace of the debug-agent, used in port-forwad
</span></span><span style="display:flex;"><span>default to <span style="color:#e6db74">&#39;default&#39;</span>
</span></span><span style="display:flex;"><span>debugAgentNamespace: kube-system
</span></span><span style="display:flex;"><span>whether using port-forward when connecting debug-agent
</span></span><span style="display:flex;"><span>default false
</span></span><span style="display:flex;"><span>portForward: true
</span></span><span style="display:flex;"><span>image of the debug container
</span></span><span style="display:flex;"><span>default as showed
</span></span><span style="display:flex;"><span>image: nicolaka/netshoot:latest
</span></span><span style="display:flex;"><span>start command of the debug container
</span></span><span style="display:flex;"><span>default <span style="color:#f92672">[</span><span style="color:#e6db74">&#39;bash&#39;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>command:
</span></span><span style="display:flex;"><span>- <span style="color:#e6db74">&#39;/bin/bash&#39;</span>
</span></span><span style="display:flex;"><span>- <span style="color:#e6db74">&#39;-l&#39;</span>
</span></span></code></pre></div><h2 id="典型案例">典型案例<a hidden class="anchor" aria-hidden="true" href="#典型案例">#</a></h2>
<h4 id="使用-iftop查看pod的网络流量">使用 <strong>iftop</strong>查看pod的网络流量<a hidden class="anchor" aria-hidden="true" href="#使用-iftop查看pod的网络流量">#</a></h4>
<p>比如查看POD_NAME是kube-flannel-ds-amd64-2xwqp的网络流量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> ~  kubectl debug kube-flannel-ds-amd64-2xwqp -n kube-system
</span></span><span style="display:flex;"><span>Agent Pod info: <span style="color:#f92672">[</span>Name:debug-agent-pod-b14bd868-61a9-11ec-bc72-acbc328370f3, Namespace:default, Image:registry.cn-hangzhou.aliyuncs.com/querycapimages/kubectl-debug-agent:latest, HostPort:10027, ContainerPort:10027<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>Waiting <span style="color:#66d9ef">for</span> pod debug-agent-pod-b14bd868-61a9-11ec-bc72-acbc328370f3 to run...
</span></span><span style="display:flex;"><span>Forwarding from 127.0.0.1:10027 -&gt; <span style="color:#ae81ff">10027</span>
</span></span><span style="display:flex;"><span>Forwarding from <span style="color:#f92672">[</span>::1<span style="color:#f92672">]</span>:10027 -&gt; <span style="color:#ae81ff">10027</span>
</span></span><span style="display:flex;"><span>Handling connection <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">10027</span>
</span></span><span style="display:flex;"><span>                             set container procfs correct false ..
</span></span><span style="display:flex;"><span>pulling image registry.cn-hangzhou.aliyuncs.com/querycapimages/netshoot:latest, skip TLS false...
</span></span><span style="display:flex;"><span>latest: Pulling from querycapimages/netshoot
</span></span><span style="display:flex;"><span>Digest: sha256:f0eba49c9bf66600788d58779e57c2d7334708e12cb292ff8ccc9414c1b6730c
</span></span><span style="display:flex;"><span>Status: Image is up to date <span style="color:#66d9ef">for</span> registry.cn-hangzhou.aliyuncs.com/querycapimages/netshoot:latest
</span></span><span style="display:flex;"><span>starting debug container...
</span></span><span style="display:flex;"><span>container created, open tty...
</span></span><span style="display:flex;"><span>bash-5.0# iftop -i eth0
</span></span><span style="display:flex;"><span>interface: eth0
</span></span><span style="display:flex;"><span>IP address is: 172.17.3.3
</span></span><span style="display:flex;"><span>MAC address is: 52:54:be:83:3a:e4
</span></span></code></pre></div><h4 id="使用-drill-诊断-dns-解析">使用 <strong>drill</strong> 诊断 DNS 解析<a hidden class="anchor" aria-hidden="true" href="#使用-drill-诊断-dns-解析">#</a></h4>
<p>比如查看POD_NAME是kube-flannel-ds-amd64-2xwqp的网络流量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>bash-5.0# drill any www.baidu.com
</span></span><span style="display:flex;"><span>;; -&gt;&gt;HEADER<span style="color:#e6db74">&lt;&lt;- opco</span>de: QUERY, rcode: NOERROR, id: <span style="color:#ae81ff">3214</span>
</span></span><span style="display:flex;"><span>;; flags: qr rd ra ; QUERY: 1, ANSWER: 1, AUTHORITY: 5, ADDITIONAL: <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>;; QUESTION SECTION:
</span></span><span style="display:flex;"><span>;; www.baidu.com. IN ANY
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>;; ANSWER SECTION:
</span></span><span style="display:flex;"><span>www.baidu.com. <span style="color:#ae81ff">803</span> IN CNAME www.a.shifen.com.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>;; AUTHORITY SECTION:
</span></span><span style="display:flex;"><span>baidu.com. <span style="color:#ae81ff">38993</span> IN NS ns4.baidu.com.
</span></span><span style="display:flex;"><span>baidu.com. <span style="color:#ae81ff">38993</span> IN NS ns3.baidu.com.
</span></span><span style="display:flex;"><span>baidu.com. <span style="color:#ae81ff">38993</span> IN NS ns7.baidu.com.
</span></span><span style="display:flex;"><span>baidu.com. <span style="color:#ae81ff">38993</span> IN NS dns.baidu.com.
</span></span><span style="display:flex;"><span>baidu.com. <span style="color:#ae81ff">38993</span> IN NS ns2.baidu.com.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>;; ADDITIONAL SECTION:
</span></span><span style="display:flex;"><span>ns2.baidu.com. <span style="color:#ae81ff">19348</span> IN A 220.181.33.31
</span></span><span style="display:flex;"><span>ns3.baidu.com. <span style="color:#ae81ff">23022</span> IN A 112.80.248.64
</span></span><span style="display:flex;"><span>ns7.baidu.com. <span style="color:#ae81ff">20697</span> IN A 180.76.76.92
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>;; Query time: <span style="color:#ae81ff">1</span> msec
</span></span><span style="display:flex;"><span>;; SERVER: 100.64.9.5
</span></span><span style="display:flex;"><span>;; WHEN: Mon Dec <span style="color:#ae81ff">20</span> 15:37:35 <span style="color:#ae81ff">2021</span>
</span></span><span style="display:flex;"><span>;; MSG SIZE  rcvd: <span style="color:#ae81ff">196</span>
</span></span></code></pre></div><p>drill 命令详解：https://commandnotfound.cn/linux/1/533/drill-%E5%91%BD%E4%BB%A4</p>
<h4 id="使用-tcpdump-抓包">使用 <strong>tcpdump</strong> 抓包<a hidden class="anchor" aria-hidden="true" href="#使用-tcpdump-抓包">#</a></h4>
<p>比如查看POD_NAME是kube-flannel-ds-amd64-2xwqp的网络流量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>bash-5.0# tcpdump -i eth0 -c <span style="color:#ae81ff">1</span> -Xvv
</span></span><span style="display:flex;"><span>tcpdump: listening on eth0, link-type EN10MB <span style="color:#f92672">(</span>Ethernet<span style="color:#f92672">)</span>, capture size <span style="color:#ae81ff">262144</span> bytes
</span></span><span style="display:flex;"><span>15:39:27.577342 IP <span style="color:#f92672">(</span>tos 0x0, ttl 63, id 41476, offset 0, flags <span style="color:#f92672">[</span>DF<span style="color:#f92672">]</span>, proto TCP <span style="color:#f92672">(</span>6<span style="color:#f92672">)</span>, length 89<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    198.19.116.60.16710 &gt; 172.17.3.3.6443: Flags <span style="color:#f92672">[</span>P.<span style="color:#f92672">]</span>, cksum 0xf831 <span style="color:#f92672">(</span>correct<span style="color:#f92672">)</span>, seq 677521811:677521848, ack 1388710574, win 1037, options <span style="color:#f92672">[</span>nop,nop,TS val <span style="color:#ae81ff">2849535414</span> ecr 1924260089<span style="color:#f92672">]</span>, length <span style="color:#ae81ff">37</span>
</span></span><span style="display:flex;"><span> 0x0000:  <span style="color:#ae81ff">4500</span> <span style="color:#ae81ff">0059</span> a204 <span style="color:#ae81ff">4000</span> 3f06 b036 c613 743c  E..Y..@.?..6..t&lt;
</span></span><span style="display:flex;"><span> 0x0010:  ac11 <span style="color:#ae81ff">0303</span> <span style="color:#ae81ff">4146</span> 192b <span style="color:#ae81ff">2862</span> <span style="color:#ae81ff">2993</span> 52c6 0aae  ....AF.+<span style="color:#f92672">(</span>b<span style="color:#f92672">)</span>.R...
</span></span><span style="display:flex;"><span> 0x0020:  <span style="color:#ae81ff">8018</span> 040d f831 <span style="color:#ae81ff">0000</span> <span style="color:#ae81ff">0101</span> 080a a9d8 75b6  .....1........u.
</span></span><span style="display:flex;"><span> 0x0030:  72b1 e0f9 <span style="color:#ae81ff">1703</span> <span style="color:#ae81ff">0300</span> <span style="color:#ae81ff">2047</span> 49f1 8fbb <span style="color:#ae81ff">2835</span>  r........GI...<span style="color:#f92672">(</span><span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span> 0x0040:  059a 5e82 <span style="color:#ae81ff">0746</span> afaf bd2d 5af3 c797 16b5  ..^..F...-Z.....
</span></span><span style="display:flex;"><span> 0x0050:  <span style="color:#ae81ff">8709</span> <span style="color:#ae81ff">4666</span> 7e61 6f5a 0b                   ..Ff~aoZ.
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span> packet captured
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">18</span> packets received by filter
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span> packets dropped by kernel
</span></span><span style="display:flex;"><span>bash-5.0# tcpdump -n -vvv -w /tmp/kube-flannel-ds-amd64-2xwqp.pcap
</span></span><span style="display:flex;"><span>tcpdump: listening on veth19416cac, link-type EN10MB <span style="color:#f92672">(</span>Ethernet<span style="color:#f92672">)</span>, capture size <span style="color:#ae81ff">262144</span> bytes
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">50</span> packets captured
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">50</span> packets received by filter
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span> packets dropped by kernel
</span></span></code></pre></div><p>这里需要注意，如果是想拿到-w抓包保存的文件用wireshark工具分析，则需要去POD_NAME对应的宿主机上拷贝出来进行分析</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-demo-master-01-2 ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker ps |grep netshoot</span>
</span></span><span style="display:flex;"><span>58b918b67b3f        registry.cn-hangzhou.aliyuncs.com/querycapimages/netshoot:latest       <span style="color:#e6db74">&#34;bash&#34;</span>                   <span style="color:#ae81ff">15</span> minutes ago      Up <span style="color:#ae81ff">15</span> minutes                           unruffled_fermat
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-demo-master-01-2 ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker cp 58b918b67b3f:/tmp/kube-flannel-ds-amd64-2xwqp.pcap .</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-demo-master-01-2 ~<span style="color:#f92672">]</span><span style="color:#75715e"># ll |grep kube-flannel-ds-amd64-2xwqp.pcap</span>
</span></span><span style="display:flex;"><span>-rw-r--r--  <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">5404</span> 12月 <span style="color:#ae81ff">20</span> 23:41 kube-flannel-ds-amd64-2xwqp.pcap
</span></span></code></pre></div><h4 id="诊断-crashloopbackoff">诊断 CrashLoopBackoff<a hidden class="anchor" aria-hidden="true" href="#诊断-crashloopbackoff">#</a></h4>
<p>排查 CrashLoopBackoff 是一个很麻烦的问题，Pod 可能会不断重启， kubectl exec 和 kubectl debug 都没法稳定进行排查问题，基本上只能寄希望于 Pod 的日志中打印出了有用的信息。 为了让针对 CrashLoopBackoff 的排查更方便， kubectl-debug 参考 oc debug 命令，添加了一个 &ndash;fork 参数。当指定 &ndash;fork 时，插件会复制当前的 Pod Spec，做一些小修改， 再创建一个新 Pod：</p>
<ul>
<li>新 Pod 的所有 Labels 会被删掉，避免 Service 将流量导到 fork 出的 Pod 上</li>
<li>新 Pod 的 ReadinessProbe 和 LivnessProbe 也会被移除，避免 kubelet 杀死 Pod</li>
<li>新 Pod 中目标容器（待排障的容器）的启动命令会被改写，避免新 Pod 继续 Crash</li>
</ul>
<p>接下来，我们就可以在新 Pod 中尝试复现旧 Pod 中导致 Crash 的问题，示例pod_name为srv-es-driver-7445f6cf48-ff7bq的go服务。为了保证操作的一致性，可以先 chroot 到目标容器的根文件系统中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> ~  kubectl-debug srv-es-driver-7445f6cf48-ff7bq -n devops --agentless --port-forward
</span></span><span style="display:flex;"><span>Agent Pod info: <span style="color:#f92672">[</span>Name:debug-agent-pod-177482f4-61ad-11ec-b297-acbc328370f3, Namespace:default, Image:registry.cn-hangzhou.aliyuncs.com/querycapimages/kubectl-debug-agent:latest, HostPort:10027, ContainerPort:10027<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>Waiting <span style="color:#66d9ef">for</span> pod debug-agent-pod-177482f4-61ad-11ec-b297-acbc328370f3 to run...
</span></span><span style="display:flex;"><span>Forwarding from 127.0.0.1:10027 -&gt; <span style="color:#ae81ff">10027</span>
</span></span><span style="display:flex;"><span>Forwarding from <span style="color:#f92672">[</span>::1<span style="color:#f92672">]</span>:10027 -&gt; <span style="color:#ae81ff">10027</span>
</span></span><span style="display:flex;"><span>Handling connection <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">10027</span>
</span></span><span style="display:flex;"><span>                             set container procfs correct false ..
</span></span><span style="display:flex;"><span>pulling image registry.cn-hangzhou.aliyuncs.com/querycapimages/netshoot:latest, skip TLS false...
</span></span><span style="display:flex;"><span>latest: Pulling from querycapimages/netshoot
</span></span><span style="display:flex;"><span>Digest: sha256:f0eba49c9bf66600788d58779e57c2d7334708e12cb292ff8ccc9414c1b6730c
</span></span><span style="display:flex;"><span>Status: Image is up to date <span style="color:#66d9ef">for</span> registry.cn-hangzhou.aliyuncs.com/querycapimages/netshoot:latest
</span></span><span style="display:flex;"><span>starting debug container...
</span></span><span style="display:flex;"><span>container created, open tty...
</span></span><span style="display:flex;"><span>bash-5.0# ls
</span></span><span style="display:flex;"><span>bin                        mnt                        sys
</span></span><span style="display:flex;"><span>dev                        opt                        termshark_2.1.1_linux_x64
</span></span><span style="display:flex;"><span>etc                        proc                       tmp
</span></span><span style="display:flex;"><span>home                       root                       usr
</span></span><span style="display:flex;"><span>lib                        run                        var
</span></span><span style="display:flex;"><span>lib64                      sbin
</span></span><span style="display:flex;"><span>media                      srv
</span></span><span style="display:flex;"><span>bash-5.0# chroot /proc/1/root
</span></span><span style="display:flex;"><span>root@srv-es-driver-7445f6cf48-ff7bq:/# ls
</span></span><span style="display:flex;"><span>bin   dev  go  lib media  opt   root  sbin  sys  usr
</span></span><span style="display:flex;"><span>boot  etc  home  lib64 mnt    proc  run   srv  tmp  var
</span></span><span style="display:flex;"><span>root@srv-es-driver-7445f6cf48-ff7bq:/# cd /go/bin/
</span></span><span style="display:flex;"><span>root@srv-es-driver-7445f6cf48-ff7bq:/go/bin# ls
</span></span><span style="display:flex;"><span>openapi.json  srv-es-driver
</span></span><span style="display:flex;"><span>root@srv-es-driver-7445f6cf48-ff7bq:/go/bin# ./srv-es-driver
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># 观察执行启动脚本时的信息并根据信息进一步排障</span>
</span></span></code></pre></div><h4 id="自定义image作为sidercar安装命令行调试">自定义image作为sidercar安装命令行调试<a hidden class="anchor" aria-hidden="true" href="#自定义image作为sidercar安装命令行调试">#</a></h4>
<p>对于没有安装yum,apt-get 的镜像可以挂载 centos或者ubuntu的sidercar镜像, 再进行操作, 如安装 redis 命令, 再使用redis-cli 命令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> ~  kubectl-debug srv-es-driver-7445f6cf48-ff7bq -n devops --agentless --port-forward --image centos
</span></span><span style="display:flex;"><span>Agent Pod info: <span style="color:#f92672">[</span>Name:debug-agent-pod-f5077b08-61ad-11ec-8728-acbc328370f3, Namespace:default, Image:registry.cn-hangzhou.aliyuncs.com/querycapimages/kubectl-debug-agent:latest, HostPort:10027, ContainerPort:10027<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>Waiting <span style="color:#66d9ef">for</span> pod debug-agent-pod-f5077b08-61ad-11ec-8728-acbc328370f3 to run...
</span></span><span style="display:flex;"><span>Forwarding from 127.0.0.1:10027 -&gt; <span style="color:#ae81ff">10027</span>
</span></span><span style="display:flex;"><span>Forwarding from <span style="color:#f92672">[</span>::1<span style="color:#f92672">]</span>:10027 -&gt; <span style="color:#ae81ff">10027</span>
</span></span><span style="display:flex;"><span>Handling connection <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">10027</span>
</span></span><span style="display:flex;"><span>                             set container procfs correct false ..
</span></span><span style="display:flex;"><span>pulling image centos, skip TLS false...
</span></span><span style="display:flex;"><span>latest: Pulling from library/centos
</span></span><span style="display:flex;"><span>a1d0c7532777: Pull complete
</span></span><span style="display:flex;"><span>Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177
</span></span><span style="display:flex;"><span>Status: Downloaded newer image <span style="color:#66d9ef">for</span> centos:latest
</span></span><span style="display:flex;"><span>starting debug container...
</span></span><span style="display:flex;"><span>container created, open tty...
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@srv-es-driver-7445f6cf48-ff7bq /<span style="color:#f92672">]</span><span style="color:#75715e"># yum install -y redis</span>
</span></span><span style="display:flex;"><span> 
</span></span></code></pre></div><p>参考链接：</p>
<p><a href="https://aleiwu.com/post/kubectl-debug-intro/">https://aleiwu.com/post/kubectl-debug-intro/</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://iblog.zone/tags/kubectl-debug/">kubectl-debug</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://iblog.zone/archives/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8harbor/">
    <span class="title">« 上一页</span>
    <br>
    <span>生产环境搭建高可用Harbor</span>
  </a>
  <a class="next" href="https://iblog.zone/archives/java%E5%B8%B8%E7%94%A8api/">
    <span class="title">下一页 »</span>
    <br>
    <span>Java常用API</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://iblog.zone">ylw&#39;s blog</a></span>
    <span>
	& <a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2021039488号</a>
    </span>

    总访客：<span id="busuanzi_value_site_uv"></span>
    总浏览量：<span id="busuanzi_value_site_pv"></span>
    页面访问量：<span id="busuanzi_value_page_pv"></span>

</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '复制';

        function copyingDone() {
            copybutton.innerText = '已复制！';
            setTimeout(() => {
                copybutton.innerText = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
