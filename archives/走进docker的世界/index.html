<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>走进Docker的世界 | ylw&#39;s blog</title>
<meta name="keywords" content="docker, k8s" />
<meta name="description" content="第一天 走进Docker的世界 介绍docker的前世今生，了解docker的实现原理，以Django项目为例，带大家如何编写最佳的Dockerfile构建镜像。通过本章的学习，大家会知道docker的概念及基本操作，并学会构建自己的业务镜像，并通过抓包的方式掌握Docker最常用的bridge网络模式的通信。
认识docker  why what how  为什么出现docker 需要一种轻量、高效的虚拟化能力
Docker 公司位于旧金山,原名dotCloud，底层利用了Linux容器技术（LXC）（在操作系统中实现资源隔离与限制）。为了方便创建和管理这些容器，dotCloud 开发了一套内部工具，之后被命名为“Docker”。Docker就是这样诞生的。
Hypervisor： 一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件 。常见的VMware的 Workstation 、ESXi、微软的Hyper-V或者思杰的XenServer。
Container Runtime：通过Linux内核虚拟化能力管理多个容器，多个容器共享一套操作系统内核。因此摘掉了内核占用的空间及运行所需要的耗时，使得容器极其轻量与快速。
什么是docker 基于操作系统内核，提供轻量级虚拟化功能的CS架构的软件产品。
基于轻量的特性，解决软件交付过程中的环境依赖
docker能做什么  可以把应用程序代码及运行依赖环境打包成镜像，作为交付介质，在各环境部署 可以将镜像（image）启动成为容器(container)，并且提供多容器的生命周期进行管理（启、停、删） container容器之间相互隔离，且每个容器可以设置资源限额 提供轻量级虚拟化功能，容器就是在宿主机中的一个个的虚拟的空间，彼此相互隔离，完全独立  版本管理  Docker 引擎主要有两个版本：企业版（EE）和社区版（CE） 每个季度(1-3,4-6,7-9,10-12)，企业版和社区版都会发布一个稳定版本(Stable)。社区版本会提供 4 个月的支持，而企业版本会提供 12 个月的支持 每个月社区版还会通过 Edge 方式发布月度版 从 2017 年第一季度开始，Docker 版本号遵循 YY.MM-xx 格式，类似于 Ubuntu 等项目。例如，2018 年 6 月第一次发布的社区版本为 18.06.0-ce  发展史 13年成立，15年开始，迎来了飞速发展。
Docker 1.8之前，使用LXC，Docker在上层做了封装， 把LXC复杂的容器创建与使用方式简化为自己的一套命令体系。
之后，为了实现跨平台等复杂的场景，Docker抽出了libcontainer项目，把对namespace、cgroup的操作封装在libcontainer项目里，支持不同的平台类型。
2015年6月，Docker牵头成立了 OCI（Open Container Initiative开放容器计划）组织，这个组织的目的是建立起一个围绕容器的通用标准 。 容器格式标准是一种不受上层结构绑定的协议，即不限于某种特定操作系统、硬件、CPU架构、公有云等 ， 允许任何人在遵循该标准的情况下开发应用容器技术，这使得容器技术有了一个更广阔的发展空间。">
<meta name="author" content="">
<link rel="canonical" href="https://iblog.zone/archives/%E8%B5%B0%E8%BF%9Bdocker%E7%9A%84%E4%B8%96%E7%95%8C/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7af5e4f048c756d5896f15b3f7cd7ee898ea1b3b101fcb40abfb5216ca230ecf.css" integrity="sha256-evXk8EjHVtWJbxWz981&#43;6JjqGzsQH8tAq/tSFsojDs8=" rel="preload stylesheet" as="style">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://iblog.zone/images/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://iblog.zone/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="https://iblog.zone/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="https://iblog.zone/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="https://iblog.zone/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel='stylesheet' href='//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>

<meta property="og:title" content="走进Docker的世界" />
<meta property="og:description" content="第一天 走进Docker的世界 介绍docker的前世今生，了解docker的实现原理，以Django项目为例，带大家如何编写最佳的Dockerfile构建镜像。通过本章的学习，大家会知道docker的概念及基本操作，并学会构建自己的业务镜像，并通过抓包的方式掌握Docker最常用的bridge网络模式的通信。
认识docker  why what how  为什么出现docker 需要一种轻量、高效的虚拟化能力
Docker 公司位于旧金山,原名dotCloud，底层利用了Linux容器技术（LXC）（在操作系统中实现资源隔离与限制）。为了方便创建和管理这些容器，dotCloud 开发了一套内部工具，之后被命名为“Docker”。Docker就是这样诞生的。
Hypervisor： 一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件 。常见的VMware的 Workstation 、ESXi、微软的Hyper-V或者思杰的XenServer。
Container Runtime：通过Linux内核虚拟化能力管理多个容器，多个容器共享一套操作系统内核。因此摘掉了内核占用的空间及运行所需要的耗时，使得容器极其轻量与快速。
什么是docker 基于操作系统内核，提供轻量级虚拟化功能的CS架构的软件产品。
基于轻量的特性，解决软件交付过程中的环境依赖
docker能做什么  可以把应用程序代码及运行依赖环境打包成镜像，作为交付介质，在各环境部署 可以将镜像（image）启动成为容器(container)，并且提供多容器的生命周期进行管理（启、停、删） container容器之间相互隔离，且每个容器可以设置资源限额 提供轻量级虚拟化功能，容器就是在宿主机中的一个个的虚拟的空间，彼此相互隔离，完全独立  版本管理  Docker 引擎主要有两个版本：企业版（EE）和社区版（CE） 每个季度(1-3,4-6,7-9,10-12)，企业版和社区版都会发布一个稳定版本(Stable)。社区版本会提供 4 个月的支持，而企业版本会提供 12 个月的支持 每个月社区版还会通过 Edge 方式发布月度版 从 2017 年第一季度开始，Docker 版本号遵循 YY.MM-xx 格式，类似于 Ubuntu 等项目。例如，2018 年 6 月第一次发布的社区版本为 18.06.0-ce  发展史 13年成立，15年开始，迎来了飞速发展。
Docker 1.8之前，使用LXC，Docker在上层做了封装， 把LXC复杂的容器创建与使用方式简化为自己的一套命令体系。
之后，为了实现跨平台等复杂的场景，Docker抽出了libcontainer项目，把对namespace、cgroup的操作封装在libcontainer项目里，支持不同的平台类型。
2015年6月，Docker牵头成立了 OCI（Open Container Initiative开放容器计划）组织，这个组织的目的是建立起一个围绕容器的通用标准 。 容器格式标准是一种不受上层结构绑定的协议，即不限于某种特定操作系统、硬件、CPU架构、公有云等 ， 允许任何人在遵循该标准的情况下开发应用容器技术，这使得容器技术有了一个更广阔的发展空间。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://iblog.zone/archives/%E8%B5%B0%E8%BF%9Bdocker%E7%9A%84%E4%B8%96%E7%95%8C/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-30T15:35:39&#43;00:00" />
<meta property="article:modified_time" content="2021-12-30T15:35:39&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="走进Docker的世界"/>
<meta name="twitter:description" content="第一天 走进Docker的世界 介绍docker的前世今生，了解docker的实现原理，以Django项目为例，带大家如何编写最佳的Dockerfile构建镜像。通过本章的学习，大家会知道docker的概念及基本操作，并学会构建自己的业务镜像，并通过抓包的方式掌握Docker最常用的bridge网络模式的通信。
认识docker  why what how  为什么出现docker 需要一种轻量、高效的虚拟化能力
Docker 公司位于旧金山,原名dotCloud，底层利用了Linux容器技术（LXC）（在操作系统中实现资源隔离与限制）。为了方便创建和管理这些容器，dotCloud 开发了一套内部工具，之后被命名为“Docker”。Docker就是这样诞生的。
Hypervisor： 一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件 。常见的VMware的 Workstation 、ESXi、微软的Hyper-V或者思杰的XenServer。
Container Runtime：通过Linux内核虚拟化能力管理多个容器，多个容器共享一套操作系统内核。因此摘掉了内核占用的空间及运行所需要的耗时，使得容器极其轻量与快速。
什么是docker 基于操作系统内核，提供轻量级虚拟化功能的CS架构的软件产品。
基于轻量的特性，解决软件交付过程中的环境依赖
docker能做什么  可以把应用程序代码及运行依赖环境打包成镜像，作为交付介质，在各环境部署 可以将镜像（image）启动成为容器(container)，并且提供多容器的生命周期进行管理（启、停、删） container容器之间相互隔离，且每个容器可以设置资源限额 提供轻量级虚拟化功能，容器就是在宿主机中的一个个的虚拟的空间，彼此相互隔离，完全独立  版本管理  Docker 引擎主要有两个版本：企业版（EE）和社区版（CE） 每个季度(1-3,4-6,7-9,10-12)，企业版和社区版都会发布一个稳定版本(Stable)。社区版本会提供 4 个月的支持，而企业版本会提供 12 个月的支持 每个月社区版还会通过 Edge 方式发布月度版 从 2017 年第一季度开始，Docker 版本号遵循 YY.MM-xx 格式，类似于 Ubuntu 等项目。例如，2018 年 6 月第一次发布的社区版本为 18.06.0-ce  发展史 13年成立，15年开始，迎来了飞速发展。
Docker 1.8之前，使用LXC，Docker在上层做了封装， 把LXC复杂的容器创建与使用方式简化为自己的一套命令体系。
之后，为了实现跨平台等复杂的场景，Docker抽出了libcontainer项目，把对namespace、cgroup的操作封装在libcontainer项目里，支持不同的平台类型。
2015年6月，Docker牵头成立了 OCI（Open Container Initiative开放容器计划）组织，这个组织的目的是建立起一个围绕容器的通用标准 。 容器格式标准是一种不受上层结构绑定的协议，即不限于某种特定操作系统、硬件、CPU架构、公有云等 ， 允许任何人在遵循该标准的情况下开发应用容器技术，这使得容器技术有了一个更广阔的发展空间。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://iblog.zone/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "走进Docker的世界",
      "item": "https://iblog.zone/archives/%E8%B5%B0%E8%BF%9Bdocker%E7%9A%84%E4%B8%96%E7%95%8C/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "走进Docker的世界",
  "name": "走进Docker的世界",
  "description": "第一天 走进Docker的世界 介绍docker的前世今生，了解docker的实现原理，以Django项目为例，带大家如何编写最佳的Dockerfile构建镜像。通过本章的学习，大家会知道docker的概念及基本操作，并学会构建自己的业务镜像，并通过抓包的方式掌握Docker最常用的bridge网络模式的通信。\n认识docker  why what how  为什么出现docker 需要一种轻量、高效的虚拟化能力\nDocker 公司位于旧金山,原名dotCloud，底层利用了Linux容器技术（LXC）（在操作系统中实现资源隔离与限制）。为了方便创建和管理这些容器，dotCloud 开发了一套内部工具，之后被命名为“Docker”。Docker就是这样诞生的。\nHypervisor： 一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件 。常见的VMware的 Workstation 、ESXi、微软的Hyper-V或者思杰的XenServer。\nContainer Runtime：通过Linux内核虚拟化能力管理多个容器，多个容器共享一套操作系统内核。因此摘掉了内核占用的空间及运行所需要的耗时，使得容器极其轻量与快速。\n什么是docker 基于操作系统内核，提供轻量级虚拟化功能的CS架构的软件产品。\n基于轻量的特性，解决软件交付过程中的环境依赖\ndocker能做什么  可以把应用程序代码及运行依赖环境打包成镜像，作为交付介质，在各环境部署 可以将镜像（image）启动成为容器(container)，并且提供多容器的生命周期进行管理（启、停、删） container容器之间相互隔离，且每个容器可以设置资源限额 提供轻量级虚拟化功能，容器就是在宿主机中的一个个的虚拟的空间，彼此相互隔离，完全独立  版本管理  Docker 引擎主要有两个版本：企业版（EE）和社区版（CE） 每个季度(1-3,4-6,7-9,10-12)，企业版和社区版都会发布一个稳定版本(Stable)。社区版本会提供 4 个月的支持，而企业版本会提供 12 个月的支持 每个月社区版还会通过 Edge 方式发布月度版 从 2017 年第一季度开始，Docker 版本号遵循 YY.MM-xx 格式，类似于 Ubuntu 等项目。例如，2018 年 6 月第一次发布的社区版本为 18.06.0-ce  发展史 13年成立，15年开始，迎来了飞速发展。\nDocker 1.8之前，使用LXC，Docker在上层做了封装， 把LXC复杂的容器创建与使用方式简化为自己的一套命令体系。\n之后，为了实现跨平台等复杂的场景，Docker抽出了libcontainer项目，把对namespace、cgroup的操作封装在libcontainer项目里，支持不同的平台类型。\n2015年6月，Docker牵头成立了 OCI（Open Container Initiative开放容器计划）组织，这个组织的目的是建立起一个围绕容器的通用标准 。 容器格式标准是一种不受上层结构绑定的协议，即不限于某种特定操作系统、硬件、CPU架构、公有云等 ， 允许任何人在遵循该标准的情况下开发应用容器技术，这使得容器技术有了一个更广阔的发展空间。",
  "keywords": [
    "docker", "k8s"
  ],
  "articleBody": "第一天 走进Docker的世界 介绍docker的前世今生，了解docker的实现原理，以Django项目为例，带大家如何编写最佳的Dockerfile构建镜像。通过本章的学习，大家会知道docker的概念及基本操作，并学会构建自己的业务镜像，并通过抓包的方式掌握Docker最常用的bridge网络模式的通信。\n认识docker  why what how  为什么出现docker 需要一种轻量、高效的虚拟化能力\nDocker 公司位于旧金山,原名dotCloud，底层利用了Linux容器技术（LXC）（在操作系统中实现资源隔离与限制）。为了方便创建和管理这些容器，dotCloud 开发了一套内部工具，之后被命名为“Docker”。Docker就是这样诞生的。\nHypervisor： 一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件 。常见的VMware的 Workstation 、ESXi、微软的Hyper-V或者思杰的XenServer。\nContainer Runtime：通过Linux内核虚拟化能力管理多个容器，多个容器共享一套操作系统内核。因此摘掉了内核占用的空间及运行所需要的耗时，使得容器极其轻量与快速。\n什么是docker 基于操作系统内核，提供轻量级虚拟化功能的CS架构的软件产品。\n基于轻量的特性，解决软件交付过程中的环境依赖\ndocker能做什么  可以把应用程序代码及运行依赖环境打包成镜像，作为交付介质，在各环境部署 可以将镜像（image）启动成为容器(container)，并且提供多容器的生命周期进行管理（启、停、删） container容器之间相互隔离，且每个容器可以设置资源限额 提供轻量级虚拟化功能，容器就是在宿主机中的一个个的虚拟的空间，彼此相互隔离，完全独立  版本管理  Docker 引擎主要有两个版本：企业版（EE）和社区版（CE） 每个季度(1-3,4-6,7-9,10-12)，企业版和社区版都会发布一个稳定版本(Stable)。社区版本会提供 4 个月的支持，而企业版本会提供 12 个月的支持 每个月社区版还会通过 Edge 方式发布月度版 从 2017 年第一季度开始，Docker 版本号遵循 YY.MM-xx 格式，类似于 Ubuntu 等项目。例如，2018 年 6 月第一次发布的社区版本为 18.06.0-ce  发展史 13年成立，15年开始，迎来了飞速发展。\nDocker 1.8之前，使用LXC，Docker在上层做了封装， 把LXC复杂的容器创建与使用方式简化为自己的一套命令体系。\n之后，为了实现跨平台等复杂的场景，Docker抽出了libcontainer项目，把对namespace、cgroup的操作封装在libcontainer项目里，支持不同的平台类型。\n2015年6月，Docker牵头成立了 OCI（Open Container Initiative开放容器计划）组织，这个组织的目的是建立起一个围绕容器的通用标准 。 容器格式标准是一种不受上层结构绑定的协议，即不限于某种特定操作系统、硬件、CPU架构、公有云等 ， 允许任何人在遵循该标准的情况下开发应用容器技术，这使得容器技术有了一个更广阔的发展空间。\nOCI成立后，libcontainer 交给OCI组织来维护，但是libcontainer中只包含了与kernel交互的库，因此基于libcontainer项目，后面又加入了一个CLI工具，并且项目改名为runC (https://github.com/opencontainers/runc )， 目前runC已经成为一个功能强大的runtime工具。\nDocker也做了架构调整。将容器运行时相关的程序从docker daemon剥离出来，形成了containerd。containerd向上为Docker Daemon提供了gRPC接口，使得Docker Daemon屏蔽下面的结构变化，确保原有接口向下兼容。向下通过containerd-shim结合runC，使得引擎可以独立升级，避免之前Docker Daemon升级会导致所有容器不可用的问题。\n也就是说\n runC（libcontainer）是符合OCI标准的一个实现，与底层系统交互 containerd是实现了OCI之上的容器的高级功能，比如镜像管理、容器执行的调用等 Dockerd目前是最上层与CLI交互的进程，接收cli的请求并与containerd协作  小结  为了提供一种更加轻量的虚拟化技术，docker出现了 借助于docker容器的轻、快等特性，解决了软件交付过程中的环境依赖问题，使得docker得以快速发展 Docker是一种CS架构的软件产品，可以把代码及依赖打包成镜像，作为交付介质，并且把镜像启动成为容器，提供容器生命周期的管理 docker-ce，每季度发布stable版本。18.06，18.09，19.03 发展至今，docker已经通过制定OCI标准对最初的项目做了拆分，其中runC和containerd是docker的核心项目，理解docker整个请求的流程，对我们深入理解docker有很大的帮助  安装 配置宿主机网卡转发 ## 若未配置，需要执行如下 $ cat /etc/sysctl.d/docker.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward=1 EOF $ sysctl -p /etc/sysctl.d/docker.conf Yum安装配置docker ## 下载阿里源repo文件 $ curl -o /etc/yum.repos.d/Centos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo $ curl -o /etc/yum.repos.d/docker-ce.repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo  $ yum clean all \u0026\u0026 yum makecache ## yum安装 $ yum install docker-ce-20.10.6 -y ## 查看源中可用版本 $ yum list docker-ce --showduplicates | sort -r ## 安装旧版本 ##yum install -y docker-ce-18.09.9  ## 配置源加速 ## https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors mkdir -p /etc/docker vi /etc/docker/daemon.json {  \"registry-mirrors\" : [  \"https://8xpk5wnt.mirror.aliyuncs.com\"  ] }  ## 设置开机自启 systemctl enable docker systemctl daemon-reload  ## 启动docker systemctl start docker  ## 查看docker信息 docker info  ## docker-client which docker ## docker daemon ps aux |grep docker ## containerd ps aux|grep containerd systemctl status containerd 核心要素及常用操作详解 三大核心要素：镜像(Image)、容器(Container)、仓库(Registry)\n镜像（Image） 打包了业务代码及运行环境的包，是静态的文件，不能直接对外提供服务。\n容器（Container） 镜像的运行时，可以对外提供服务。\n仓库（Registry） 存放镜像的地方\n 公有仓库，Docker Hub，阿里，网易… 私有仓库，企业内部搭建  Docker Registry，Docker官方提供的镜像仓库存储服务 Harbor, 是Docker Registry的更高级封装，它除了提供友好的Web UI界面，角色和用户权限管理，用户操作审计等功能   镜像访问地址形式 registry.devops.com/demo/hello:latest,若没有前面的url地址，则默认寻找Docker Hub中的镜像，若没有tag标签，则使用latest作为标签。 比如，docker pull nginx，会被解析成docker.io/library/nginx:latest 公有的仓库中，一般存在这么几类镜像  操作系统基础镜像（centos，ubuntu，suse，alpine） 中间件（nginx，redis，mysql，tomcat） 语言编译环境（python，java，golang） 业务镜像（django-demo…）    容器和仓库不会直接交互，都是以镜像为载体来操作。\n  查看镜像列表\n$ docker images   如何获取镜像\n  从远程仓库拉取\n$ docker pull nginx:alpine $ docker images   使用tag命令\n$ docker tag nginx:alpine 172.21.51.143:5000/nginx:alpine $ docker images   本地构建\n$ docker build . -t my-nginx:ubuntu -f Dockerfile     如何通过镜像启动容器\n$ docker run --name my-nginx-alpine -d nginx:alpine   如何知道容器内部运行了什么程序？\n# 进入容器内部,分配一个tty终端 $ docker exec -ti my-nginx-alpine /bin/sh # ps aux   docker怎么知道容器启动后该执行什么命令？\n通过docker build来模拟构建一个nginx的镜像，\n  创建Dockerfile\n# 告诉docker使用哪个基础镜像作为模板，后续命令都以这个镜像为基础  FROM ubuntu # RUN命令会在上面指定的镜像里执行命令  RUN apt-get update \u0026\u0026 apt install -y nginx #告诉docker，启动容器时执行如下命令 CMD [\"/usr/sbin/nginx\", \"-g\",\"daemon off;\"]   构建本地镜像\n$ docker build . -t my-nginx:ubuntu -f Dockerfile       使用新镜像启动容器\n $ docker run --name my-nginx-ubuntu -d my-nginx:ubuntu   进入容器查看进程\n $ docker exec -ti my-nginx-ubuntu /bin/sh  # ps aux     如何访问容器内服务\n# 进入容器内部 $ docker exec -ti my-nginx-alpine /bin/sh # ps aux|grep nginx # curl localhost:80   宿主机中如何访问容器服务\n# 删掉旧服务,重新启动 $ docker rm -f my-nginx-alpine $ docker run --name my-nginx-alpine -d -p 8080:80 nginx:alpine $ curl 172.21.51.143:8080   docker client如何与daemon通信\n# /var/run/docker.sock $ docker run --name portainer -d -p 9001:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer   操作演示  查看所有镜像：  $ docker images  拉取镜像:  $ docker pull nginx:alpine  如何唯一确定镜像:   image_id repository:tag  $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE nginx alpine 377c0837328f 2 weeks ago 19.7MB   导出镜像到文件中\n$ docker save -o nginx-alpine.tar nginx:alpine   从文件中加载镜像\n$ docker load -i nginx-alpine.tar   部署镜像仓库\nhttps://docs.docker.com/registry/\n## 使用docker镜像启动镜像仓库服务 $ docker run -d -p 5000:5000 --restart always --name registry registry:2  ## 默认仓库不带认证，若需要认证，参考https://docs.docker.com/registry/deploying/#restricting-access   推送本地镜像到镜像仓库中\n$ docker tag nginx:alpine localhost:5000/nginx:alpine $ docker push localhost:5000/nginx:alpine ## 查看仓库内元数据 $ curl -X GET http://172.21.51.143:5000/v2/_catalog $ curl -X GET http://172.21.51.143:5000/v2/nginx/tags/list ## 镜像仓库给外部访问，不能通过localhost，尝试使用内网地址172.21.51.143:5000/nginx:alpine $ docker tag nginx:alpine 172.21.51.143:5000/nginx:alpine $ docker push 172.21.51.143:5000/nginx:alpine The push refers to repository [172.21.51.143:5000/nginx] Get https://172.21.51.143:5000/v2/: http: server gave HTTP response to HTTPS client ## docker默认不允许向http的仓库地址推送，如何做成https的，参考：https://docs.docker.com/registry/deploying/#run-an-externally-accessible-registry ## 我们没有可信证书机构颁发的证书和域名，自签名证书需要在每个节点中拷贝证书文件，比较麻烦，因此我们通过配置daemon的方式，来跳过证书的验证： $ cat /etc/docker/daemon.json {  \"registry-mirrors\": [  \"https://8xpk5wnt.mirror.aliyuncs.com\"  ],  \"insecure-registries\": [  \"172.21.51.143:5000\"  ] } $ systemctl restart docker $ docker push 172.21.51.143:5000/nginx:alpine $ docker images # IMAGE ID相同，等于起别名或者加快捷方式 REPOSITORY TAG IMAGE ID CREATED SIZE 172.21.51.143:5000/nginx alpine 377c0837328f 4 weeks ago nginx alpine 377c0837328f 4 weeks ago localhost:5000/nginx alpine 377c0837328f 4 weeks ago registry 2 708bc6af7e5e 2 months ago   删除镜像\n$ docker rmi nginx:alpine   查看容器列表\n## 查看运行状态的容器列表 $ docker ps ## 查看全部状态的容器列表 $ docker ps -a   启动容器\n## 后台启动 $ docker run --name nginx -d nginx:alpine ## 映射端口,把容器的端口映射到宿主机中,-p : $ docker run --name nginx -d -p 8080:80 nginx:alpine ## 资源限制,最大可用内存500M $ docker run --memory=500m nginx:alpine   容器数据持久化\n## 挂载主机目录 $ docker run --name nginx -d -v /opt:/opt nginx:alpine $ docker run --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d -v /opt/mysql/:/var/lib/mysql mysql:5.7   进入容器或者执行容器内的命令\n $ docker exec -ti  /bin/sh  $ docker exec  hostname   主机与容器之间拷贝数据\n ## 主机拷贝到容器  $ echo '123'/tmp/test.txt  $ docker cp /tmp/test.txt nginx:/tmp  $ docker exec -ti nginx cat /tmp/test.txt  123  ## 容器拷贝到主机  $ docker cp nginx:/tmp/test.txt ./   挂载已有的数据，重新创建镜像仓库容器\n## 解压离线镜像文件 $ tar zxf registry.tar.gz -C /opt ## 删除当前镜像仓库容器 $ docker rm -f registry ## 使用docker镜像启动镜像仓库服务 $ docker run -d -p 5000:5000 --restart always -v /opt/registry:/var/lib/registry --name registry registry:2 假设启动镜像仓库服务的主机地址为172.21.51.143，该目录中已存在的镜像列表：\n   现镜像仓库地址 原镜像仓库地址     172.21.51.143:5000/coreos/flannel:v0.11.0-amd64 quay.io/coreos/flannel:v0.11.0-amd64   172.21.51.143:5000/mysql:5.7 mysql:5.7   172.21.51.143:5000/nginx:alpine nginx:alpine   172.21.51.143:5000/centos:centos7.5.1804 centos:centos7.5.1804   172.21.51.143:5000/elasticsearch/elasticsearch:7.4.2 docker.elastic.co/elasticsearch/elasticsearch:7.4.2   172.21.51.143:5000/fluentd-es-root:v1.6.2-1.0 quay.io/fluentd_elasticsearch/fluentd:v2.5.2   172.21.51.143:5000/kibana/kibana:7.4.2 docker.elastic.co/kibana/kibana:7.4.2   172.21.51.143:5000/kubernetesui/dashboard:v2.0.0-beta5 kubernetesui/dashboard:v2.0.0-beta5   172.21.51.143:5000/kubernetesui/metrics-scraper:v1.0.1 kubernetesui/metrics-scraper:v1.0.1   172.21.51.143:5000/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0 quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0   172.21.51.143:5000/jenkinsci/blueocean:latest jenkinsci/blueocean:latest   172.21.51.143:5000/sonarqube:7.9-community sonarqube:7.9-community   172.21.51.143:5000/postgres:11.4 postgres:11.4      查看容器日志\n ## 查看全部日志  $ docker logs nginx  ## 实时查看最新日志  $ docker logs -f nginx  ## 从最新的100条开始查看  $ docker logs --tail=100 -f nginx   停止或者删除容器\n ## 停止运行中的容器  $ docker stop nginx  ## 启动退出容器  $ docker start nginx  ## 删除非运行中状态的容器  $ docker rm nginx  ## 删除运行中的容器  $ docker rm -f nginx   查看容器或者镜像的明细\n ## 查看容器详细信息，包括容器IP地址等  $ docker inspect nginx  ## 查看镜像的明细信息  $ docker inspect nginx:alpine   Dockerfile使用 $ docker build . -t ImageName:ImageTag -f Dockerfile Dockerfile是一堆指令，在docker build的时候，按照该指令进行操作，最终生成我们期望的镜像\n  FROM 指定基础镜像，必须为第一个命令\n格式： FROM  FROM :示例： FROM mysql:5.7注意： tag是可选的，如果不使用tag时，会使用latest版本的基础镜像  MAINTAINER 镜像维护者的信息\n格式：\tMAINTAINER 示例：\tMAINTAINER Yongxin Li MAINTAINER inspur_lyx@hotmail.com MAINTAINER Yongxin Li   COPY|ADD 添加本地文件到镜像中\n格式： COPY ... 示例： ADD hom* /mydir/ # 添加所有以\"hom\"开头的文件 ADD test relativeDir/ # 添加 \"test\" 到 `WORKDIR`/relativeDir/ ADD test /absoluteDir/ # 添加 \"test\" 到 /absoluteDir/  WORKDIR 工作目录\n格式：\tWORKDIR /path/to/workdir 示例： WORKDIR /a (这时工作目录为/a)注意： 通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行  RUN 构建镜像过程中执行命令\n格式： RUN 示例： RUN yum install nginx RUN pip install django RUN mkdir test \u0026\u0026 rm -rf /var/lib/unusedfiles注意： RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache  CMD 构建容器后调用，也就是在容器启动时才进行调用\n格式： CMD [\"executable\",\"param1\",\"param2\"] (执行可执行文件，优先) CMD [\"param1\",\"param2\"] (设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数) CMD command param1 param2 (执行shell内部命令)示例： CMD [\"/usr/bin/wc\",\"--help\"] CMD ping www.baidu.com注意： CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。  ENTRYPOINT 设置容器初始化命令，使其可执行化\n格式： ENTRYPOINT [\"executable\", \"param1\", \"param2\"] (可执行文件, 优先) ENTRYPOINT command param1 param2 (shell内部命令)示例： ENTRYPOINT [\"/usr/bin/wc\",\"--help\"]注意：\tENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令  ENV\n格式： ENV   ENV =示例： ENV myName John ENV myCat=fluffy  EXPOSE\n格式： EXPOSE  [...]示例： EXPOSE 80 443 EXPOSE 8080 EXPOSE 11211/tcp 11211/udp注意： EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口  基础环境镜像\nFROMjava:8-alpineRUN apk add --update ca-certificates \u0026\u0026 rm -rf /var/cache/apk/* \u0026\u0026 \\  find /usr/share/ca-certificates/mozilla/ -name \"*.crt\" -exec keytool -import -trustcacerts \\  -keystore /usr/lib/jvm/java-1.8-openjdk/jre/lib/security/cacerts -storepass changeit -noprompt \\  -file {} -alias {} \\; \u0026\u0026 \\  keytool -list -keystore /usr/lib/jvm/java-1.8-openjdk/jre/lib/security/cacerts --storepass changeitENV MAVEN_VERSION 3.5.4ENV MAVEN_HOME /usr/lib/mvnENV PATH $MAVEN_HOME/bin:$PATHRUN wget http://archive.apache.org/dist/maven/maven-3/$MAVEN_VERSION/binaries/apache-maven-$MAVEN_VERSION-bin.tar.gz \u0026\u0026 \\  tar -zxvf apache-maven-$MAVEN_VERSION-bin.tar.gz \u0026\u0026 \\  rm apache-maven-$MAVEN_VERSION-bin.tar.gz \u0026\u0026 \\  mv apache-maven-$MAVEN_VERSION /usr/lib/mvnRUN mkdir -p /usr/src/appWORKDIR/usr/src/app  前端镜像\nFROMnginx:1.19.0-alpineLABEL maintainer=\"mritd \"ARG TZ='Asia/Shanghai'ENV TZ ${TZ}RUN apk upgrade --update \\  \u0026\u0026 apk add bash tzdata curl wget ca-certificates \\  \u0026\u0026 ln -sf /usr/share/zoneinfo/${TZ} /etc/localtime \\  \u0026\u0026 echo ${TZ}  /etc/timezone \\  \u0026\u0026 rm -rf /usr/share/nginx/html /var/cache/apk/*COPY landscape-animation-experiment /usr/share/nginx/htmlEXPOSE80 443CMD [\"nginx\", \"-g\", \"daemon off;\"]  java镜像\nFROMjava:8u111ENV JAVA_OPTS \"\\ -Xmx4096m \\ -XX:MetaspaceSize=256m \\ -XX:MaxMetaspaceSize=256m\"ENV JAVA_HOME /usr/java/jdkENV PATH ${PATH}:${JAVA_HOME}/binCOPY target/myapp.jar myapp.jarRUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimeRUN echo 'Asia/Shanghai' /etc/timezoneEXPOSE9000CMD java ${JAVA_OPTS} -jar myapp.jar  golang镜像\n多阶段构建\n  多阶构建 https://gitee.com/agagin/href-counter.git\n原始构建：\nFROMgolang:1.13WORKDIR/go/src/github.com/alexellis/href-counter/COPY vendor vendorCOPY app.go .ENV GOPROXY https://goproxy.cnRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .$ docker build . -t href-counter:v1 -f Dockerfile多阶构建：\nFROMgolang:1.13 AS builderWORKDIR/go/src/github.com/alexellis/href-counter/COPY vendor vendorCOPY app.go .ENV GOPROXY https://goproxy.cnRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .FROMalpine:3.10RUN apk --no-cache add ca-certificatesWORKDIR/root/COPY --from=builder /go/src/github.com/alexellis/href-counter/app .CMD [\"./app\"]$ docker build . -t href-counter:v2 -f Dockerfile.multi原则：\n 不必要的内容不要放在镜像中 减少不必要的层文件 减少网络传输操作 可以适当的包含一些调试命令  通过1号进程理解容器的本质 $ docker exec -ti my-nginx-alpine /bin/sh #/ ps aux 容器启动的时候可以通过命令去覆盖默认的CMD\n$ docker run -d --name xxx nginx:alpine  # 会覆盖镜像中指定的CMD指令，作为容器的1号进程启动。  $ docker run -d --name test-3 nginx:alpine echo 123  $ docker run -d --name test-4 nginx:alpine ping www.luffycity.com 本质上讲容器是利用namespace和cgroup等技术在宿主机中创建的独立的虚拟空间，这个空间内的网络、进程、挂载等资源都是隔离的。\n$ docker exec -ti my-nginx /bin/sh #/ ip addr #/ ls -l / #/ apt install xxx #/ #安装的软件对宿主机和其他容器没有任何影响，和虚拟机不同的是，容器间共享一个内核，所以容器内没法升级内核 Django应用容器化实践 django项目介绍  项目地址：https://gitee.com/agagin/python-demo.git python3 + django + uwsgi + nginx + mysql 内部服务端口8002  容器化Django项目 dockerfiles/myblog/Dockerfile\n# This my first django Dockerfile# Version 1.0# Base images 基础镜像FROMcentos:centos7.5.1804#MAINTAINER 维护者信息LABEL maintainer=\"inspur_lyx@hotmail.com\"#ENV 设置环境变量ENV LANG en_US.UTF-8ENV LC_ALL en_US.UTF-8#RUN 执行以下命令RUN curl -so /etc/yum.repos.d/Centos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo \u0026\u0026 rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpmRUN yum install -y python36 python3-devel gcc pcre-devel zlib-devel make net-tools nginx#工作目录WORKDIR/opt/myblog#拷贝文件至工作目录COPY . .# 拷贝nginx配置文件COPY myblog.conf /etc/nginx#安装依赖的插件RUN pip3 install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com -r requirements.txtRUN chmod +x run.sh \u0026\u0026 rm -rf ~/.cache/pip#EXPOSE 映射端口EXPOSE8002#容器启动时执行命令CMD [\"./run.sh\"]执行构建：\n$ docker build . -t myblog:v1 -f Dockerfile 运行mysql $ docker run -d -p 3306:3306 --name mysql -v /opt/mysql:/var/lib/mysql -e MYSQL_DATABASE=myblog -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci  ## 参数传递 ## 查看数据库 $ docker exec -ti mysql bash #/ mysql -uroot -p123456 #/ show databases;  ## navicator连接 启动Django应用 ## 启动容器 $ docker run -d -p 8002:8002 --name myblog -e MYSQL_HOST=172.21.51.143 -e MYSQL_USER=root -e MYSQL_PASSWD=123456 myblog:v1  ## migrate $ docker exec -ti myblog bash #/ python3 manage.py makemigrations #/ python3 manage.py migrate #/ python3 manage.py createsuperuser  ## 创建超级用户 $ docker exec -ti myblog python3 manage.py createsuperuser  ## 收集静态文件 ## $ docker exec -ti myblog python3 manage.py collectstatic 访问172.21.51.143:8002/admin\n实现原理 docker优势：\n  轻量级的虚拟化\n  容器快速启停\n  虚拟化核心需要解决的问题：资源隔离与资源限制\n 虚拟机硬件虚拟化技术， 通过一个 hypervisor 层实现对资源的彻底隔离。 容器则是操作系统级别的虚拟化，利用的是内核的 Cgroup 和 Namespace 特性，此功能完全通过软件实现。  Namespace 资源隔离 命名空间是全局资源的一种抽象，将资源放到不同的命名空间中，各个命名空间中的资源是相互隔离的。\n   分类 系统调用参数 相关内核版本     Mount namespaces CLONE_NEWNS Linux 2.4.19   UTS namespaces CLONE_NEWUTS Linux 2.6.19   IPC namespaces CLONE_NEWIPC Linux 2.6.19   PID namespaces CLONE_NEWPID Linux 2.6.24   Network namespaces CLONE_NEWNET 始于Linux 2.6.24 完成于 Linux 2.6.29   User namespaces CLONE_NEWUSER 始于 Linux 2.6.23 完成于 Linux 3.8    我们知道，docker容器对于操作系统来讲其实是一个进程，我们可以通过原始的方式来模拟一下容器实现资源隔离的基本原理：\nlinux系统中，通常可以通过clone()实现进程创建的系统调用 ，原型如下：\nint clone(int (*child_func)(void *), void *child_stack, int flags, void *arg);  child_func : 传入子进程运行的程序主函数。 child_stack : 传入子进程使用的栈空间。 flags : 表示使用哪些 CLONE_* 标志位。 args : 用于传入用户参数。  示例一：实现进程独立的UTS空间\n#define _GNU_SOURCE #include  #include #include #include #include #include #include #define STACK_SIZE (1024 * 1024) static char container_stack[STACK_SIZE]; char* const container_args[] = {  \"/bin/bash\",  NULL };  int container_main(void* arg) {  printf(\"Container - inside the container!\\n\");  sethostname(\"container\",10); /* 设置hostname */  execv(container_args[0], container_args);  printf(\"Something's wrong!\\n\");  return 1; }  int main() {  printf(\"Parent - start a container!\\n\");  int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | SIGCHLD , NULL);  waitpid(container_pid, NULL, 0);  printf(\"Parent - container stopped!\\n\");  return 0; } 执行编译并测试：\n$ gcc -o ns_uts ns_uts.c $ ./ns_uts $ hostname 示例二：实现容器独立的进程空间\n#define _GNU_SOURCE #include  #include #include #include #include #include #include #define STACK_SIZE (1024 * 1024) static char container_stack[STACK_SIZE]; char* const container_args[] = {  \"/bin/bash\",  NULL };  int container_main(void* arg) {  printf(\"Container [%5d] - inside the container!\\n\", getpid());  sethostname(\"container\",10); /* 设置hostname */  execv(container_args[0], container_args);  printf(\"Something's wrong!\\n\");  return 1; }  int main() {  printf(\"Parent [%5d] - start a container!\\n\", getpid());  int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD , NULL);  waitpid(container_pid, NULL, 0);  printf(\"Parent - container stopped!\\n\");  return 0; } 执行编译并测试：\n$ gcc -o ns_pid ns_pid.c $ ./ns_pid $ echo $$ 如何确定进程是否属于同一个namespace：\n$ ./ns_pid Parent [ 8061] - start a container! $ pstree -p 8061 pid1(8061)───bash(8062)───pstree(8816) $ ls -l /proc/8061/ns lrwxrwxrwx 1 root root 0 Jun 24 12:51 ipc - ipc:[4026531839] lrwxrwxrwx 1 root root 0 Jun 24 12:51 mnt - mnt:[4026531840] lrwxrwxrwx 1 root root 0 Jun 24 12:51 net - net:[4026531968] lrwxrwxrwx 1 root root 0 Jun 24 12:51 pid - pid:[4026531836] lrwxrwxrwx 1 root root 0 Jun 24 12:51 user - user:[4026531837] lrwxrwxrwx 1 root root 0 Jun 24 12:51 uts - uts:[4026531838] $ ls -l /proc/8062/ns lrwxrwxrwx 1 root root 0 Jun 24 12:51 ipc - ipc:[4026531839] lrwxrwxrwx 1 root root 0 Jun 24 12:51 mnt - mnt:[4026531840] lrwxrwxrwx 1 root root 0 Jun 24 12:51 net - net:[4026531968] lrwxrwxrwx 1 root root 0 Jun 24 12:51 pid - pid:[4026534845] lrwxrwxrwx 1 root root 0 Jun 24 12:51 user - user:[4026531837] lrwxrwxrwx 1 root root 0 Jun 24 12:51 uts - uts:[4026534844]  ## 发现pid和uts是和父进程使用了不同的ns，其他的则是继承了父进程的命名空间 综上：通俗来讲，docker在启动一个容器的时候，会调用Linux Kernel Namespace的接口，来创建一块虚拟空间，创建的时候，可以支持设置下面这几种（可以随意选择）,docker默认都设置。\n pid：用于进程隔离（PID：进程ID） net：管理网络接口（NET：网络） ipc：管理对 IPC 资源的访问（IPC：进程间通信（信号量、消息队列和共享内存）） mnt：管理文件系统挂载点（MNT：挂载） uts：隔离主机名和域名 user：隔离用户和用户组  CGroup 资源限制 通过namespace可以保证容器之间的隔离，但是无法控制每个容器可以占用多少资源， 如果其中的某一个容器正在执行 CPU 密集型的任务，那么就会影响其他容器中任务的性能与执行效率，导致多个容器相互影响并且抢占资源。如何对多个容器的资源使用进行限制就成了解决进程虚拟资源隔离之后的主要问题。\nControl Groups（简称 CGroups）\n cgroups是Linux内核提供的一种机制，这种机制可以根据需求吧一系列系统任务及其子任务整合(或分隔)到按资源划分等级的不同组中，从而为系统资源管理提供一个统一的框架。\n CGroups能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I/O 。每一个 CGroup 都是一组被相同的标准和参数限制的进程。而我们需要做的，其实就是把容器这个进程加入到指定的Cgroup中。深入理解CGroup，请点此。\nUnionFS 联合文件系统 Linux namespace和cgroup分别解决了容器的资源隔离与资源限制，那么容器是很轻量的，通常每台机器中可以运行几十上百个容器， 这些个容器是共用一个image，还是各自将这个image复制了一份，然后各自独立运行呢？ 如果每个容器之间都是全量的文件系统拷贝，那么会导致至少如下问题：\n 运行容器的速度会变慢 容器和镜像对宿主机的磁盘空间的压力  怎么解决这个问题——Docker的存储驱动\n 镜像分层存储 UnionFS  Docker 镜像是由一系列的层组成的，每层代表 Dockerfile 中的一条指令，比如下面的 Dockerfile 文件：\nFROMubuntu:15.04COPY . /appRUN make /appCMD python /app/app.py这里的 Dockerfile 包含4条命令，其中每一行就创建了一层，下面显示了上述Dockerfile构建出来的镜像运行的容器层的结构：\n镜像就是由这些层一层一层堆叠起来的，镜像中的这些层都是只读的，当我们运行容器的时候，就可以在这些基础层至上添加新的可写层，也就是我们通常说的容器层，对于运行中的容器所做的所有更改（比如写入新文件、修改现有文件、删除文件）都将写入这个容器层。\n对容器层的操作，主要利用了写时复制（CoW）技术。CoW就是copy-on-write，表示只在需要写时才去复制，这个是针对已有文件的修改场景。 CoW技术可以让所有的容器共享image的文件系统，所有数据都从image中读取，只有当要对文件进行写操作时，才从image里把要写的文件复制到自己的文件系统进行修改。所以无论有多少个容器共享同一个image，所做的写操作都是对从image中复制到自己的文件系统中的复本上进行，并不会修改image的源文件，且多个容器操作同一个文件，会在每个容器的文件系统里生成一个复本，每个容器修改的都是自己的复本，相互隔离，相互不影响。使用CoW可以有效的提高磁盘的利用率。\n镜像中每一层的文件都是分散在不同的目录中的，如何把这些不同目录的文件整合到一起呢？\nUnionFS 其实是一种为 Linux 操作系统设计的用于把多个文件系统联合到同一个挂载点的文件系统服务。 它能够将不同文件夹中的层联合（Union）到了同一个文件夹中，整个联合的过程被称为联合挂载（Union Mount）。\n上图是AUFS的实现，AUFS是作为Docker存储驱动的一种实现，Docker 还支持了不同的存储驱动，包括 aufs、devicemapper、overlay2、zfs 和 Btrfs 等等，在最新的 Docker 中，overlay2 取代了 aufs 成为了推荐的存储驱动，但是在没有 overlay2 驱动的机器上仍然会使用 aufs 作为 Docker 的默认驱动。\nDocker网络 docker容器是一块具有隔离性的虚拟系统，容器内可以有自己独立的网络空间，\n 多个容器之间是如何实现通信的呢？ 容器和宿主机之间又是如何实现的通信呢？ 使用-p参数是怎么实现的端口映射?  带着这些问题，我们来学习一下docker的网络模型，最后我会通过抓包的方式，给大家演示一下数据包在容器和宿主机之间的转换过程。\n网络模式 我们在使用docker run创建Docker容器时，可以用–net选项指定容器的网络模式，Docker有以下4种网络模式：\n  bridge模式，使用–net=bridge指定，默认设置\n  host模式，使用–net=host指定，容器内部网络空间共享宿主机的空间，效果类似直接在宿主机上启动一个进程，端口信息和宿主机共用\n  container模式，使用–net=container:NAME_or_ID指定\n指定容器与特定容器共享网络命名空间\n  none模式，使用–net=none指定\n网络模式为空，即仅保留网络命名空间，但是不做任何网络相关的配置(网卡、IP、路由等)\n  bridge模式 那我们之前在演示创建docker容器的时候其实是没有指定的网络模式的，如果不指定的话默认就会使用bridge模式，bridge本意是桥的意思，其实就是网桥模式。\n那我们怎么理解网桥，如果需要做类比的话，我们可以把网桥看成一个二层的交换机设备，我们来看下这张图：\n交换机通信简图\n交换机网络通信流程：\n网桥模式示意图\nLinux 中，能够起到虚拟交换机作用的网络设备，是网桥（Bridge）。它是一个工作在数据链路层（Data Link）的设备，主要功能是根据 MAC 地址将数据包转发到网桥的不同端口上。 网桥在哪，查看网桥\n$ yum install -y bridge-utils $ brctl show bridge name bridge id STP enabled interfaces docker0 8000.0242b5fbe57b no veth3a496ed 有了网桥之后，那我们看下docker在启动一个容器的时候做了哪些事情才能实现容器间的互联互通\nDocker 创建一个容器的时候，会执行如下操作：\n 创建一对虚拟接口/网卡，也就是veth pair； veth pair的一端桥接 到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 vethxxxxxx； veth paid的另一端放到新启动的容器内部，并修改名字作为 eth0，这个网卡/接口只在容器的命名空间可见； 从网桥可用地址段中（也就是与该bridge对应的network）获取一个空闲地址分配给容器的 eth0 配置容器的默认路由  那整个过程其实是docker自动帮我们完成的，清理掉所有容器，来验证。\n## 清掉所有容器 $ docker rm -f `docker ps -aq` $ docker ps $ brctl show # 查看网桥中的接口，目前没有  ## 创建测试容器test1 $ docker run -d --name test1 nginx:alpine $ brctl show # 查看网桥中的接口，已经把test1的veth端接入到网桥中 $ ip a |grep veth # 已在宿主机中可以查看到 $ docker exec -ti test1 sh / # ifconfig # 查看容器的eth0网卡及分配的容器ip  # 再来启动一个测试容器，测试容器间的通信 $ docker run -d --name test2 nginx:alpine $ docker exec -ti test2 sh / # sed -i 's/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g' /etc/apk/repositories / # apk add curl / # curl 172.17.0.8:80  ## 为啥可以通信？ / # route -n #  Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 172.17.0.1 0.0.0.0 UG 0 0 0 eth0 172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0  # eth0 网卡是这个容器里的默认路由设备；所有对 172.17.0.0/16 网段的请求，也会被交给 eth0 来处理（第二条 172.17.0.0 路由规则），这条路由规则的网关（Gateway）是 0.0.0.0，这就意味着这是一条直连规则，即：凡是匹配到这条规则的 IP 包，应该经过本机的 eth0 网卡，通过二层网络(数据链路层)直接发往目的主机。  # 而要通过二层网络到达 test1 容器，就需要有 172.17.0.8 这个 IP 地址对应的 MAC 地址。所以test2容器的网络协议栈，就需要通过 eth0 网卡发送一个 ARP 广播，来通过 IP 地址查找对应的 MAC 地址。  #这个 eth0 网卡，是一个 Veth Pair，它的一端在这个 test2 容器的 Network Namespace 里，而另一端则位于宿主机上（Host Namespace），并且被“插”在了宿主机的 docker0 网桥上。网桥设备的一个特点是插在桥上的网卡都会被当成桥上的一个端口来处理，而端口的唯一作用就是接收流入的数据包，然后把这些数据包的“生杀大权”（比如转发或者丢弃），全部交给对应的网桥设备处理。  # 因此ARP的广播请求也会由docker0来负责转发，这样网桥就维护了一份端口与mac的信息表，因此针对test2的eth0拿到mac地址后发出的各类请求，同样走到docker0网桥中由网桥负责转发到对应的容器中。  # 网桥会维护一份mac映射表，我们可以大概通过命令来看一下， $ brctl showmacs docker0 ## 这些mac地址是主机端的veth网卡对应的mac，可以查看一下 $ ip a 我们如何知道网桥上的这些虚拟网卡与容器端是如何对应？\n通过ifindex，网卡索引号\n## 查看test1容器的网卡索引 $ docker exec -ti test1 cat /sys/class/net/eth0/ifindex  ## 主机中找到虚拟网卡后面这个@ifxx的值，如果是同一个值，说明这个虚拟网卡和这个容器的eth0网卡是配对的。 $ ip a |grep @if 整理脚本，快速查看对应：\nfor container in $(docker ps -q); do  iflink=`docker exec -it $container sh -c 'cat /sys/class/net/eth0/iflink'`  iflink=`echo $iflink|tr -d '\\r'`  veth=`grep -l $iflink /sys/class/net/veth*/ifindex`  veth=`echo $veth|sed -e 's;^.*net/\\(.*\\)/ifindex$;\\1;'`  echo $container:$veth done 上面我们讲解了容器之间的通信，那么容器与宿主机的通信是如何做的？\n添加端口映射：\n## 启动容器的时候通过-p参数添加宿主机端口与容器内部服务端口的映射 $ docker run --name test -d -p 8088:80 nginx:alpine $ curl localhost:8088 端口映射如何实现的？先来回顾iptables链表图\n访问本机的8088端口，数据包会从流入方向进入本机，因此涉及到PREROUTING和INPUT链，我们是通过做宿主机与容器之间加的端口映射，所以肯定会涉及到端口转换，那哪个表是负责存储端口转换信息的呢，就是nat表，负责维护网络地址转换信息的。因此我们来查看一下PREROUTING链的nat表：\n$ iptables -t nat -nvL PREROUTING Chain PREROUTING (policy ACCEPT 159 packets, 20790 bytes)  pkts bytes target prot opt in out source destination  3 156 DOCKER all -- * * 0.0.0.0/0 0.0.0.0/0 ADDRTYPE match dst-type LOCAL 规则利用了iptables的addrtype拓展，匹配网络类型为本地的包，如何确定哪些是匹配本地，\n$ ip route show table local type local 127.0.0.0/8 dev lo proto kernel scope host src 127.0.0.1 127.0.0.1 dev lo proto kernel scope host src 127.0.0.1 172.17.0.1 dev docker0 proto kernel scope host src 172.17.0.1 172.21.51.143 dev eth0 proto kernel scope host src 172.21.51.143 也就是说目标地址类型匹配到这些的，会转发到我们的TARGET中，TARGET是动作，意味着对符合要求的数据包执行什么样的操作，最常见的为ACCEPT或者DROP，此处的TARGET为DOCKER，很明显DOCKER不是标准的动作，那DOCKER是什么呢？我们通常会定义自定义的链，这样把某类对应的规则放在自定义链中，然后把自定义的链绑定到标准的链路中，因此此处DOCKER 是自定义的链。那我们现在就来看一下DOCKER这个自定义链上的规则。\n$ iptables -t nat -nvL DOCKER Chain DOCKER (2 references)  pkts bytes target prot opt in out source destination  0 0 RETURN all -- docker0 * 0.0.0.0/0 0.0.0.0/0  0 0 DNAT tcp -- !docker0 * 0.0.0.0/0 0.0.0.0/0 tcp dpt:8088 to:172.17.0.2:80 此条规则就是对主机收到的目的端口为8088的tcp流量进行DNAT转换，将流量发往172.17.0.2:80，172.17.0.2地址是不是就是我们上面创建的Docker容器的ip地址，流量走到网桥上了，后面就走网桥的转发就ok了。 所以，外界只需访问172.21.51.143:8088就可以访问到容器中的服务了。\n数据包在出口方向走POSTROUTING链，我们查看一下规则：\n$ iptables -t nat -nvL POSTROUTING Chain POSTROUTING (policy ACCEPT 1099 packets, 67268 bytes)  pkts bytes target prot opt in out source destination  86 5438 MASQUERADE all -- * !docker0 172.17.0.0/16 0.0.0.0/0  0 0 MASQUERADE tcp -- * * 172.17.0.4 172.17.0.4 tcp dpt:80 大家注意MASQUERADE这个动作是什么意思，其实是一种更灵活的SNAT，把源地址转换成主机的出口ip地址，那解释一下这条规则的意思:\n这条规则会将源地址为172.17.0.0/16的包（也就是从Docker容器产生的包），并且不是从docker0网卡发出的，进行源地址转换，转换成主机网卡的地址。大概的过程就是ACK的包在容器里面发出来，会路由到网桥docker0，网桥根据宿主机的路由规则会转给宿主机网卡eth0，这时候包就从docker0网卡转到eth0网卡了，并从eth0网卡发出去，这时候这条规则就会生效了，把源地址换成了eth0的ip地址。\n 注意一下，刚才这个过程涉及到了网卡间包的传递，那一定要打开主机的ip_forward转发服务，要不然包转不了，服务肯定访问不到。\n 抓包演示 我们先想一下，我们要抓哪个网卡的包\n  首先访问宿主机的8088端口，我们抓一下宿主机的eth0\n$ tcpdump -i eth0 port 8088 -w host.cap   然后最终包会流入容器内，那我们抓一下容器内的eth0网卡\n# 容器内安装一下tcpdump $ sed -i 's/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g' /etc/apk/repositories $ apk add tcpdump $ tcpdump -i eth0 port 80 -w container.cap   到另一台机器访问一下，\n$ curl 172.21.51.143:8088/ 停止抓包，拷贝容器内的包到宿主机\n$ docker cp test:/root/container.cap /root/ 把抓到的内容拷贝到本地，使用wireshark进行分析。\n$ scp root@172.21.51.143:/root/*.cap /d/packages （wireshark合并包进行分析）\n进到容器内的包做DNAT，出去的包做SNAT，这样对外面来讲，根本就不知道机器内部是谁提供服务，其实这就和一个内网多个机器公用一个外网IP地址上网的效果是一样的，那这也属于NAT功能的一个常见的应用场景。\nHost模式 容器内部不会创建网络空间，共享宿主机的网络空间。比如直接通过host模式创建mysql容器：\n$ docker run --net host -d --name mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 容器启动后，会默认监听3306端口，由于网络模式是host，因为可以直接通过宿主机的3306端口进行访问服务，效果等同于在宿主机中直接启动mysqld的进程。\nConatiner模式 这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。\n## 启动测试容器，共享mysql的网络空间 $ docker run -ti --rm --net=container:mysql busybox sh / # ip a / # netstat -tlp|grep 3306 / # telnet localhost 3306 在一些特殊的场景中非常有用，例如，kubernetes的pod，kubernetes为pod创建一个基础设施容器，同一pod下的其他容器都以container模式共享这个基础设施容器的网络命名空间，相互之间以localhost访问，构成一个统一的整体。\nNone模式 只会创建对应的网络空间，不会配置网络堆栈（网卡、路由等）。\n# 创建none的容器 $ docker run -it --name=network-none --net=none nginx:alpine sh # ifconfig 在宿主机中操作：\n# 创建虚拟网卡对 $ ip link add A type veth peer name B # A端插入到docker0网桥 $ brctl addif docker0 A $ ip link set A up  # B端插入到network-none容器中，需要借助ip netns,因此需要显示的创建命名network namespace $ PID=$(docker inspect -f '{{.State.Pid}}' network-none) $ mkdir -p /var/run/netns $ ln -s /proc/$PID/ns/net /var/run/netns/$PID  # B端放到容器的命名空间 $ ip link set B netns $PID $ ip netns exec $PID ip link set dev B name eth0 # 修改设备名称为eth0，和docker默认行为一致 $ ip netns exec $PID ip link set eth0 up  # 设置ip $ ip netns exec $PID ip addr add 172.17.0.100/16 dev eth0 # 添加默认路由，指定给docker0网桥 $ ip netns exec $PID ip route add default via 172.17.0.1  # 测试容器间通信 前置知识：\n ip netns 命令用来管理 network namespace。它可以创建命名的 network namespace，然后通过名字来引用 network namespace network namespace 在逻辑上是网络堆栈的一个副本，它有自己的路由、防火墙规则和网络设备。 默认情况下，子进程继承其父进程的 network namespace。也就是说，如果不显式创建新的 network namespace，所有进程都从 init 进程继承相同的默认 network namespace。 根据约定，命名的 network namespace 是可以打开的 /var/run/netns/ 目录下的一个对象。比如有一个名称为 net1 的 network namespace 对象，则可以由打开 /var/run/netns/net1 对象产生的文件描述符引用 network namespace net1。通过引用该文件描述符，可以修改进程的 network namespace。  实用技巧   清理主机上所有退出的容器\n$ docker rm $(docker ps -aq)   调试或者排查容器启动错误\n## 若有时遇到容器启动失败的情况，可以先使用相同的镜像启动一个临时容器，先进入容器 $ docker run --rm -ti  sh ## 进入容器后，手动执行该容器对应的ENTRYPOINT或者CMD命令，这样即使出错，容器也不会退出，因为bash作为1号进程，我们只要不退出容器，该容器就不会自动退出   本章小结  为了解决软件交付过程中的环境依赖，同时提供一种更加轻量的虚拟化技术，Docker出现了。 2013年诞生，15年开始迅速发展，从17.03月开始，使用时间日期管理版本，稳定版以每季度为准。 Docker是一种CS架构的软件产品，可以把代码及依赖打包成镜像，作为交付介质，并且把镜像启动成为容器，提供容器生命周期的管理。 使用yum部署docker，启动后通过操作docker这个命令行，自动调用docker daemon完成容器相关操作。 常用操作，围绕镜像|容器|仓库三大核心要素  systemctl start|stop|restart docker docker build | pull - docker tag - docker push docker run –name my-demo -d -p 8080:80 -v /opt/data:/data demo:v20200327 ping xx.com docker cp /path/a.txt mycontainer:/opt docker exec -ti mycontainer /bin/sh docker logs -f –tail=100 mycontainer   通过dockerfile构建业务镜像，先使用基础镜像，然后通过一系列的指令把我们的业务应用所需要的运行环境和依赖都打包到镜像中，然后通过CMD或者ENTRYPOINT指令把镜像启动时的入口制定好，完成封装即可。有点类似于，先找来一个集装箱模板(基础镜像)，然后把项目依赖的服务都扔到集装箱中，然后设置好服务的启动入口，关闭箱门，即完成了业务镜像的制作。 容器的实现依赖于内核模块提供的namespace和control-group的功能，通过namespace创建一块虚拟空间，空间内实现了各类资源(进程、网络、文件系统)的隔离，提供control-group实现了对隔离的空间的资源使用的限制。 docker镜像使用分层的方式进行存储，根据主机的存储驱动的不同，实现方式会不同，kernel在3.10.0-514以上自动支持overlay2 存储驱动，也是目前Docker推荐的方式。 得益于分层存储的模式，多个容器可以通过copy-on-write的策略，在镜像的最上层加一个可写层，同时利用存储驱动的UnionFS的能力，实现一个镜像快速启动多个容器的场景。 docker的网络模式分为4种，最常用的为bridge和host模式。bridge模式通过docker0网桥，启动容器的时候通过创建一对虚拟网卡，将容器连接在桥上，同时维护了虚拟网卡与网桥端口的关系，实现容器间的通信。容器与宿主机之间的通信通过iptables端口映射的方式，docker利用iptables的PREROUTING和POSTROUTING的nat功能，实现了SNAT与DNAT，使得容器内部的服务被完美的保护起来。 本章重点内容是docker的核心要素及基础的操作，实现原理以及docker的网络模式为选修包，目的为了帮助有docker基础及经验的同学更好的进一步理解docker。  ",
  "wordCount" : "2680",
  "inLanguage": "zh",
  "datePublished": "2021-12-30T15:35:39Z",
  "dateModified": "2021-12-30T15:35:39Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://iblog.zone/archives/%E8%B5%B0%E8%BF%9Bdocker%E7%9A%84%E4%B8%96%E7%95%8C/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "ylw's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://iblog.zone/images/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://iblog.zone" accesskey="h" title="ylw&#39;s blog (Alt + H)">ylw&#39;s blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://iblog.zone/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://iblog.zone/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://iblog.zone/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://iblog.zone/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://iblog.zone/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://iblog.zone">主页</a>&nbsp;»&nbsp;<a href="https://iblog.zone/posts/">Posts</a></div>
    <h1 class="post-title">
      走进Docker的世界
    </h1>
    <div class="post-meta"><span title='2021-12-30 15:35:39 +0000 UTC'>2021-12-30</span>&nbsp;·&nbsp;13 分钟

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e7%ac%ac%e4%b8%80%e5%a4%a9--%e8%b5%b0%e8%bf%9bdocker%e7%9a%84%e4%b8%96%e7%95%8c" aria-label="第一天  走进Docker的世界">第一天  走进Docker的世界</a><ul>
                            
                    <li>
                        <a href="#%e8%ae%a4%e8%af%86docker" aria-label="认识docker">认识docker</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%87%ba%e7%8e%b0docker" aria-label="为什么出现docker">为什么出现docker</a></li>
                    <li>
                        <a href="#%e4%bb%80%e4%b9%88%e6%98%afdocker" aria-label="什么是docker">什么是docker</a></li>
                    <li>
                        <a href="#docker%e8%83%bd%e5%81%9a%e4%bb%80%e4%b9%88" aria-label="docker能做什么">docker能做什么</a></li>
                    <li>
                        <a href="#%e7%89%88%e6%9c%ac%e7%ae%a1%e7%90%86" aria-label="版本管理">版本管理</a></li>
                    <li>
                        <a href="#%e5%8f%91%e5%b1%95%e5%8f%b2" aria-label="发展史">发展史</a></li>
                    <li>
                        <a href="#%e5%b0%8f%e7%bb%93" aria-label="小结">小结</a></li></ul>
                        </ul>
                    </li>
                    <li>
                        <a href="#%e5%ae%89%e8%a3%85" aria-label="安装">安装</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#%e9%85%8d%e7%bd%ae%e5%ae%bf%e4%b8%bb%e6%9c%ba%e7%bd%91%e5%8d%a1%e8%bd%ac%e5%8f%91" aria-label="配置宿主机网卡转发">配置宿主机网卡转发</a></li>
                    <li>
                        <a href="#yum%e5%ae%89%e8%a3%85%e9%85%8d%e7%bd%aedocker" aria-label="Yum安装配置docker">Yum安装配置docker</a></li></ul>
                        </ul>
                    </li>
                    <li>
                        <a href="#%e6%a0%b8%e5%bf%83%e8%a6%81%e7%b4%a0%e5%8f%8a%e5%b8%b8%e7%94%a8%e6%93%8d%e4%bd%9c%e8%af%a6%e8%a7%a3" aria-label="核心要素及常用操作详解">核心要素及常用操作详解</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#%e9%95%9c%e5%83%8fimage" aria-label="镜像（Image）">镜像（Image）</a></li>
                    <li>
                        <a href="#%e5%ae%b9%e5%99%a8container" aria-label="容器（Container）">容器（Container）</a></li>
                    <li>
                        <a href="#%e4%bb%93%e5%ba%93registry" aria-label="仓库（Registry）">仓库（Registry）</a></li>
                    <li>
                        <a href="#%e6%93%8d%e4%bd%9c%e6%bc%94%e7%a4%ba" aria-label="操作演示">操作演示</a></li>
                    <li>
                        <a href="#dockerfile%e4%bd%bf%e7%94%a8" aria-label="Dockerfile使用">Dockerfile使用</a></li>
                    <li>
                        <a href="#%e5%a4%9a%e9%98%b6%e6%9e%84%e5%bb%ba" aria-label="多阶构建">多阶构建</a></li>
                    <li>
                        <a href="#%e9%80%9a%e8%bf%871%e5%8f%b7%e8%bf%9b%e7%a8%8b%e7%90%86%e8%a7%a3%e5%ae%b9%e5%99%a8%e7%9a%84%e6%9c%ac%e8%b4%a8" aria-label="通过1号进程理解容器的本质">通过1号进程理解容器的本质</a></li></ul>
                        </ul>
                    </li>
                    <li>
                        <a href="#django%e5%ba%94%e7%94%a8%e5%ae%b9%e5%99%a8%e5%8c%96%e5%ae%9e%e8%b7%b5" aria-label="Django应用容器化实践">Django应用容器化实践</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#django%e9%a1%b9%e7%9b%ae%e4%bb%8b%e7%bb%8d" aria-label="django项目介绍">django项目介绍</a></li>
                    <li>
                        <a href="#%e5%ae%b9%e5%99%a8%e5%8c%96django%e9%a1%b9%e7%9b%ae" aria-label="容器化Django项目">容器化Django项目</a></li>
                    <li>
                        <a href="#%e8%bf%90%e8%a1%8cmysql" aria-label="运行mysql">运行mysql</a></li>
                    <li>
                        <a href="#%e5%90%af%e5%8a%a8django%e5%ba%94%e7%94%a8" aria-label="启动Django应用">启动Django应用</a></li></ul>
                        </ul>
                    </li>
                    <li>
                        <a href="#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86" aria-label="实现原理">实现原理</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#namespace-%e8%b5%84%e6%ba%90%e9%9a%94%e7%a6%bb" aria-label="Namespace 资源隔离">Namespace 资源隔离</a></li>
                    <li>
                        <a href="#cgroup-%e8%b5%84%e6%ba%90%e9%99%90%e5%88%b6" aria-label="CGroup 资源限制">CGroup 资源限制</a></li>
                    <li>
                        <a href="#unionfs-%e8%81%94%e5%90%88%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" aria-label="UnionFS 联合文件系统">UnionFS 联合文件系统</a></li></ul>
                        </ul>
                    </li>
                    <li>
                        <a href="#docker%e7%bd%91%e7%bb%9c" aria-label="Docker网络">Docker网络</a><ul>
                            
                    <li>
                        <a href="#%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%bc%8f" aria-label="网络模式">网络模式</a></li>
                    <li>
                        <a href="#bridge%e6%a8%a1%e5%bc%8f" aria-label="bridge模式">bridge模式</a><ul>
                            
                    <li>
                        <a href="#%e6%8a%93%e5%8c%85%e6%bc%94%e7%a4%ba" aria-label="抓包演示">抓包演示</a></li></ul>
                    </li>
                    <li>
                        <a href="#host%e6%a8%a1%e5%bc%8f" aria-label="Host模式">Host模式</a></li>
                    <li>
                        <a href="#conatiner%e6%a8%a1%e5%bc%8f" aria-label="Conatiner模式">Conatiner模式</a></li>
                    <li>
                        <a href="#none%e6%a8%a1%e5%bc%8f" aria-label="None模式">None模式</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%ae%9e%e7%94%a8%e6%8a%80%e5%b7%a7" aria-label="实用技巧">实用技巧</a></li>
                    <li>
                        <a href="#%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93" aria-label="本章小结">本章小结</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script data-cfasync="false">
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>


  <div class="post-content"><h3 id="第一天--走进docker的世界">第一天  走进Docker的世界<a hidden class="anchor" aria-hidden="true" href="#第一天--走进docker的世界">#</a></h3>
<p>介绍docker的前世今生，了解docker的实现原理，以Django项目为例，带大家如何编写最佳的Dockerfile构建镜像。通过本章的学习，大家会知道docker的概念及基本操作，并学会构建自己的业务镜像，并通过抓包的方式掌握Docker最常用的bridge网络模式的通信。</p>
<h4 id="认识docker">认识docker<a hidden class="anchor" aria-hidden="true" href="#认识docker">#</a></h4>
<ul>
<li>why</li>
<li>what</li>
<li>how</li>
</ul>
<h6 id="为什么出现docker">为什么出现docker<a hidden class="anchor" aria-hidden="true" href="#为什么出现docker">#</a></h6>
<p>需要一种轻量、高效的虚拟化能力</p>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/docker-differents.svg" alt=""  />
</p>
<p>Docker 公司位于旧金山,原名dotCloud，底层利用了Linux容器技术（LXC）（在操作系统中实现资源隔离与限制）。为了方便创建和管理这些容器，dotCloud 开发了一套内部工具，之后被命名为“Docker”。Docker就是这样诞生的。</p>
<p>Hypervisor： 一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件 。常见的VMware的 Workstation 、ESXi、微软的Hyper-V或者思杰的XenServer。</p>
<p>Container Runtime：通过Linux内核虚拟化能力管理多个容器，多个容器共享一套操作系统内核。因此摘掉了内核占用的空间及运行所需要的耗时，使得容器极其轻量与快速。</p>
<h6 id="什么是docker">什么是docker<a hidden class="anchor" aria-hidden="true" href="#什么是docker">#</a></h6>
<p>基于操作系统内核，提供轻量级虚拟化功能的CS架构的软件产品。</p>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/docker-engine.png" alt=""  />
</p>
<p>基于轻量的特性，解决软件交付过程中的环境依赖</p>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/why1.png" alt=""  />
</p>
<h6 id="docker能做什么">docker能做什么<a hidden class="anchor" aria-hidden="true" href="#docker能做什么">#</a></h6>
<ul>
<li>可以把应用程序代码及运行依赖环境打包成镜像，作为交付介质，在各环境部署</li>
<li>可以将镜像（image）启动成为容器(container)，并且提供多容器的生命周期进行管理（启、停、删）</li>
<li>container容器之间相互隔离，且每个容器可以设置资源限额</li>
<li>提供轻量级虚拟化功能，容器就是在宿主机中的一个个的虚拟的空间，彼此相互隔离，完全独立</li>
</ul>
<h6 id="版本管理">版本管理<a hidden class="anchor" aria-hidden="true" href="#版本管理">#</a></h6>
<ul>
<li>Docker 引擎主要有两个版本：企业版（EE）和社区版（CE）</li>
<li>每个季度(1-3,4-6,7-9,10-12)，企业版和社区版都会发布一个稳定版本(Stable)。社区版本会提供 4 个月的支持，而企业版本会提供 12 个月的支持</li>
<li>每个月社区版还会通过 Edge 方式发布月度版</li>
<li>从 2017 年第一季度开始，Docker 版本号遵循 YY.MM-xx 格式，类似于 Ubuntu 等项目。例如，2018 年 6 月第一次发布的社区版本为 18.06.0-ce</li>
</ul>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/docker-version.png" alt=""  />
</p>
<h6 id="发展史">发展史<a hidden class="anchor" aria-hidden="true" href="#发展史">#</a></h6>
<p>13年成立，15年开始，迎来了飞速发展。</p>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/deplpment.png" alt=""  />
</p>
<p>Docker 1.8之前，使用<a href="https://linuxcontainers.org/fr/lxc/introduction/">LXC</a>，Docker在上层做了封装， 把LXC复杂的容器创建与使用方式简化为自己的一套命令体系。</p>
<p>之后，为了实现跨平台等复杂的场景，Docker抽出了libcontainer项目，把对namespace、cgroup的操作封装在libcontainer项目里，支持不同的平台类型。</p>
<p>2015年6月，Docker牵头成立了 OCI（Open Container Initiative开放容器计划）组织，这个组织的目的是建立起一个围绕容器的通用标准 。 容器格式标准是一种不受上层结构绑定的协议，即不限于某种特定操作系统、硬件、CPU架构、公有云等 ， 允许任何人在遵循该标准的情况下开发应用容器技术，这使得容器技术有了一个更广阔的发展空间。</p>
<p>OCI成立后，libcontainer 交给OCI组织来维护，但是libcontainer中只包含了与kernel交互的库，因此基于libcontainer项目，后面又加入了一个CLI工具，并且项目改名为runC (<a href="https://github.com/opencontainers/runc">https://github.com/opencontainers/runc</a> )， 目前runC已经成为一个功能强大的runtime工具。</p>
<p>Docker也做了架构调整。将容器运行时相关的程序从docker daemon剥离出来，形成了<strong>containerd</strong>。containerd向上为Docker Daemon提供了<code>gRPC接口</code>，使得Docker Daemon屏蔽下面的结构变化，确保原有接口向下兼容。向下通过<code>containerd-shim</code>结合<code>runC</code>，使得引擎可以独立升级，避免之前Docker Daemon升级会导致所有容器不可用的问题。</p>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/containerd.png" alt=""  />
</p>
<p>也就是说</p>
<ul>
<li>runC（libcontainer）是符合OCI标准的一个实现，与底层系统交互</li>
<li>containerd是实现了OCI之上的容器的高级功能，比如镜像管理、容器执行的调用等</li>
<li>Dockerd目前是最上层与CLI交互的进程，接收cli的请求并与containerd协作</li>
</ul>
<h6 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h6>
<ol>
<li>为了提供一种更加轻量的虚拟化技术，docker出现了</li>
<li>借助于docker容器的轻、快等特性，解决了软件交付过程中的环境依赖问题，使得docker得以快速发展</li>
<li>Docker是一种CS架构的软件产品，可以把代码及依赖打包成镜像，作为交付介质，并且把镜像启动成为容器，提供容器生命周期的管理</li>
<li>docker-ce，每季度发布stable版本。18.06，18.09，19.03</li>
<li>发展至今，docker已经通过制定OCI标准对最初的项目做了拆分，其中runC和containerd是docker的核心项目，理解docker整个请求的流程，对我们深入理解docker有很大的帮助</li>
</ol>
<h4 id="安装">安装<a hidden class="anchor" aria-hidden="true" href="#安装">#</a></h4>
<h6 id="配置宿主机网卡转发">配置宿主机网卡转发<a hidden class="anchor" aria-hidden="true" href="#配置宿主机网卡转发">#</a></h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">## 若未配置，需要执行如下</span>
</span></span><span style="display:flex;"><span>$ cat <span style="color:#e6db74">&lt;&lt;EOF &gt;  /etc/sysctl.d/docker.conf
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">net.bridge.bridge-nf-call-ip6tables = 1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">net.bridge.bridge-nf-call-iptables = 1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">net.ipv4.ip_forward=1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EOF</span>
</span></span><span style="display:flex;"><span>$ sysctl -p /etc/sysctl.d/docker.conf
</span></span></code></pre></div><h6 id="yum安装配置docker">Yum安装配置docker<a hidden class="anchor" aria-hidden="true" href="#yum安装配置docker">#</a></h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">## 下载阿里源repo文件</span>
</span></span><span style="display:flex;"><span>$ curl -o /etc/yum.repos.d/Centos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo
</span></span><span style="display:flex;"><span>$ curl -o /etc/yum.repos.d/docker-ce.repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ yum clean all <span style="color:#f92672">&amp;&amp;</span> yum makecache
</span></span><span style="display:flex;"><span><span style="color:#75715e">## yum安装</span>
</span></span><span style="display:flex;"><span>$ yum install docker-ce-20.10.6 -y
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 查看源中可用版本</span>
</span></span><span style="display:flex;"><span>$ yum list docker-ce --showduplicates | sort -r
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 安装旧版本</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##yum install -y docker-ce-18.09.9</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 配置源加速</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</span>
</span></span><span style="display:flex;"><span>mkdir -p /etc/docker
</span></span><span style="display:flex;"><span>vi /etc/docker/daemon.json
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;registry-mirrors&#34;</span> : <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;https://8xpk5wnt.mirror.aliyuncs.com&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 设置开机自启</span>
</span></span><span style="display:flex;"><span>systemctl enable docker  
</span></span><span style="display:flex;"><span>systemctl daemon-reload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 启动docker</span>
</span></span><span style="display:flex;"><span>systemctl start docker 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 查看docker信息</span>
</span></span><span style="display:flex;"><span>docker info
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## docker-client</span>
</span></span><span style="display:flex;"><span>which docker
</span></span><span style="display:flex;"><span><span style="color:#75715e">## docker daemon</span>
</span></span><span style="display:flex;"><span>ps aux |grep docker
</span></span><span style="display:flex;"><span><span style="color:#75715e">## containerd</span>
</span></span><span style="display:flex;"><span>ps aux|grep containerd
</span></span><span style="display:flex;"><span>systemctl status containerd
</span></span></code></pre></div><h4 id="核心要素及常用操作详解">核心要素及常用操作详解<a hidden class="anchor" aria-hidden="true" href="#核心要素及常用操作详解">#</a></h4>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/docker%E6%9E%B6%E6%9E%84.png" alt=""  />
</p>
<p>三大核心要素：镜像(Image)、容器(Container)、仓库(Registry)</p>
<h6 id="镜像image">镜像（Image）<a hidden class="anchor" aria-hidden="true" href="#镜像image">#</a></h6>
<p>打包了业务代码及运行环境的包，是静态的文件，不能直接对外提供服务。</p>
<h6 id="容器container">容器（Container）<a hidden class="anchor" aria-hidden="true" href="#容器container">#</a></h6>
<p>镜像的运行时，可以对外提供服务。</p>
<h6 id="仓库registry">仓库（Registry）<a hidden class="anchor" aria-hidden="true" href="#仓库registry">#</a></h6>
<p>存放镜像的地方</p>
<ul>
<li>公有仓库，Docker Hub，阿里，网易&hellip;</li>
<li>私有仓库，企业内部搭建
<ul>
<li>Docker Registry，Docker官方提供的镜像仓库存储服务</li>
<li>Harbor, 是Docker Registry的更高级封装，它除了提供友好的Web UI界面，角色和用户权限管理，用户操作审计等功能</li>
</ul>
</li>
<li>镜像访问地址形式 registry.devops.com/demo/hello:latest,若没有前面的url地址，则默认寻找Docker Hub中的镜像，若没有tag标签，则使用latest作为标签。 比如，docker pull nginx，会被解析成docker.io/library/nginx:latest</li>
<li>公有的仓库中，一般存在这么几类镜像
<ul>
<li>操作系统基础镜像（centos，ubuntu，suse，alpine）</li>
<li>中间件（nginx，redis，mysql，tomcat）</li>
<li>语言编译环境（python，java，golang）</li>
<li>业务镜像（django-demo&hellip;）</li>
</ul>
</li>
</ul>
<p>容器和仓库不会直接交互，都是以镜像为载体来操作。</p>
<ol>
<li>
<p>查看镜像列表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker images
</span></span></code></pre></div></li>
<li>
<p>如何获取镜像</p>
<ul>
<li>
<p>从远程仓库拉取</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker pull nginx:alpine
</span></span><span style="display:flex;"><span>$ docker images
</span></span></code></pre></div></li>
<li>
<p>使用tag命令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker tag nginx:alpine 172.21.51.143:5000/nginx:alpine
</span></span><span style="display:flex;"><span>$ docker images
</span></span></code></pre></div></li>
<li>
<p>本地构建</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker build . -t my-nginx:ubuntu -f Dockerfile
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>如何通过镜像启动容器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker run --name my-nginx-alpine -d nginx:alpine
</span></span></code></pre></div></li>
<li>
<p>如何知道容器内部运行了什么程序？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 进入容器内部,分配一个tty终端</span>
</span></span><span style="display:flex;"><span>$ docker exec -ti my-nginx-alpine /bin/sh
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ps aux</span>
</span></span></code></pre></div></li>
<li>
<p>docker怎么知道容器启动后该执行什么命令？</p>
<p>通过docker build来模拟构建一个nginx的镜像，</p>
<ul>
<li>
<p>创建Dockerfile</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 告诉docker使用哪个基础镜像作为模板，后续命令都以这个镜像为基础 </span>
</span></span><span style="display:flex;"><span>FROM ubuntu
</span></span><span style="display:flex;"><span><span style="color:#75715e"># RUN命令会在上面指定的镜像里执行命令 </span>
</span></span><span style="display:flex;"><span>RUN apt-get update <span style="color:#f92672">&amp;&amp;</span> apt install -y nginx
</span></span><span style="display:flex;"><span><span style="color:#75715e">#告诉docker，启动容器时执行如下命令</span>
</span></span><span style="display:flex;"><span>CMD <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;/usr/sbin/nginx&#34;</span>, <span style="color:#e6db74">&#34;-g&#34;</span>,<span style="color:#e6db74">&#34;daemon off;&#34;</span><span style="color:#f92672">]</span>
</span></span></code></pre></div></li>
<li>
<p>构建本地镜像</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker build . -t my-nginx:ubuntu -f Dockerfile
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<ul>
<li>
<p>使用新镜像启动容器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>   $ docker run --name my-nginx-ubuntu -d my-nginx:ubuntu
</span></span></code></pre></div></li>
<li>
<p>进入容器查看进程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>   $ docker exec -ti my-nginx-ubuntu /bin/sh
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># ps aux</span>
</span></span></code></pre></div></li>
</ul>
<ol>
<li>
<p>如何访问容器内服务</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 进入容器内部</span>
</span></span><span style="display:flex;"><span>$ docker exec -ti my-nginx-alpine /bin/sh
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ps aux|grep nginx</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># curl localhost:80</span>
</span></span></code></pre></div></li>
<li>
<p>宿主机中如何访问容器服务</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 删掉旧服务,重新启动</span>
</span></span><span style="display:flex;"><span>$ docker rm -f my-nginx-alpine
</span></span><span style="display:flex;"><span>$ docker run --name my-nginx-alpine -d -p 8080:80 nginx:alpine
</span></span><span style="display:flex;"><span>$ curl 172.21.51.143:8080
</span></span></code></pre></div></li>
<li>
<p>docker client如何与daemon通信</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># /var/run/docker.sock</span>
</span></span><span style="display:flex;"><span>$ docker run --name portainer -d -p 9001:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer
</span></span></code></pre></div></li>
</ol>
<h6 id="操作演示">操作演示<a hidden class="anchor" aria-hidden="true" href="#操作演示">#</a></h6>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.jpg" alt=""  />
</p>
<ol>
<li>查看所有镜像：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker images
</span></span></code></pre></div><ol>
<li>拉取镜像:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker pull nginx:alpine
</span></span></code></pre></div><ol>
<li>如何唯一确定镜像:</li>
</ol>
<ul>
<li>image_id</li>
<li>repository:tag</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker images
</span></span><span style="display:flex;"><span>REPOSITORY    TAG                 IMAGE ID            CREATED             SIZE
</span></span><span style="display:flex;"><span>nginx         alpine              377c0837328f        <span style="color:#ae81ff">2</span> weeks ago         19.7MB
</span></span></code></pre></div><ol>
<li>
<p>导出镜像到文件中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker save -o nginx-alpine.tar nginx:alpine
</span></span></code></pre></div></li>
<li>
<p>从文件中加载镜像</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker load -i nginx-alpine.tar
</span></span></code></pre></div></li>
<li>
<p>部署镜像仓库</p>
<p><a href="https://docs.docker.com/registry/">https://docs.docker.com/registry/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">## 使用docker镜像启动镜像仓库服务</span>
</span></span><span style="display:flex;"><span>$ docker run -d -p 5000:5000 --restart always --name registry registry:2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 默认仓库不带认证，若需要认证，参考https://docs.docker.com/registry/deploying/#restricting-access</span>
</span></span></code></pre></div></li>
<li>
<p>推送本地镜像到镜像仓库中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker tag nginx:alpine localhost:5000/nginx:alpine
</span></span><span style="display:flex;"><span>$ docker push localhost:5000/nginx:alpine
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 查看仓库内元数据</span>
</span></span><span style="display:flex;"><span>$ curl -X GET http://172.21.51.143:5000/v2/_catalog
</span></span><span style="display:flex;"><span>$ curl -X GET http://172.21.51.143:5000/v2/nginx/tags/list
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 镜像仓库给外部访问，不能通过localhost，尝试使用内网地址172.21.51.143:5000/nginx:alpine</span>
</span></span><span style="display:flex;"><span>$ docker tag nginx:alpine 172.21.51.143:5000/nginx:alpine
</span></span><span style="display:flex;"><span>$ docker push 172.21.51.143:5000/nginx:alpine
</span></span><span style="display:flex;"><span>The push refers to repository <span style="color:#f92672">[</span>172.21.51.143:5000/nginx<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>Get https://172.21.51.143:5000/v2/: http: server gave HTTP response to HTTPS client
</span></span><span style="display:flex;"><span><span style="color:#75715e">## docker默认不允许向http的仓库地址推送，如何做成https的，参考：https://docs.docker.com/registry/deploying/#run-an-externally-accessible-registry</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 我们没有可信证书机构颁发的证书和域名，自签名证书需要在每个节点中拷贝证书文件，比较麻烦，因此我们通过配置daemon的方式，来跳过证书的验证：</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ cat /etc/docker/daemon.json
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;registry-mirrors&#34;</span>: <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>     <span style="color:#e6db74">&#34;https://8xpk5wnt.mirror.aliyuncs.com&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">]</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;insecure-registries&#34;</span>: <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>     <span style="color:#e6db74">&#34;172.21.51.143:5000&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ systemctl restart docker
</span></span><span style="display:flex;"><span>$ docker push 172.21.51.143:5000/nginx:alpine
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker images <span style="color:#75715e"># IMAGE ID相同，等于起别名或者加快捷方式</span>
</span></span><span style="display:flex;"><span>REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE
</span></span><span style="display:flex;"><span>172.21.51.143:5000/nginx   alpine              377c0837328f        <span style="color:#ae81ff">4</span> weeks ago     
</span></span><span style="display:flex;"><span>nginx                    alpine              377c0837328f        <span style="color:#ae81ff">4</span> weeks ago 
</span></span><span style="display:flex;"><span>localhost:5000/nginx     alpine              377c0837328f        <span style="color:#ae81ff">4</span> weeks ago  
</span></span><span style="display:flex;"><span>registry                 <span style="color:#ae81ff">2</span>                   708bc6af7e5e        <span style="color:#ae81ff">2</span> months ago   
</span></span></code></pre></div></li>
<li>
<p>删除镜像</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker rmi nginx:alpine
</span></span></code></pre></div></li>
<li>
<p>查看容器列表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">## 查看运行状态的容器列表</span>
</span></span><span style="display:flex;"><span>$ docker ps
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 查看全部状态的容器列表</span>
</span></span><span style="display:flex;"><span>$ docker ps -a
</span></span></code></pre></div></li>
<li>
<p>启动容器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">## 后台启动</span>
</span></span><span style="display:flex;"><span>$ docker run --name nginx -d nginx:alpine
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 映射端口,把容器的端口映射到宿主机中,-p &lt;host_port&gt;:&lt;container_port&gt;</span>
</span></span><span style="display:flex;"><span>$ docker run --name nginx -d -p 8080:80 nginx:alpine
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 资源限制,最大可用内存500M</span>
</span></span><span style="display:flex;"><span>$ docker run --memory<span style="color:#f92672">=</span>500m nginx:alpine
</span></span></code></pre></div></li>
<li>
<p>容器数据持久化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">## 挂载主机目录</span>
</span></span><span style="display:flex;"><span>$ docker run --name nginx -d  -v /opt:/opt  nginx:alpine
</span></span><span style="display:flex;"><span>$ docker run --name mysql -e MYSQL_ROOT_PASSWORD<span style="color:#f92672">=</span><span style="color:#ae81ff">123456</span>  -d -v /opt/mysql/:/var/lib/mysql mysql:5.7
</span></span></code></pre></div></li>
<li>
<p>进入容器或者执行容器内的命令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> $ docker exec -ti &lt;container_id_or_name&gt; /bin/sh
</span></span><span style="display:flex;"><span> $ docker exec &lt;container_id_or_name&gt; hostname
</span></span></code></pre></div></li>
<li>
<p>主机与容器之间拷贝数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> <span style="color:#75715e">## 主机拷贝到容器</span>
</span></span><span style="display:flex;"><span> $ echo <span style="color:#e6db74">&#39;123&#39;</span>&gt;/tmp/test.txt
</span></span><span style="display:flex;"><span> $ docker cp /tmp/test.txt nginx:/tmp
</span></span><span style="display:flex;"><span> $ docker exec -ti nginx cat /tmp/test.txt
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">123</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> <span style="color:#75715e">## 容器拷贝到主机</span>
</span></span><span style="display:flex;"><span> $ docker cp nginx:/tmp/test.txt ./
</span></span></code></pre></div></li>
<li>
<p>挂载已有的数据，重新创建镜像仓库容器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">## 解压离线镜像文件</span>
</span></span><span style="display:flex;"><span>$ tar zxf registry.tar.gz -C /opt
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">## 删除当前镜像仓库容器</span>
</span></span><span style="display:flex;"><span>$ docker rm -f registry
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">## 使用docker镜像启动镜像仓库服务</span>
</span></span><span style="display:flex;"><span>$ docker run -d -p 5000:5000 --restart always -v /opt/registry:/var/lib/registry --name registry registry:2
</span></span></code></pre></div><p>假设启动镜像仓库服务的主机地址为172.21.51.143，该目录中已存在的镜像列表：</p>
<table>
<thead>
<tr>
<th>现镜像仓库地址</th>
<th>原镜像仓库地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>172.21.51.143:5000/coreos/flannel:v0.11.0-amd64</td>
<td>quay.io/coreos/flannel:v0.11.0-amd64</td>
</tr>
<tr>
<td>172.21.51.143:5000/mysql:5.7</td>
<td>mysql:5.7</td>
</tr>
<tr>
<td>172.21.51.143:5000/nginx:alpine</td>
<td>nginx:alpine</td>
</tr>
<tr>
<td>172.21.51.143:5000/centos:centos7.5.1804</td>
<td>centos:centos7.5.1804</td>
</tr>
<tr>
<td>172.21.51.143:5000/elasticsearch/elasticsearch:7.4.2</td>
<td>docker.elastic.co/elasticsearch/elasticsearch:7.4.2</td>
</tr>
<tr>
<td>172.21.51.143:5000/fluentd-es-root:v1.6.2-1.0</td>
<td>quay.io/fluentd_elasticsearch/fluentd:v2.5.2</td>
</tr>
<tr>
<td>172.21.51.143:5000/kibana/kibana:7.4.2</td>
<td>docker.elastic.co/kibana/kibana:7.4.2</td>
</tr>
<tr>
<td>172.21.51.143:5000/kubernetesui/dashboard:v2.0.0-beta5</td>
<td>kubernetesui/dashboard:v2.0.0-beta5</td>
</tr>
<tr>
<td>172.21.51.143:5000/kubernetesui/metrics-scraper:v1.0.1</td>
<td>kubernetesui/metrics-scraper:v1.0.1</td>
</tr>
<tr>
<td>172.21.51.143:5000/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0</td>
<td>quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0</td>
</tr>
<tr>
<td>172.21.51.143:5000/jenkinsci/blueocean:latest</td>
<td>jenkinsci/blueocean:latest</td>
</tr>
<tr>
<td>172.21.51.143:5000/sonarqube:7.9-community</td>
<td>sonarqube:7.9-community</td>
</tr>
<tr>
<td>172.21.51.143:5000/postgres:11.4</td>
<td>postgres:11.4</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>查看容器日志</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> <span style="color:#75715e">## 查看全部日志</span>
</span></span><span style="display:flex;"><span> $ docker logs nginx
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> <span style="color:#75715e">## 实时查看最新日志</span>
</span></span><span style="display:flex;"><span> $ docker logs -f nginx
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> <span style="color:#75715e">## 从最新的100条开始查看</span>
</span></span><span style="display:flex;"><span> $ docker logs --tail<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span> -f nginx
</span></span></code></pre></div></li>
<li>
<p>停止或者删除容器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> <span style="color:#75715e">## 停止运行中的容器</span>
</span></span><span style="display:flex;"><span> $ docker stop nginx 
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> <span style="color:#75715e">## 启动退出容器</span>
</span></span><span style="display:flex;"><span> $ docker start nginx
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> <span style="color:#75715e">## 删除非运行中状态的容器</span>
</span></span><span style="display:flex;"><span> $ docker rm nginx
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> <span style="color:#75715e">## 删除运行中的容器</span>
</span></span><span style="display:flex;"><span> $ docker rm -f nginx
</span></span></code></pre></div></li>
<li>
<p>查看容器或者镜像的明细</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> <span style="color:#75715e">## 查看容器详细信息，包括容器IP地址等</span>
</span></span><span style="display:flex;"><span> $ docker inspect nginx
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> <span style="color:#75715e">## 查看镜像的明细信息</span>
</span></span><span style="display:flex;"><span> $ docker inspect nginx:alpine
</span></span></code></pre></div></li>
</ol>
<h6 id="dockerfile使用">Dockerfile使用<a hidden class="anchor" aria-hidden="true" href="#dockerfile使用">#</a></h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker build . -t ImageName:ImageTag -f Dockerfile
</span></span></code></pre></div><p>Dockerfile是一堆指令，在docker build的时候，按照该指令进行操作，最终生成我们期望的镜像</p>
<ul>
<li>
<p>FROM 指定基础镜像，必须为第一个命令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span>格式：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  FROM &lt;image&gt;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  FROM &lt;image&gt;:&lt;tag&gt;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>示例：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  FROM mysql:5.7<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>注意：  <span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>tag是可选的，如果不使用tag时，会使用latest版本的基础镜像<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div></li>
<li>
<p>MAINTAINER 镜像维护者的信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span>格式：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>	MAINTAINER &lt;name&gt;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>示例：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>	MAINTAINER Yongxin Li<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    MAINTAINER inspur_lyx@hotmail.com<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    MAINTAINER Yongxin Li &lt;inspur_lyx@hotmail.com&gt;<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div></li>
<li>
<p>COPY|ADD 添加本地文件到镜像中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span>格式：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  COPY &lt;src&gt;... &lt;dest&gt;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>示例：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    ADD hom* /mydir/          <span style="color:#75715e"># 添加所有以&#34;hom&#34;开头的文件</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    ADD test relativeDir/     <span style="color:#75715e"># 添加 &#34;test&#34; 到 `WORKDIR`/relativeDir/</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    ADD test /absoluteDir/    <span style="color:#75715e"># 添加 &#34;test&#34; 到 /absoluteDir/</span><span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div></li>
<li>
<p>WORKDIR 工作目录</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span>格式：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>		WORKDIR /path/to/workdir  <span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>示例：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    WORKDIR /a  <span style="color:#f92672">(</span>这时工作目录为/a<span style="color:#f92672">)</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>注意：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div></li>
<li>
<p>RUN 构建镜像过程中执行命令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span>格式：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  RUN &lt;command&gt;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>示例：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    RUN yum install nginx<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    RUN pip install django<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    RUN mkdir test <span style="color:#f92672">&amp;&amp;</span> rm -rf /var/lib/unusedfiles<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>注意：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div></li>
<li>
<p>CMD 构建容器后调用，也就是在容器启动时才进行调用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span>格式：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    CMD <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;executable&#34;</span>,<span style="color:#e6db74">&#34;param1&#34;</span>,<span style="color:#e6db74">&#34;param2&#34;</span><span style="color:#f92672">]</span> <span style="color:#f92672">(</span>执行可执行文件，优先<span style="color:#f92672">)</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    CMD <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;param1&#34;</span>,<span style="color:#e6db74">&#34;param2&#34;</span><span style="color:#f92672">]</span> <span style="color:#f92672">(</span>设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数<span style="color:#f92672">)</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    CMD command param1 param2 <span style="color:#f92672">(</span>执行shell内部命令<span style="color:#f92672">)</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>示例：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    CMD <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;/usr/bin/wc&#34;</span>,<span style="color:#e6db74">&#34;--help&#34;</span><span style="color:#f92672">]</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    CMD ping www.baidu.com<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>注意：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div></li>
<li>
<p>ENTRYPOINT 设置容器初始化命令，使其可执行化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span>格式：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    ENTRYPOINT <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;executable&#34;</span>, <span style="color:#e6db74">&#34;param1&#34;</span>, <span style="color:#e6db74">&#34;param2&#34;</span><span style="color:#f92672">]</span> <span style="color:#f92672">(</span>可执行文件, 优先<span style="color:#f92672">)</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    ENTRYPOINT command param1 param2 <span style="color:#f92672">(</span>shell内部命令<span style="color:#f92672">)</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>示例：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    ENTRYPOINT <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;/usr/bin/wc&#34;</span>,<span style="color:#e6db74">&#34;--help&#34;</span><span style="color:#f92672">]</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>注意：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>	ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div></li>
<li>
<p>ENV</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span>格式：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    ENV &lt;key&gt; &lt;value&gt;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    ENV &lt;key&gt;<span style="color:#f92672">=</span>&lt;value&gt;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>示例：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    ENV myName John<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    ENV myCat<span style="color:#f92672">=</span>fluffy<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div></li>
<li>
<p>EXPOSE</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span>格式：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    EXPOSE &lt;port&gt; <span style="color:#f92672">[</span>&lt;port&gt;...<span style="color:#f92672">]</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>示例：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    EXPOSE <span style="color:#ae81ff">80</span> <span style="color:#ae81ff">443</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    EXPOSE <span style="color:#ae81ff">8080</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    EXPOSE 11211/tcp 11211/udp<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>注意：<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>    EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/Dockerfile%E8%A7%A3%E9%87%8A.png" alt=""  />
</p>
</li>
<li>
<p>基础环境镜像</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> java:8-alpine</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> apk add --update ca-certificates <span style="color:#f92672">&amp;&amp;</span> rm -rf /var/cache/apk/* <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  find /usr/share/ca-certificates/mozilla/ -name <span style="color:#e6db74">&#34;*.crt&#34;</span> -exec keytool -import -trustcacerts <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -keystore /usr/lib/jvm/java-1.8-openjdk/jre/lib/security/cacerts -storepass changeit -noprompt <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -file <span style="color:#f92672">{}</span> -alias <span style="color:#f92672">{}</span> <span style="color:#ae81ff">\;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  keytool -list -keystore /usr/lib/jvm/java-1.8-openjdk/jre/lib/security/cacerts --storepass changeit<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENV</span> MAVEN_VERSION 3.5.4<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENV</span> MAVEN_HOME /usr/lib/mvn<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENV</span> PATH $MAVEN_HOME/bin:$PATH<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> wget http://archive.apache.org/dist/maven/maven-3/$MAVEN_VERSION/binaries/apache-maven-$MAVEN_VERSION-bin.tar.gz <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  tar -zxvf apache-maven-$MAVEN_VERSION-bin.tar.gz <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  rm apache-maven-$MAVEN_VERSION-bin.tar.gz <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  mv apache-maven-$MAVEN_VERSION /usr/lib/mvn<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> mkdir -p /usr/src/app<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /usr/src/app</span><span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div></li>
<li>
<p>前端镜像</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> nginx:1.19.0-alpine</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">LABEL</span> maintainer<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;mritd &lt;mritd@linux.com&gt;&#34;</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ARG</span> TZ<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Asia/Shanghai&#39;</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENV</span> TZ <span style="color:#e6db74">${</span>TZ<span style="color:#e6db74">}</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> apk upgrade --update <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#f92672">&amp;&amp;</span> apk add bash tzdata curl wget ca-certificates <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#f92672">&amp;&amp;</span> ln -sf /usr/share/zoneinfo/<span style="color:#e6db74">${</span>TZ<span style="color:#e6db74">}</span> /etc/localtime <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#f92672">&amp;&amp;</span> echo <span style="color:#e6db74">${</span>TZ<span style="color:#e6db74">}</span> &gt; /etc/timezone <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#f92672">&amp;&amp;</span> rm -rf /usr/share/nginx/html /var/cache/apk/*<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> landscape-animation-experiment /usr/share/nginx/html<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">EXPOSE</span><span style="color:#e6db74"> 80 443</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">CMD</span> [<span style="color:#e6db74">&#34;nginx&#34;</span>, <span style="color:#e6db74">&#34;-g&#34;</span>, <span style="color:#e6db74">&#34;daemon off;&#34;</span>]<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div></li>
<li>
<p>java镜像</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> java:8u111</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENV</span> JAVA_OPTS <span style="color:#e6db74">&#34;\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">-Xmx4096m \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">-XX:MetaspaceSize=256m \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">-XX:MaxMetaspaceSize=256m&#34;</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENV</span> JAVA_HOME /usr/java/jdk<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENV</span> PATH <span style="color:#e6db74">${</span>PATH<span style="color:#e6db74">}</span>:<span style="color:#e6db74">${</span>JAVA_HOME<span style="color:#e6db74">}</span>/bin<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> target/myapp.jar myapp.jar<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> echo <span style="color:#e6db74">&#39;Asia/Shanghai&#39;</span> &gt;/etc/timezone<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">EXPOSE</span><span style="color:#e6db74"> 9000</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">CMD</span> java <span style="color:#e6db74">${</span>JAVA_OPTS<span style="color:#e6db74">}</span> -jar myapp.jar<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div></li>
<li>
<p>golang镜像</p>
<p>多阶段构建</p>
</li>
</ul>
<h6 id="多阶构建">多阶构建<a hidden class="anchor" aria-hidden="true" href="#多阶构建">#</a></h6>
<p><a href="https://gitee.com/agagin/href-counter.git">https://gitee.com/agagin/href-counter.git</a></p>
<p>原始构建：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> golang:1.13</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /go/src/github.com/alexellis/href-counter/</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> vendor vendor<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> app.go .<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENV</span> GOPROXY https://goproxy.cn<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> CGO_ENABLED<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> GOOS<span style="color:#f92672">=</span>linux go build -a -installsuffix cgo -o app .<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>$ docker build . -t href-counter:v1 -f Dockerfile<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>多阶构建：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> golang:1.13 AS builder</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /go/src/github.com/alexellis/href-counter/</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> vendor vendor<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> app.go .<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENV</span> GOPROXY https://goproxy.cn<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> CGO_ENABLED<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> GOOS<span style="color:#f92672">=</span>linux go build -a -installsuffix cgo -o app .<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> alpine:3.10</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> apk --no-cache add ca-certificates<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /root/</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> --from<span style="color:#f92672">=</span>builder  /go/src/github.com/alexellis/href-counter/app    .<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">CMD</span> [<span style="color:#e6db74">&#34;./app&#34;</span>]<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>$ docker build . -t href-counter:v2 -f Dockerfile.multi<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>原则：</p>
<ul>
<li>不必要的内容不要放在镜像中</li>
<li>减少不必要的层文件</li>
<li>减少网络传输操作</li>
<li>可以适当的包含一些调试命令</li>
</ul>
<h6 id="通过1号进程理解容器的本质">通过1号进程理解容器的本质<a hidden class="anchor" aria-hidden="true" href="#通过1号进程理解容器的本质">#</a></h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker exec -ti my-nginx-alpine /bin/sh
</span></span><span style="display:flex;"><span><span style="color:#75715e">#/ ps aux</span>
</span></span></code></pre></div><p>容器启动的时候可以通过命令去覆盖默认的CMD</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker run -d --name xxx nginx:alpine &lt;自定义命令&gt;
</span></span><span style="display:flex;"><span><span style="color:#75715e"># &lt;自定义命令&gt;会覆盖镜像中指定的CMD指令，作为容器的1号进程启动。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ docker run -d --name test-3 nginx:alpine echo <span style="color:#ae81ff">123</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ docker run -d --name test-4 nginx:alpine ping www.luffycity.com
</span></span></code></pre></div><p>本质上讲容器是利用namespace和cgroup等技术在宿主机中创建的独立的虚拟空间，这个空间内的网络、进程、挂载等资源都是隔离的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker exec -ti my-nginx /bin/sh
</span></span><span style="display:flex;"><span><span style="color:#75715e">#/ ip addr</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#/ ls -l /</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#/ apt install xxx</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#/ #安装的软件对宿主机和其他容器没有任何影响，和虚拟机不同的是，容器间共享一个内核，所以容器内没法升级内核</span>
</span></span></code></pre></div><h4 id="django应用容器化实践">Django应用容器化实践<a hidden class="anchor" aria-hidden="true" href="#django应用容器化实践">#</a></h4>
<h6 id="django项目介绍">django项目介绍<a hidden class="anchor" aria-hidden="true" href="#django项目介绍">#</a></h6>
<ul>
<li>项目地址：https://gitee.com/agagin/python-demo.git</li>
<li>python3 + django + uwsgi + nginx + mysql</li>
<li>内部服务端口8002</li>
</ul>
<h6 id="容器化django项目">容器化Django项目<a hidden class="anchor" aria-hidden="true" href="#容器化django项目">#</a></h6>
<p><em>dockerfiles/myblog/Dockerfile</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span><span style="color:#75715e"># This my first django Dockerfile</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># Version 1.0</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># Base images 基础镜像</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> centos:centos7.5.1804</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e">#MAINTAINER 维护者信息</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">LABEL</span> maintainer<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;inspur_lyx@hotmail.com&#34;</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e">#ENV 设置环境变量</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENV</span> LANG en_US.UTF-8<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENV</span> LC_ALL en_US.UTF-8<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e">#RUN 执行以下命令</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> curl -so /etc/yum.repos.d/Centos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo <span style="color:#f92672">&amp;&amp;</span> rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> yum install -y  python36 python3-devel gcc pcre-devel zlib-devel make net-tools nginx<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e">#工作目录</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /opt/myblog</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e">#拷贝文件至工作目录</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> . .<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 拷贝nginx配置文件</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> myblog.conf /etc/nginx<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e">#安装依赖的插件</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> pip3 install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com -r requirements.txt<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> chmod +x run.sh <span style="color:#f92672">&amp;&amp;</span> rm -rf ~/.cache/pip<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e">#EXPOSE 映射端口</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">EXPOSE</span><span style="color:#e6db74"> 8002</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e">#容器启动时执行命令</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">CMD</span> [<span style="color:#e6db74">&#34;./run.sh&#34;</span>]<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>执行构建：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker build . -t myblog:v1 -f Dockerfile
</span></span></code></pre></div><h6 id="运行mysql">运行mysql<a hidden class="anchor" aria-hidden="true" href="#运行mysql">#</a></h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">$</span> docker run <span style="color:#f92672">-</span>d <span style="color:#f92672">-</span>p <span style="color:#ae81ff">3306</span>:<span style="color:#ae81ff">3306</span> <span style="color:#f92672">--</span>name mysql  <span style="color:#f92672">-</span>v <span style="color:#f92672">/</span>opt<span style="color:#f92672">/</span>mysql:<span style="color:#f92672">/</span>var<span style="color:#f92672">/</span>lib<span style="color:#f92672">/</span>mysql <span style="color:#f92672">-</span>e MYSQL_DATABASE<span style="color:#f92672">=</span>myblog <span style="color:#f92672">-</span>e MYSQL_ROOT_PASSWORD<span style="color:#f92672">=</span><span style="color:#ae81ff">123456</span> mysql:<span style="color:#ae81ff">5</span>.<span style="color:#ae81ff">7</span> <span style="color:#f92672">--</span><span style="color:#66d9ef">character</span><span style="color:#f92672">-</span><span style="color:#66d9ef">set</span><span style="color:#f92672">-</span>server<span style="color:#f92672">=</span>utf8mb4 <span style="color:#f92672">--</span>collation<span style="color:#f92672">-</span>server<span style="color:#f92672">=</span>utf8mb4_unicode_ci
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 参数传递
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">## 查看数据库
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">$</span> docker exec <span style="color:#f92672">-</span>ti mysql bash
</span></span><span style="display:flex;"><span><span style="color:#75715e">#/ mysql -uroot -p123456
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#/ show databases;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## navicator连接
</span></span></span></code></pre></div><h6 id="启动django应用">启动Django应用<a hidden class="anchor" aria-hidden="true" href="#启动django应用">#</a></h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">## 启动容器</span>
</span></span><span style="display:flex;"><span>$ docker run -d -p 8002:8002 --name myblog -e MYSQL_HOST<span style="color:#f92672">=</span>172.21.51.143 -e MYSQL_USER<span style="color:#f92672">=</span>root -e MYSQL_PASSWD<span style="color:#f92672">=</span><span style="color:#ae81ff">123456</span>  myblog:v1 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## migrate</span>
</span></span><span style="display:flex;"><span>$ docker exec -ti myblog bash
</span></span><span style="display:flex;"><span><span style="color:#75715e">#/ python3 manage.py makemigrations</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#/ python3 manage.py migrate</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#/ python3 manage.py createsuperuser</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 创建超级用户</span>
</span></span><span style="display:flex;"><span>$ docker exec -ti myblog python3 manage.py createsuperuser
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 收集静态文件</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## $ docker exec -ti myblog python3 manage.py collectstatic</span>
</span></span></code></pre></div><p>访问172.21.51.143:8002/admin</p>
<h4 id="实现原理">实现原理<a hidden class="anchor" aria-hidden="true" href="#实现原理">#</a></h4>
<p>docker优势：</p>
<ul>
<li>
<p>轻量级的虚拟化</p>
</li>
<li>
<p>容器快速启停</p>
</li>
</ul>
<p>虚拟化核心需要解决的问题：资源隔离与资源限制</p>
<ul>
<li>虚拟机硬件虚拟化技术， 通过一个 hypervisor 层实现对资源的彻底隔离。</li>
<li>容器则是操作系统级别的虚拟化，利用的是内核的 Cgroup 和 Namespace 特性，此功能完全通过软件实现。</li>
</ul>
<h6 id="namespace-资源隔离">Namespace 资源隔离<a hidden class="anchor" aria-hidden="true" href="#namespace-资源隔离">#</a></h6>
<p>命名空间是全局资源的一种抽象，将资源放到不同的命名空间中，各个命名空间中的资源是相互隔离的。</p>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>系统调用参数</strong></th>
<th><strong>相关内核版本</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Mount namespaces</td>
<td>CLONE_NEWNS</td>
<td><a href="http://lwn.net/2001/0301/a/namespaces.php3">Linux 2.4.19</a></td>
</tr>
<tr>
<td>UTS namespaces</td>
<td>CLONE_NEWUTS</td>
<td><a href="http://lwn.net/Articles/179345/">Linux 2.6.19</a></td>
</tr>
<tr>
<td>IPC namespaces</td>
<td>CLONE_NEWIPC</td>
<td><a href="http://lwn.net/Articles/187274/">Linux 2.6.19</a></td>
</tr>
<tr>
<td>PID namespaces</td>
<td>CLONE_NEWPID</td>
<td><a href="http://lwn.net/Articles/259217/">Linux 2.6.24</a></td>
</tr>
<tr>
<td>Network namespaces</td>
<td>CLONE_NEWNET</td>
<td><a href="http://lwn.net/Articles/219794/">始于Linux 2.6.24 完成于 Linux 2.6.29</a></td>
</tr>
<tr>
<td>User namespaces</td>
<td>CLONE_NEWUSER</td>
<td><a href="http://lwn.net/Articles/528078/">始于 Linux 2.6.23 完成于 Linux 3.8</a></td>
</tr>
</tbody>
</table>
<p>我们知道，docker容器对于操作系统来讲其实是一个进程，我们可以通过原始的方式来模拟一下容器实现资源隔离的基本原理：</p>
<p>linux系统中，通常可以通过<code>clone()</code>实现进程创建的系统调用 ，原型如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">clone</span>(<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>child_func)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>), <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>child_stack, <span style="color:#66d9ef">int</span> flags, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg);
</span></span></code></pre></div><ul>
<li><strong>child_func</strong> : 传入子进程运行的程序主函数。</li>
<li><strong>child_stack</strong> : 传入子进程使用的栈空间。</li>
<li><strong>flags</strong> : 表示使用哪些 <code>CLONE_*</code> 标志位。</li>
<li><strong>args</strong> : 用于传入用户参数。</li>
</ul>
<p>示例一：实现进程独立的UTS空间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define _GNU_SOURCE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/mount.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/wait.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sched.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;signal.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define STACK_SIZE (1024 * 1024)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span> container_stack[STACK_SIZE];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> container_args[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;/bin/bash&#34;</span>,
</span></span><span style="display:flex;"><span>  NULL
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">container_main</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;Container - inside the container!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  sethostname(<span style="color:#e6db74">&#34;container&#34;</span>,<span style="color:#ae81ff">10</span>); <span style="color:#75715e">/* 设置hostname */</span>
</span></span><span style="display:flex;"><span>  execv(container_args[<span style="color:#ae81ff">0</span>], container_args);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;Something&#39;s wrong!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;Parent - start a container!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> container_pid <span style="color:#f92672">=</span> clone(container_main, container_stack<span style="color:#f92672">+</span>STACK_SIZE, CLONE_NEWUTS <span style="color:#f92672">|</span> SIGCHLD , NULL);
</span></span><span style="display:flex;"><span>  waitpid(container_pid, NULL, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;Parent - container stopped!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>执行编译并测试：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ gcc -o ns_uts ns_uts.c
</span></span><span style="display:flex;"><span>$ ./ns_uts
</span></span><span style="display:flex;"><span>$ hostname
</span></span></code></pre></div><p>示例二：实现容器独立的进程空间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define _GNU_SOURCE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/mount.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/wait.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sched.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;signal.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define STACK_SIZE (1024 * 1024)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span> container_stack[STACK_SIZE];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> container_args[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;/bin/bash&#34;</span>,
</span></span><span style="display:flex;"><span>  NULL
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">container_main</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;Container [%5d] - inside the container!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, getpid());
</span></span><span style="display:flex;"><span>  sethostname(<span style="color:#e6db74">&#34;container&#34;</span>,<span style="color:#ae81ff">10</span>); <span style="color:#75715e">/* 设置hostname */</span>
</span></span><span style="display:flex;"><span>  execv(container_args[<span style="color:#ae81ff">0</span>], container_args);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;Something&#39;s wrong!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;Parent [%5d] - start a container!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, getpid());
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> container_pid <span style="color:#f92672">=</span> clone(container_main, container_stack<span style="color:#f92672">+</span>STACK_SIZE, CLONE_NEWUTS <span style="color:#f92672">|</span> CLONE_NEWPID <span style="color:#f92672">|</span> SIGCHLD , NULL);
</span></span><span style="display:flex;"><span>  waitpid(container_pid, NULL, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;Parent - container stopped!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>执行编译并测试：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ gcc -o ns_pid ns_pid.c
</span></span><span style="display:flex;"><span>$ ./ns_pid
</span></span><span style="display:flex;"><span>$ echo $$
</span></span></code></pre></div><p>如何确定进程是否属于同一个namespace：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ ./ns_pid
</span></span><span style="display:flex;"><span>Parent <span style="color:#f92672">[</span> 8061<span style="color:#f92672">]</span> - start a container!
</span></span><span style="display:flex;"><span>$ pstree -p <span style="color:#ae81ff">8061</span>
</span></span><span style="display:flex;"><span>pid1<span style="color:#f92672">(</span>8061<span style="color:#f92672">)</span>───bash<span style="color:#f92672">(</span>8062<span style="color:#f92672">)</span>───pstree<span style="color:#f92672">(</span>8816<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>$ ls -l /proc/8061/ns
</span></span><span style="display:flex;"><span>lrwxrwxrwx <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">0</span> Jun <span style="color:#ae81ff">24</span> 12:51 ipc -&gt; ipc:<span style="color:#f92672">[</span>4026531839<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>lrwxrwxrwx <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">0</span> Jun <span style="color:#ae81ff">24</span> 12:51 mnt -&gt; mnt:<span style="color:#f92672">[</span>4026531840<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>lrwxrwxrwx <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">0</span> Jun <span style="color:#ae81ff">24</span> 12:51 net -&gt; net:<span style="color:#f92672">[</span>4026531968<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>lrwxrwxrwx <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">0</span> Jun <span style="color:#ae81ff">24</span> 12:51 pid -&gt; pid:<span style="color:#f92672">[</span>4026531836<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>lrwxrwxrwx <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">0</span> Jun <span style="color:#ae81ff">24</span> 12:51 user -&gt; user:<span style="color:#f92672">[</span>4026531837<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>lrwxrwxrwx <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">0</span> Jun <span style="color:#ae81ff">24</span> 12:51 uts -&gt; uts:<span style="color:#f92672">[</span>4026531838<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>$ ls -l /proc/8062/ns
</span></span><span style="display:flex;"><span>lrwxrwxrwx <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">0</span> Jun <span style="color:#ae81ff">24</span> 12:51 ipc -&gt; ipc:<span style="color:#f92672">[</span>4026531839<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>lrwxrwxrwx <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">0</span> Jun <span style="color:#ae81ff">24</span> 12:51 mnt -&gt; mnt:<span style="color:#f92672">[</span>4026531840<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>lrwxrwxrwx <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">0</span> Jun <span style="color:#ae81ff">24</span> 12:51 net -&gt; net:<span style="color:#f92672">[</span>4026531968<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>lrwxrwxrwx <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">0</span> Jun <span style="color:#ae81ff">24</span> 12:51 pid -&gt; pid:<span style="color:#f92672">[</span>4026534845<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>lrwxrwxrwx <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">0</span> Jun <span style="color:#ae81ff">24</span> 12:51 user -&gt; user:<span style="color:#f92672">[</span>4026531837<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>lrwxrwxrwx <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">0</span> Jun <span style="color:#ae81ff">24</span> 12:51 uts -&gt; uts:<span style="color:#f92672">[</span>4026534844<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 发现pid和uts是和父进程使用了不同的ns，其他的则是继承了父进程的命名空间</span>
</span></span></code></pre></div><p>综上：通俗来讲，docker在启动一个容器的时候，会调用Linux Kernel Namespace的接口，来创建一块虚拟空间，创建的时候，可以支持设置下面这几种（可以随意选择）,docker默认都设置。</p>
<ul>
<li>pid：用于进程隔离（PID：进程ID）</li>
<li>net：管理网络接口（NET：网络）</li>
<li>ipc：管理对 IPC 资源的访问（IPC：进程间通信（信号量、消息队列和共享内存））</li>
<li>mnt：管理文件系统挂载点（MNT：挂载）</li>
<li>uts：隔离主机名和域名</li>
<li>user：隔离用户和用户组</li>
</ul>
<h6 id="cgroup-资源限制">CGroup 资源限制<a hidden class="anchor" aria-hidden="true" href="#cgroup-资源限制">#</a></h6>
<p>通过namespace可以保证容器之间的隔离，但是无法控制每个容器可以占用多少资源， 如果其中的某一个容器正在执行 CPU 密集型的任务，那么就会影响其他容器中任务的性能与执行效率，导致多个容器相互影响并且抢占资源。如何对多个容器的资源使用进行限制就成了解决进程虚拟资源隔离之后的主要问题。</p>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/cgroup.png" alt=""  />
</p>
<p>Control Groups（简称 CGroups）</p>
<blockquote>
<p>cgroups是Linux内核提供的一种机制，这种机制可以根据需求吧一系列系统任务及其子任务整合(或分隔)到按资源划分等级的不同组中，从而为系统资源管理提供一个统一的框架。</p>
</blockquote>
<p>CGroups能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I/O 。每一个 CGroup 都是一组被相同的标准和参数限制的进程。而我们需要做的，其实就是把容器这个进程加入到指定的Cgroup中。深入理解CGroup，请<a href="!%5Bimage-20200323195718300%5D(C:%5CUsers%5Cliyongxin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200323195718300.png)">点此</a>。</p>
<h6 id="unionfs-联合文件系统">UnionFS 联合文件系统<a hidden class="anchor" aria-hidden="true" href="#unionfs-联合文件系统">#</a></h6>
<p>Linux namespace和cgroup分别解决了容器的资源隔离与资源限制，那么容器是很轻量的，通常每台机器中可以运行几十上百个容器， 这些个容器是共用一个image，还是各自将这个image复制了一份，然后各自独立运行呢？ 如果每个容器之间都是全量的文件系统拷贝，那么会导致至少如下问题：</p>
<ul>
<li>运行容器的速度会变慢</li>
<li>容器和镜像对宿主机的磁盘空间的压力</li>
</ul>
<p>怎么解决这个问题&mdash;&mdash;Docker的存储驱动</p>
<ul>
<li>镜像分层存储</li>
<li>UnionFS</li>
</ul>
<p>Docker 镜像是由一系列的层组成的，每层代表 Dockerfile 中的一条指令，比如下面的 Dockerfile 文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> ubuntu:15.04</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> . /app<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> make /app<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">CMD</span> python /app/app.py<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>这里的 Dockerfile 包含4条命令，其中每一行就创建了一层，下面显示了上述Dockerfile构建出来的镜像运行的容器层的结构：</p>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/container-layers.jpg" alt=""  />
</p>
<p>镜像就是由这些层一层一层堆叠起来的，镜像中的这些层都是只读的，当我们运行容器的时候，就可以在这些基础层至上添加新的可写层，也就是我们通常说的<code>容器层</code>，对于运行中的容器所做的所有更改（比如写入新文件、修改现有文件、删除文件）都将写入这个容器层。</p>
<p>对容器层的操作，主要利用了写时复制（CoW）技术。CoW就是copy-on-write，表示只在需要写时才去复制，这个是针对已有文件的修改场景。 CoW技术可以让所有的容器共享image的文件系统，所有数据都从image中读取，只有当要对文件进行写操作时，才从image里把要写的文件复制到自己的文件系统进行修改。所以无论有多少个容器共享同一个image，所做的写操作都是对从image中复制到自己的文件系统中的复本上进行，并不会修改image的源文件，且多个容器操作同一个文件，会在每个容器的文件系统里生成一个复本，每个容器修改的都是自己的复本，相互隔离，相互不影响。使用CoW可以有效的提高磁盘的利用率。</p>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/sharing-layers.jpg" alt=""  />
</p>
<p><strong>镜像中每一层的文件都是分散在不同的目录中的，如何把这些不同目录的文件整合到一起呢？</strong></p>
<p>UnionFS 其实是一种为 Linux 操作系统设计的用于把多个文件系统联合到同一个挂载点的文件系统服务。  它能够将不同文件夹中的层联合（Union）到了同一个文件夹中，整个联合的过程被称为联合挂载（Union Mount）。</p>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/aufs.png" alt=""  />
</p>
<p>上图是AUFS的实现，AUFS是作为Docker存储驱动的一种实现，Docker 还支持了不同的存储驱动，包括 aufs、devicemapper、overlay2、zfs 和  Btrfs 等等，在最新的 Docker 中，overlay2 取代了 aufs 成为了推荐的存储驱动，但是在没有 overlay2 驱动的机器上仍然会使用 aufs 作为 Docker 的默认驱动。</p>
<h4 id="docker网络">Docker网络<a hidden class="anchor" aria-hidden="true" href="#docker网络">#</a></h4>
<p>docker容器是一块具有隔离性的虚拟系统，容器内可以有自己独立的网络空间，</p>
<ul>
<li>多个容器之间是如何实现通信的呢？</li>
<li>容器和宿主机之间又是如何实现的通信呢？</li>
<li>使用-p参数是怎么实现的端口映射?</li>
</ul>
<p>带着这些问题，我们来学习一下docker的网络模型，最后我会通过抓包的方式，给大家演示一下数据包在容器和宿主机之间的转换过程。</p>
<h5 id="网络模式">网络模式<a hidden class="anchor" aria-hidden="true" href="#网络模式">#</a></h5>
<p>我们在使用docker run创建Docker容器时，可以用&ndash;net选项指定容器的网络模式，Docker有以下4种网络模式：</p>
<ul>
<li>
<p>bridge模式，使用&ndash;net=bridge指定，默认设置</p>
</li>
<li>
<p>host模式，使用&ndash;net=host指定，容器内部网络空间共享宿主机的空间，效果类似直接在宿主机上启动一个进程，端口信息和宿主机共用</p>
</li>
<li>
<p>container模式，使用&ndash;net=container:NAME_or_ID指定</p>
<p>指定容器与特定容器共享网络命名空间</p>
</li>
<li>
<p>none模式，使用&ndash;net=none指定</p>
<p>网络模式为空，即仅保留网络命名空间，但是不做任何网络相关的配置(网卡、IP、路由等)</p>
</li>
</ul>
<h5 id="bridge模式">bridge模式<a hidden class="anchor" aria-hidden="true" href="#bridge模式">#</a></h5>
<p>那我们之前在演示创建docker容器的时候其实是没有指定的网络模式的，如果不指定的话默认就会使用bridge模式，bridge本意是桥的意思，其实就是网桥模式。</p>
<p>那我们怎么理解网桥，如果需要做类比的话，我们可以把网桥看成一个二层的交换机设备，我们来看下这张图：</p>
<p>交换机通信简图</p>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/exchange1.bmp" alt=""  />
</p>
<p>交换机网络通信流程：</p>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/exchange2.png" alt=""  />
</p>
<p>网桥模式示意图</p>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/docker-bridge.jpeg" alt=""  />
</p>
<p>Linux 中，能够起到<strong>虚拟交换机作用</strong>的网络设备，是网桥（Bridge）。它是一个工作在<strong>数据链路层</strong>（Data Link）的设备，主要功能是<strong>根据 MAC 地址将数据包转发到网桥的不同端口上</strong>。 网桥在哪，查看网桥</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ yum install -y bridge-utils
</span></span><span style="display:flex;"><span>$ brctl show
</span></span><span style="display:flex;"><span>bridge name     bridge id               STP enabled     interfaces
</span></span><span style="display:flex;"><span>docker0         8000.0242b5fbe57b       no              veth3a496ed
</span></span></code></pre></div><p>有了网桥之后，那我们看下docker在启动一个容器的时候做了哪些事情才能实现容器间的互联互通</p>
<p>Docker 创建一个容器的时候，会执行如下操作：</p>
<ul>
<li>创建一对虚拟接口/网卡，也就是veth pair；</li>
<li>veth pair的一端桥接 到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 vethxxxxxx；</li>
<li>veth paid的另一端放到新启动的容器内部，并修改名字作为 eth0，这个网卡/接口只在容器的命名空间可见；</li>
<li>从网桥可用地址段中（也就是与该bridge对应的network）获取一个空闲地址分配给容器的 eth0</li>
<li>配置容器的默认路由</li>
</ul>
<p>那整个过程其实是docker自动帮我们完成的，清理掉所有容器，来验证。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">## 清掉所有容器</span>
</span></span><span style="display:flex;"><span>$ docker rm -f <span style="color:#e6db74">`</span>docker ps -aq<span style="color:#e6db74">`</span>
</span></span><span style="display:flex;"><span>$ docker ps
</span></span><span style="display:flex;"><span>$ brctl show <span style="color:#75715e"># 查看网桥中的接口，目前没有</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 创建测试容器test1</span>
</span></span><span style="display:flex;"><span>$ docker run -d --name test1 nginx:alpine
</span></span><span style="display:flex;"><span>$ brctl show <span style="color:#75715e"># 查看网桥中的接口，已经把test1的veth端接入到网桥中</span>
</span></span><span style="display:flex;"><span>$ ip a |grep veth <span style="color:#75715e"># 已在宿主机中可以查看到</span>
</span></span><span style="display:flex;"><span>$ docker exec -ti test1 sh 
</span></span><span style="display:flex;"><span>/ <span style="color:#75715e"># ifconfig  # 查看容器的eth0网卡及分配的容器ip</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 再来启动一个测试容器，测试容器间的通信</span>
</span></span><span style="display:flex;"><span>$ docker run -d --name test2 nginx:alpine
</span></span><span style="display:flex;"><span>$ docker exec -ti test2 sh
</span></span><span style="display:flex;"><span>/ <span style="color:#75715e"># sed -i &#39;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&#39; /etc/apk/repositories</span>
</span></span><span style="display:flex;"><span>/ <span style="color:#75715e"># apk add curl</span>
</span></span><span style="display:flex;"><span>/ <span style="color:#75715e"># curl 172.17.0.8:80</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 为啥可以通信？</span>
</span></span><span style="display:flex;"><span>/ <span style="color:#75715e"># route -n  # </span>
</span></span><span style="display:flex;"><span>Kernel IP routing table
</span></span><span style="display:flex;"><span>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
</span></span><span style="display:flex;"><span>0.0.0.0         172.17.0.1      0.0.0.0         UG    <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>        <span style="color:#ae81ff">0</span> eth0
</span></span><span style="display:flex;"><span>172.17.0.0      0.0.0.0         255.255.0.0     U     <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>        <span style="color:#ae81ff">0</span> eth0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># eth0 网卡是这个容器里的默认路由设备；所有对 172.17.0.0/16 网段的请求，也会被交给 eth0 来处理（第二条 172.17.0.0 路由规则），这条路由规则的网关（Gateway）是 0.0.0.0，这就意味着这是一条直连规则，即：凡是匹配到这条规则的 IP 包，应该经过本机的 eth0 网卡，通过二层网络(数据链路层)直接发往目的主机。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 而要通过二层网络到达 test1 容器，就需要有 172.17.0.8 这个 IP 地址对应的 MAC 地址。所以test2容器的网络协议栈，就需要通过 eth0 网卡发送一个 ARP 广播，来通过 IP 地址查找对应的 MAC 地址。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#这个 eth0 网卡，是一个 Veth Pair，它的一端在这个 test2 容器的 Network Namespace 里，而另一端则位于宿主机上（Host Namespace），并且被“插”在了宿主机的 docker0 网桥上。网桥设备的一个特点是插在桥上的网卡都会被当成桥上的一个端口来处理，而端口的唯一作用就是接收流入的数据包，然后把这些数据包的“生杀大权”（比如转发或者丢弃），全部交给对应的网桥设备处理。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 因此ARP的广播请求也会由docker0来负责转发，这样网桥就维护了一份端口与mac的信息表，因此针对test2的eth0拿到mac地址后发出的各类请求，同样走到docker0网桥中由网桥负责转发到对应的容器中。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 网桥会维护一份mac映射表，我们可以大概通过命令来看一下，</span>
</span></span><span style="display:flex;"><span>$ brctl showmacs docker0
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 这些mac地址是主机端的veth网卡对应的mac，可以查看一下</span>
</span></span><span style="display:flex;"><span>$ ip a 
</span></span></code></pre></div><p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/bridge-network.png" alt=""  />
</p>
<p>我们如何知道网桥上的这些虚拟网卡与容器端是如何对应？</p>
<p>通过ifindex，网卡索引号</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">## 查看test1容器的网卡索引</span>
</span></span><span style="display:flex;"><span>$ docker exec -ti test1 cat /sys/class/net/eth0/ifindex
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 主机中找到虚拟网卡后面这个@ifxx的值，如果是同一个值，说明这个虚拟网卡和这个容器的eth0网卡是配对的。</span>
</span></span><span style="display:flex;"><span>$ ip a |grep @if
</span></span></code></pre></div><p>整理脚本，快速查看对应：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> container in <span style="color:#66d9ef">$(</span>docker ps -q<span style="color:#66d9ef">)</span>; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    iflink<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>docker exec -it $container sh -c <span style="color:#e6db74">&#39;cat /sys/class/net/eth0/iflink&#39;</span><span style="color:#e6db74">`</span>
</span></span><span style="display:flex;"><span>    iflink<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>echo $iflink|tr -d <span style="color:#e6db74">&#39;\r&#39;</span><span style="color:#e6db74">`</span>
</span></span><span style="display:flex;"><span>    veth<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>grep -l $iflink /sys/class/net/veth*/ifindex<span style="color:#e6db74">`</span>
</span></span><span style="display:flex;"><span>    veth<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>echo $veth|sed -e <span style="color:#e6db74">&#39;s;^.*net/\(.*\)/ifindex$;\1;&#39;</span><span style="color:#e6db74">`</span>
</span></span><span style="display:flex;"><span>    echo $container:$veth
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span></code></pre></div><p>上面我们讲解了容器之间的通信，那么容器与宿主机的通信是如何做的？</p>
<p>添加端口映射：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">## 启动容器的时候通过-p参数添加宿主机端口与容器内部服务端口的映射</span>
</span></span><span style="display:flex;"><span>$ docker run --name test -d -p 8088:80 nginx:alpine
</span></span><span style="display:flex;"><span>$ curl localhost:8088
</span></span></code></pre></div><p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/docker-bridge.jpeg" alt=""  />
</p>
<p>端口映射如何实现的？先来回顾iptables链表图</p>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/iptables.png" alt=""  />
</p>
<p>访问本机的8088端口，数据包会从流入方向进入本机，因此涉及到PREROUTING和INPUT链，我们是通过做宿主机与容器之间加的端口映射，所以肯定会涉及到端口转换，那哪个表是负责存储端口转换信息的呢，就是nat表，负责维护网络地址转换信息的。因此我们来查看一下PREROUTING链的nat表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ iptables -t nat -nvL PREROUTING
</span></span><span style="display:flex;"><span>Chain PREROUTING <span style="color:#f92672">(</span>policy ACCEPT <span style="color:#ae81ff">159</span> packets, <span style="color:#ae81ff">20790</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span> pkts bytes target     prot opt in     out     source               destination
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">3</span>   <span style="color:#ae81ff">156</span> DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL
</span></span></code></pre></div><p>规则利用了iptables的addrtype拓展，匹配网络类型为本地的包，如何确定哪些是匹配本地，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ ip route show table local type local
</span></span><span style="display:flex;"><span>127.0.0.0/8 dev lo proto kernel scope host src 127.0.0.1
</span></span><span style="display:flex;"><span>127.0.0.1 dev lo proto kernel scope host src 127.0.0.1
</span></span><span style="display:flex;"><span>172.17.0.1 dev docker0 proto kernel scope host src 172.17.0.1
</span></span><span style="display:flex;"><span>172.21.51.143 dev eth0 proto kernel scope host src 172.21.51.143
</span></span></code></pre></div><p>也就是说目标地址类型匹配到这些的，会转发到我们的TARGET中，TARGET是动作，意味着对符合要求的数据包执行什么样的操作，最常见的为ACCEPT或者DROP，此处的TARGET为DOCKER，很明显DOCKER不是标准的动作，那DOCKER是什么呢？我们通常会定义自定义的链，这样把某类对应的规则放在自定义链中，然后把自定义的链绑定到标准的链路中，因此此处DOCKER 是自定义的链。那我们现在就来看一下DOCKER这个自定义链上的规则。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ iptables -t nat -nvL DOCKER
</span></span><span style="display:flex;"><span>Chain DOCKER <span style="color:#f92672">(</span><span style="color:#ae81ff">2</span> references<span style="color:#f92672">)</span>                                                                                                
</span></span><span style="display:flex;"><span> pkts bytes target     prot opt in     out     source               destination                                            
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0                                             
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:8088 to:172.17.0.2:80 
</span></span></code></pre></div><p>此条规则就是对主机收到的目的端口为8088的tcp流量进行DNAT转换，将流量发往172.17.0.2:80，172.17.0.2地址是不是就是我们上面创建的Docker容器的ip地址，流量走到网桥上了，后面就走网桥的转发就ok了。 所以，外界只需访问172.21.51.143:8088就可以访问到容器中的服务了。</p>
<p>数据包在出口方向走POSTROUTING链，我们查看一下规则：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ iptables -t nat -nvL POSTROUTING
</span></span><span style="display:flex;"><span>Chain POSTROUTING <span style="color:#f92672">(</span>policy ACCEPT <span style="color:#ae81ff">1099</span> packets, <span style="color:#ae81ff">67268</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span> pkts bytes target     prot opt in     out     source               destination
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">86</span>  <span style="color:#ae81ff">5438</span> MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> MASQUERADE  tcp  --  *      *       172.17.0.4           172.17.0.4           tcp dpt:80
</span></span></code></pre></div><p>大家注意MASQUERADE这个动作是什么意思，其实是一种更灵活的SNAT，把源地址转换成主机的出口ip地址，那解释一下这条规则的意思:</p>
<p>这条规则会将源地址为172.17.0.0/16的包（也就是从Docker容器产生的包），并且不是从docker0网卡发出的，进行源地址转换，转换成主机网卡的地址。大概的过程就是ACK的包在容器里面发出来，会路由到网桥docker0，网桥根据宿主机的路由规则会转给宿主机网卡eth0，这时候包就从docker0网卡转到eth0网卡了，并从eth0网卡发出去，这时候这条规则就会生效了，把源地址换成了eth0的ip地址。</p>
<blockquote>
<p>注意一下，刚才这个过程涉及到了网卡间包的传递，那一定要打开主机的ip_forward转发服务，要不然包转不了，服务肯定访问不到。</p>
</blockquote>
<h6 id="抓包演示">抓包演示<a hidden class="anchor" aria-hidden="true" href="#抓包演示">#</a></h6>
<p>我们先想一下，我们要抓哪个网卡的包</p>
<ul>
<li>
<p>首先访问宿主机的8088端口，我们抓一下宿主机的eth0</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ tcpdump -i eth0 port <span style="color:#ae81ff">8088</span> -w host.cap
</span></span></code></pre></div></li>
<li>
<p>然后最终包会流入容器内，那我们抓一下容器内的eth0网卡</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 容器内安装一下tcpdump</span>
</span></span><span style="display:flex;"><span>$ sed -i <span style="color:#e6db74">&#39;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&#39;</span> /etc/apk/repositories
</span></span><span style="display:flex;"><span>$ apk add tcpdump
</span></span><span style="display:flex;"><span>$ tcpdump -i eth0 port <span style="color:#ae81ff">80</span> -w container.cap
</span></span></code></pre></div></li>
</ul>
<p>到另一台机器访问一下，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ curl 172.21.51.143:8088/
</span></span></code></pre></div><p>停止抓包，拷贝容器内的包到宿主机</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker cp test:/root/container.cap /root/
</span></span></code></pre></div><p>把抓到的内容拷贝到本地，使用wireshark进行分析。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ scp root@172.21.51.143:/root/*.cap /d/packages
</span></span></code></pre></div><p>（wireshark合并包进行分析）</p>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/docker-dnat.jpeg" alt=""  />
</p>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/docker-snat.jpeg" alt=""  />
</p>
<p>进到容器内的包做DNAT，出去的包做SNAT，这样对外面来讲，根本就不知道机器内部是谁提供服务，其实这就和一个内网多个机器公用一个外网IP地址上网的效果是一样的，那这也属于NAT功能的一个常见的应用场景。</p>
<h5 id="host模式">Host模式<a hidden class="anchor" aria-hidden="true" href="#host模式">#</a></h5>
<p>容器内部不会创建网络空间，共享宿主机的网络空间。比如直接通过host模式创建mysql容器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker run --net host -d --name mysql -e MYSQL_ROOT_PASSWORD<span style="color:#f92672">=</span><span style="color:#ae81ff">123456</span> mysql:5.7
</span></span></code></pre></div><p>容器启动后，会默认监听3306端口，由于网络模式是host，因为可以直接通过宿主机的3306端口进行访问服务，效果等同于在宿主机中直接启动mysqld的进程。</p>
<h5 id="conatiner模式">Conatiner模式<a hidden class="anchor" aria-hidden="true" href="#conatiner模式">#</a></h5>
<p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p>
<p><img loading="lazy" src="/images/%e8%b5%b0%e8%bf%9bDocker%e7%9a%84%e4%b8%96%e7%95%8c/docker-network-container.jpeg" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">## 启动测试容器，共享mysql的网络空间</span>
</span></span><span style="display:flex;"><span>$ docker run -ti --rm --net<span style="color:#f92672">=</span>container:mysql busybox sh
</span></span><span style="display:flex;"><span>/ <span style="color:#75715e"># ip a</span>
</span></span><span style="display:flex;"><span>/ <span style="color:#75715e"># netstat -tlp|grep 3306</span>
</span></span><span style="display:flex;"><span>/ <span style="color:#75715e"># telnet localhost 3306</span>
</span></span></code></pre></div><p>在一些特殊的场景中非常有用，例如，kubernetes的pod，kubernetes为pod创建一个基础设施容器，同一pod下的其他容器都以container模式共享这个基础设施容器的网络命名空间，相互之间以localhost访问，构成一个统一的整体。</p>
<h5 id="none模式">None模式<a hidden class="anchor" aria-hidden="true" href="#none模式">#</a></h5>
<p>只会创建对应的网络空间，不会配置网络堆栈（网卡、路由等）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 创建none的容器</span>
</span></span><span style="display:flex;"><span>$ docker run -it  --name<span style="color:#f92672">=</span>network-none --net<span style="color:#f92672">=</span>none nginx:alpine sh
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ifconfig</span>
</span></span></code></pre></div><p>在宿主机中操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 创建虚拟网卡对</span>
</span></span><span style="display:flex;"><span>$ ip link add A type veth peer name B
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A端插入到docker0网桥</span>
</span></span><span style="display:flex;"><span>$ brctl addif docker0 A
</span></span><span style="display:flex;"><span>$ ip link set A up
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># B端插入到network-none容器中，需要借助ip netns,因此需要显示的创建命名network namespace</span>
</span></span><span style="display:flex;"><span>$ PID<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>docker inspect -f <span style="color:#e6db74">&#39;{{.State.Pid}}&#39;</span> network-none<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>$ mkdir -p /var/run/netns
</span></span><span style="display:flex;"><span>$ ln -s /proc/$PID/ns/net /var/run/netns/$PID
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># B端放到容器的命名空间</span>
</span></span><span style="display:flex;"><span>$ ip link set B netns $PID
</span></span><span style="display:flex;"><span>$ ip netns exec $PID ip link set dev B name eth0  <span style="color:#75715e"># 修改设备名称为eth0，和docker默认行为一致</span>
</span></span><span style="display:flex;"><span>$ ip netns exec $PID ip link set eth0 up
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 设置ip</span>
</span></span><span style="display:flex;"><span>$ ip netns exec $PID ip addr add 172.17.0.100/16 dev eth0
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 添加默认路由，指定给docker0网桥</span>
</span></span><span style="display:flex;"><span>$ ip netns exec $PID ip route add default via 172.17.0.1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 测试容器间通信</span>
</span></span></code></pre></div><p>前置知识：</p>
<ul>
<li>ip netns 命令用来管理 network namespace。它可以创建命名的 network namespace，然后通过名字来引用 network namespace</li>
<li>network namespace 在逻辑上是网络堆栈的一个副本，它有自己的路由、防火墙规则和网络设备。 默认情况下，子进程继承其父进程的 network namespace。也就是说，如果不显式创建新的 network namespace，所有进程都从 init 进程继承相同的默认 network namespace。</li>
<li>根据约定，命名的 network namespace 是可以打开的 <strong>/var/run/netns/</strong> 目录下的一个对象。比如有一个名称为 net1 的 network namespace 对象，则可以由打开 /var/run/netns/net1 对象产生的文件描述符引用 network namespace net1。通过引用该文件描述符，可以修改进程的 network namespace。</li>
</ul>
<h4 id="实用技巧">实用技巧<a hidden class="anchor" aria-hidden="true" href="#实用技巧">#</a></h4>
<ol>
<li>
<p>清理主机上所有退出的容器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ docker rm  <span style="color:#66d9ef">$(</span>docker ps -aq<span style="color:#66d9ef">)</span>
</span></span></code></pre></div></li>
<li>
<p>调试或者排查容器启动错误</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">## 若有时遇到容器启动失败的情况，可以先使用相同的镜像启动一个临时容器，先进入容器</span>
</span></span><span style="display:flex;"><span>$ docker run --rm -ti &lt;image_id&gt; sh
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 进入容器后，手动执行该容器对应的ENTRYPOINT或者CMD命令，这样即使出错，容器也不会退出，因为bash作为1号进程，我们只要不退出容器，该容器就不会自动退出</span>
</span></span></code></pre></div></li>
</ol>
<h4 id="本章小结">本章小结<a hidden class="anchor" aria-hidden="true" href="#本章小结">#</a></h4>
<ol>
<li>为了解决软件交付过程中的环境依赖，同时提供一种更加轻量的虚拟化技术，Docker出现了。</li>
<li>2013年诞生，15年开始迅速发展，从17.03月开始，使用时间日期管理版本，稳定版以每季度为准。</li>
<li>Docker是一种CS架构的软件产品，可以把代码及依赖打包成镜像，作为交付介质，并且把镜像启动成为容器，提供容器生命周期的管理。</li>
<li>使用yum部署docker，启动后通过操作docker这个命令行，自动调用docker daemon完成容器相关操作。</li>
<li>常用操作，围绕<code>镜像|容器|仓库</code>三大核心要素
<ul>
<li>systemctl  start|stop|restart docker</li>
<li>docker build | pull  -&gt; docker tag -&gt; docker push</li>
<li>docker run &ndash;name my-demo  -d  -p 8080:80 -v  /opt/data:/data  demo:v20200327 ping xx.com</li>
<li>docker cp  /path/a.txt  mycontainer:/opt</li>
<li>docker exec -ti  mycontainer  /bin/sh</li>
<li>docker logs -f &ndash;tail=100 mycontainer</li>
</ul>
</li>
<li>通过dockerfile构建业务镜像，先使用基础镜像，然后通过一系列的指令把我们的业务应用所需要的运行环境和依赖都打包到镜像中，然后通过CMD或者ENTRYPOINT指令把镜像启动时的入口制定好，完成封装即可。有点类似于，先找来一个集装箱模板(基础镜像)，然后把项目依赖的服务都扔到集装箱中，然后设置好服务的启动入口，关闭箱门，即完成了业务镜像的制作。</li>
<li>容器的实现依赖于内核模块提供的namespace和control-group的功能，通过namespace创建一块虚拟空间，空间内实现了各类资源(进程、网络、文件系统)的隔离，提供control-group实现了对隔离的空间的资源使用的限制。</li>
<li>docker镜像使用分层的方式进行存储，根据主机的存储驱动的不同，实现方式会不同，kernel在3.10.0-514以上自动支持overlay2 存储驱动，也是目前Docker推荐的方式。</li>
<li>得益于分层存储的模式，多个容器可以通过copy-on-write的策略，在镜像的最上层加一个可写层，同时利用存储驱动的UnionFS的能力，实现一个镜像快速启动多个容器的场景。</li>
<li>docker的网络模式分为4种，最常用的为bridge和host模式。bridge模式通过docker0网桥，启动容器的时候通过创建一对虚拟网卡，将容器连接在桥上，同时维护了虚拟网卡与网桥端口的关系，实现容器间的通信。容器与宿主机之间的通信通过iptables端口映射的方式，docker利用iptables的PREROUTING和POSTROUTING的nat功能，实现了SNAT与DNAT，使得容器内部的服务被完美的保护起来。</li>
<li>本章重点内容是docker的核心要素及基础的操作，实现原理以及docker的网络模式为选修包，目的为了帮助有docker基础及经验的同学更好的进一步理解docker。</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://iblog.zone/tags/docker/">docker</a></li>
      <li><a href="https://iblog.zone/tags/k8s/">k8s</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://iblog.zone/archives/etcd-v3%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/">
    <span class="title">« 上一页</span>
    <br>
    <span>Etcd v3备份与恢复</span>
  </a>
  <a class="next" href="https://iblog.zone/archives/nginx-php-fpm%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/">
    <span class="title">下一页 »</span>
    <br>
    <span>nginx php-fpm安装配置</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://iblog.zone">ylw&#39;s blog</a></span>
    <span>
	& <a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2021039488号</a>
    </span>

    总访客：<span id="busuanzi_value_site_uv"></span>
    总浏览量：<span id="busuanzi_value_site_pv"></span>
    页面访问量：<span id="busuanzi_value_page_pv"></span>

</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '复制';

        function copyingDone() {
            copybutton.innerText = '已复制！';
            setTimeout(() => {
                copybutton.innerText = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
