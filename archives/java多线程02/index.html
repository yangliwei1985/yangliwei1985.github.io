<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Java多线程02 | ylw&#39;s blog</title>
<meta name="keywords" content="多线程" />
<meta name="description" content="1.线程池 1.1 线程状态介绍 当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程
状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：
public class Thread {   public enum State {   /* 新建 */  NEW ,   /* 可运行状态 */  RUNNABLE ,   /* 阻塞状态 */  BLOCKED ,   /* 无限等待状态 */  WAITING ,   /* 计时等待 */  TIMED_WAITING ,   /* 终止 */  TERMINATED;  	}   // 获取当前线程的状态  public State getState() {  return jdk.">
<meta name="author" content="">
<link rel="canonical" href="https://iblog.zone/archives/java%E5%A4%9A%E7%BA%BF%E7%A8%8B02/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7af5e4f048c756d5896f15b3f7cd7ee898ea1b3b101fcb40abfb5216ca230ecf.css" integrity="sha256-evXk8EjHVtWJbxWz981&#43;6JjqGzsQH8tAq/tSFsojDs8=" rel="preload stylesheet" as="style">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://iblog.zone/images/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://iblog.zone/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="https://iblog.zone/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="https://iblog.zone/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="https://iblog.zone/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel='stylesheet' href='//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>

<meta property="og:title" content="Java多线程02" />
<meta property="og:description" content="1.线程池 1.1 线程状态介绍 当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程
状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：
public class Thread {   public enum State {   /* 新建 */  NEW ,   /* 可运行状态 */  RUNNABLE ,   /* 阻塞状态 */  BLOCKED ,   /* 无限等待状态 */  WAITING ,   /* 计时等待 */  TIMED_WAITING ,   /* 终止 */  TERMINATED;  	}   // 获取当前线程的状态  public State getState() {  return jdk." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://iblog.zone/archives/java%E5%A4%9A%E7%BA%BF%E7%A8%8B02/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-15T17:30:37&#43;00:00" />
<meta property="article:modified_time" content="2022-03-15T17:30:37&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java多线程02"/>
<meta name="twitter:description" content="1.线程池 1.1 线程状态介绍 当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程
状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：
public class Thread {   public enum State {   /* 新建 */  NEW ,   /* 可运行状态 */  RUNNABLE ,   /* 阻塞状态 */  BLOCKED ,   /* 无限等待状态 */  WAITING ,   /* 计时等待 */  TIMED_WAITING ,   /* 终止 */  TERMINATED;  	}   // 获取当前线程的状态  public State getState() {  return jdk."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://iblog.zone/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Java多线程02",
      "item": "https://iblog.zone/archives/java%E5%A4%9A%E7%BA%BF%E7%A8%8B02/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java多线程02",
  "name": "Java多线程02",
  "description": "1.线程池 1.1 线程状态介绍 当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程\n状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：\npublic class Thread {   public enum State {   /* 新建 */  NEW ,   /* 可运行状态 */  RUNNABLE ,   /* 阻塞状态 */  BLOCKED ,   /* 无限等待状态 */  WAITING ,   /* 计时等待 */  TIMED_WAITING ,   /* 终止 */  TERMINATED;  \t}   // 获取当前线程的状态  public State getState() {  return jdk.",
  "keywords": [
    "多线程"
  ],
  "articleBody": "1.线程池 1.1 线程状态介绍 当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程\n状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：\npublic class Thread {   public enum State {   /* 新建 */  NEW ,   /* 可运行状态 */  RUNNABLE ,   /* 阻塞状态 */  BLOCKED ,   /* 无限等待状态 */  WAITING ,   /* 计时等待 */  TIMED_WAITING ,   /* 终止 */  TERMINATED;  \t}   // 获取当前线程的状态  public State getState() {  return jdk.internal.misc.VM.toThreadState(threadStatus);  }  } 通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下\n   线程状态 具体含义     NEW 一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread()只有线程象，没有线程特征。   RUNNABLE 当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。   BLOCKED 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。   WAITING 一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。   TIMED_WAITING 一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。   TERMINATED 一个完全运行完成的线程的状态。也称之为终止状态、结束状态    各个状态的转换，如下图所示：\n1.2 线程的状态-练习1 目的 : 本案例主要演示TIME_WAITING的状态转换。\n**需求：**编写一段代码，依次显示一个线程的这些状态：NEW - RUNNABLE - TIME_WAITING - RUNNABLE - TERMINATED\n为了简化我们的开发，本次我们使用匿名内部类结合lambda表达式的方式使用多线程。\n代码实现\npublic class ThreadStateDemo01 {   public static void main(String[] args) throws InterruptedException {   //定义一个内部线程  Thread thread = new Thread(() - {  System.out.println(\"2.执行thread.start()之后，线程的状态：\" + Thread.currentThread().getState());  try {  //休眠100毫秒  Thread.sleep(100);  } catch (InterruptedException e) {  e.printStackTrace();  }  System.out.println(\"4.执行Thread.sleep(long)完成之后，线程的状态：\" + Thread.currentThread().getState());  });   //获取start()之前的状态  System.out.println(\"1.通过new初始化一个线程，但是还没有start()之前，线程的状态：\" + thread.getState());   //启动线程  thread.start();   //休眠50毫秒  Thread.sleep(50);   //因为thread1需要休眠100毫秒，所以在第50毫秒，thread处于sleep状态  System.out.println(\"3.执行Thread.sleep(long)时，线程的状态：\" + thread.getState());   //thread1和main线程主动休眠150毫秒，所以在第150毫秒,thread早已执行完毕  Thread.sleep(100);   System.out.println(\"5.线程执行完毕之后，线程的状态：\" + thread.getState() + \"\\n\");   }  } 控制台输出\n1.通过new初始化一个线程，但是还没有start()之前，线程的状态：NEW 2.执行thread.start()之后，线程的状态：RUNNABLE 3.执行Thread.sleep(long)时，线程的状态：TIMED_WAITING 4.执行Thread.sleep(long)完成之后，线程的状态：RUNNABLE 5.线程执行完毕之后，线程的状态：TERMINATED  1.3 线程的状态-练习2 目的 : 本案例主要演示WAITING的状态转换。\n**需求 ：**编写一段代码，依次显示一个线程的这些状态：NEW - RUNNABLE - WAITING - RUNNABLE - TERMINATED\n代码实现 :\npublic class ThreadStateDemo02 {   public static void main(String[] args) throws InterruptedException {   //定义一个对象，用来加锁和解锁  Object obj = new Object();   //定义一个内部线程  Thread thread1 = new Thread(() - {  System.out.println(\"2.执行thread.start()之后，线程的状态：\" + Thread.currentThread().getState());  synchronized (obj) {  try {   //thread1需要休眠100毫秒  Thread.sleep(100);   //thread1100毫秒之后，通过wait()方法释放obj对象是锁  obj.wait();   } catch (InterruptedException e) {  e.printStackTrace();  }  }  System.out.println(\"4.被object.notify()方法唤醒之后，线程的状态：\" + Thread.currentThread().getState());  });   //获取start()之前的状态  System.out.println(\"1.通过new初始化一个线程，但是还没有start()之前，线程的状态：\" + thread1.getState());   //启动线程  thread1.start();   //main线程休眠150毫秒  Thread.sleep(150);   //因为thread1在第100毫秒进入wait等待状态，所以第150秒肯定可以获取其状态  System.out.println(\"3.执行object.wait()时，线程的状态：\" + thread1.getState());   //声明另一个线程进行解锁  new Thread(() - {  synchronized (obj) {  //唤醒等待的线程  obj.notify();  }  }).start();   //main线程休眠10毫秒等待thread1线程能够苏醒  Thread.sleep(10);   //获取thread1运行结束之后的状态  System.out.println(\"5.线程执行完毕之后，线程的状态：\" + thread1.getState() + \"\\n\");   }  } 控制台输出结果\n1.通过new初始化一个线程，但是还没有start()之前，线程的状态：NEW 2.执行thread.start()之后，线程的状态：RUNNABLE 3.执行object.wait()时，线程的状态：WAITING 4.被object.notify()方法唤醒之后，线程的状态：RUNNABLE 5.线程执行完毕之后，线程的状态：TERMINATED  1.4 线程的状态-练习3 目的 : 本案例主要演示BLOCKED的状态转换。\n**需求 ：**编写一段代码，依次显示一个线程的这些状态：NEW - RUNNABLE - BLOCKED - RUNNABLE - TERMINATED\npublic class ThreadStateDemo03 {   public static void main(String[] args) throws InterruptedException {   //定义一个对象，用来加锁和解锁  Object obj2 = new Object();   //定义一个线程，先抢占了obj2对象的锁  new Thread(() - {  synchronized (obj2) {  try {  Thread.sleep(100); //第一个线程要持有锁100毫秒  obj2.wait(); //然后通过wait()方法进行等待状态，并释放obj2的对象锁  } catch (InterruptedException e) {  e.printStackTrace();  }  }  }).start();   //定义目标线程，获取等待获取obj2的锁  Thread thread = new Thread(() - {  System.out.println(\"2.执行thread.start()之后，线程的状态：\" + Thread.currentThread().getState());  synchronized (obj2) {  try {  Thread.sleep(100); //thread3要持有对象锁100毫秒  obj2.notify(); //然后通过notify()方法唤醒所有在ojb2上等待的线程继续执行后续操作  } catch (InterruptedException e) {  e.printStackTrace();  }  }  System.out.println(\"4.阻塞结束后，线程的状态：\" + Thread.currentThread().getState());  });   //获取start()之前的状态  System.out.println(\"1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：\" + thread.getState());   //启动线程  thread.start();   //先等100毫秒  Thread.sleep(50);   //第一个线程释放锁至少需要100毫秒，所以在第50毫秒时，thread正在因等待obj的对象锁而阻塞  System.out.println(\"3.因为等待锁而阻塞时，线程的状态：\" + thread.getState());   //再等300毫秒  Thread.sleep(300);   //两个线程的执行时间加上之前等待的50毫秒总共是250毫秒，所以第300毫秒，所有的线程都已经执行完毕  System.out.println(\"5.线程执行完毕之后，线程的状态：\" + thread.getState());   }  } 控制台输出结果\n1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：NEW 2.执行thread.start()之后，线程的状态：RUNNABLE 3.因为等待锁而阻塞时，线程的状态：BLOCKED 4.阻塞结束后，线程的状态：RUNNABLE 5.线程执行完毕之后，线程的状态：TERMINATED 1.5 线程池-基本原理 概述 :\n​\t提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。\n线程池存在的意义：\n​\t系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系\n​\t统资源的消耗，这样就有点\"舍本逐末\"了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就\n​\t会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。\n线程池的设计思路 :\n 准备一个任务容器 一次性启动多个(2个)消费者线程 刚开始任务容器是空的，所以线程都在wait 直到一个外部线程向这个任务容器中扔了一个\"任务\"，就会有一个消费者线程被唤醒 这个消费者线程取出\"任务\"，并且执行这个任务，执行完毕后，继续等待下一次任务的到来  1.6 线程池-Executors默认线程池 概述 : JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。\n我们可以使用Executors中所提供的静态方法来创建线程池\n​\tstatic ExecutorService newCachedThreadPool() 创建一个默认的线程池 ​\tstatic newFixedThreadPool(int nThreads)\t创建一个指定最多线程数量的线程池\n代码实现 :\npackage com.itheima.mythreadpool;   //static ExecutorService newCachedThreadPool() 创建一个默认的线程池 //static newFixedThreadPool(int nThreads)\t创建一个指定最多线程数量的线程池  import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors;  public class MyThreadPoolDemo {  public static void main(String[] args) throws InterruptedException {   //1,创建一个默认的线程池对象.池子中默认是空的.默认最多可以容纳int类型的最大值.  ExecutorService executorService = Executors.newCachedThreadPool();  //Executors --- 可以帮助我们创建线程池对象  //ExecutorService --- 可以帮助我们控制线程池   executorService.submit(()-{  System.out.println(Thread.currentThread().getName() + \"在执行了\");  });   //Thread.sleep(2000);   executorService.submit(()-{  System.out.println(Thread.currentThread().getName() + \"在执行了\");  });   executorService.shutdown();  } } 1.7 线程池-Executors创建指定上限的线程池 使用Executors中所提供的静态方法来创建线程池\n​\tstatic ExecutorService newFixedThreadPool(int nThreads) : 创建一个指定最多线程数量的线程池\n代码实现 :\npackage com.itheima.mythreadpool;  //static ExecutorService newFixedThreadPool(int nThreads) //创建一个指定最多线程数量的线程池  import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.ThreadPoolExecutor;  public class MyThreadPoolDemo2 {  public static void main(String[] args) {  //参数不是初始值而是最大值  ExecutorService executorService = Executors.newFixedThreadPool(10);   ThreadPoolExecutor pool = (ThreadPoolExecutor) executorService;  System.out.println(pool.getPoolSize());//0   executorService.submit(()-{  System.out.println(Thread.currentThread().getName() + \"在执行了\");  });   executorService.submit(()-{  System.out.println(Thread.currentThread().getName() + \"在执行了\");  });   System.out.println(pool.getPoolSize());//2 // executorService.shutdown();  } } 1.8 线程池-ThreadPoolExecutor 创建线程池对象 :\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略);\n代码实现 :\npackage com.itheima.mythreadpool;  import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.Executors; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit;  public class MyThreadPoolDemo3 { // 参数一：核心线程数量 // 参数二：最大线程数 // 参数三：空闲线程最大存活时间 // 参数四：时间单位 // 参数五：任务队列 // 参数六：创建线程工厂 // 参数七：任务的拒绝策略  public static void main(String[] args) {  ThreadPoolExecutor pool = new ThreadPoolExecutor(2,5,2,TimeUnit.SECONDS,new ArrayBlockingQueue(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());  pool.submit(new MyRunnable());  pool.submit(new MyRunnable());   pool.shutdown();  } } 1.9 线程池-参数详解 public ThreadPoolExecutor(int corePoolSize,  int maximumPoolSize,  long keepAliveTime,  TimeUnit unit,  BlockingQueueRunnable workQueue,  ThreadFactory threadFactory,  RejectedExecutionHandler handler)  corePoolSize： 核心线程的最大值，不能小于0 maximumPoolSize：最大线程数，不能小于等于0，maximumPoolSize = corePoolSize keepAliveTime： 空闲线程最大存活时间,不能小于0 unit： 时间单位 workQueue： 任务队列，不能为null threadFactory： 创建线程工厂,不能为null handler： 任务的拒绝策略,不能为null 1.10 线程池-非默认任务拒绝策略 RejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。\nThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出RejectedExecutionException异常。是默认的策略。 ThreadPoolExecutor.DiscardPolicy： 丢弃任务，但是不抛出异常 这是不推荐的做法。 ThreadPoolExecutor.DiscardOldestPolicy： 抛弃队列中等待最久的任务 然后把当前任务加入队列中。 ThreadPoolExecutor.CallerRunsPolicy: 调用任务的run()方法绕过线程池直接执行。 注：明确线程池对多可执行的任务数 = 队列容量 + 最大线程数\n案例演示1：演示ThreadPoolExecutor.AbortPolicy任务处理策略\npublic class ThreadPoolExecutorDemo01 {   public static void main(String[] args) {   /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */  ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,  new ArrayBlockingQueue(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ;   // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常  for(int x = 0 ; x  5 ; x++) {  threadPoolExecutor.submit(() - {  System.out.println(Thread.currentThread().getName() + \"---- 执行了任务\");  });  }  } } 控制台输出结果\npool-1-thread-1---- 执行了任务 pool-1-thread-3---- 执行了任务 pool-1-thread-2---- 执行了任务 pool-1-thread-3---- 执行了任务 控制台报错，仅仅执行了4个任务，有一个任务被丢弃了\n案例演示2：演示ThreadPoolExecutor.DiscardPolicy任务处理策略\npublic class ThreadPoolExecutorDemo02 {  public static void main(String[] args) {  /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */  ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,  new ArrayBlockingQueue(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardPolicy()) ;   // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错  for(int x = 0 ; x  5 ; x++) {  threadPoolExecutor.submit(() - {  System.out.println(Thread.currentThread().getName() + \"---- 执行了任务\");  });  }  } } 控制台输出结果\npool-1-thread-1---- 执行了任务 pool-1-thread-1---- 执行了任务 pool-1-thread-3---- 执行了任务 pool-1-thread-2---- 执行了任务 控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了\n案例演示3：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略\npublic class ThreadPoolExecutorDemo02 {  public static void main(String[] args) {  /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */  ThreadPoolExecutor threadPoolExecutor;  threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,  new ArrayBlockingQueue(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardOldestPolicy());  // 提交5个任务  for(int x = 0 ; x  5 ; x++) {  // 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰  final int y = x ;  threadPoolExecutor.submit(() - {  System.out.println(Thread.currentThread().getName() + \"---- 执行了任务\" + y);  });  }  } } 控制台输出结果\npool-1-thread-2---- 执行了任务2 pool-1-thread-1---- 执行了任务0 pool-1-thread-3---- 执行了任务3 pool-1-thread-1---- 执行了任务4 由于任务1在线程池中等待时间最长，因此任务1被丢弃。\n案例演示4：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略\npublic class ThreadPoolExecutorDemo04 {  public static void main(String[] args) {   /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */  ThreadPoolExecutor threadPoolExecutor;  threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,  new ArrayBlockingQueue(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.CallerRunsPolicy());   // 提交5个任务  for(int x = 0 ; x  5 ; x++) {  threadPoolExecutor.submit(() - {  System.out.println(Thread.currentThread().getName() + \"---- 执行了任务\");  });  }  } } 控制台输出结果\npool-1-thread-1---- 执行了任务 pool-1-thread-3---- 执行了任务 pool-1-thread-2---- 执行了任务 pool-1-thread-1---- 执行了任务 main---- 执行了任务 通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。\n2. 原子性 2.1 volatile-问题 代码分析 :\npackage com.itheima.myvolatile;  public class Demo {  public static void main(String[] args) {  MyThread1 t1 = new MyThread1();  t1.setName(\"小路同学\");  t1.start();   MyThread2 t2 = new MyThread2();  t2.setName(\"小皮同学\");  t2.start();  } } package com.itheima.myvolatile;  public class Money {  public static int money = 100000; } package com.itheima.myvolatile;  public class MyThread1 extends Thread {  @Override  public void run() {  while(Money.money == 100000){   }   System.out.println(\"结婚基金已经不是十万了\");  } } package com.itheima.myvolatile;  public class MyThread2 extends Thread {  @Override  public void run() {  try {  Thread.sleep(10);  } catch (InterruptedException e) {  e.printStackTrace();  }   Money.money = 90000;  } } 程序问题 : 女孩虽然知道结婚基金是十万，但是当基金的余额发生变化的时候，女孩无法知道最新的余额。\n2.2 volatile解决 以上案例出现的问题 :\n​\t当A线程修改了共享数据时，B线程没有及时获取到最新的值，如果还在使用原先的值，就会出现问题\n​\t1，堆内存是唯一的，每一个线程都有自己的线程栈。\n​\t2 ，每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中。\n​\t3 ，在线程中，每一次使用是从变量的副本中获取的。\nVolatile关键字 : 强制线程每次在使用的时候，都会看一下共享区域最新的值\n代码实现 : 使用volatile关键字解决\npackage com.itheima.myvolatile;  public class Demo {  public static void main(String[] args) {  MyThread1 t1 = new MyThread1();  t1.setName(\"小路同学\");  t1.start();   MyThread2 t2 = new MyThread2();  t2.setName(\"小皮同学\");  t2.start();  } } package com.itheima.myvolatile;  public class Money {  public static volatile int money = 100000; } package com.itheima.myvolatile;  public class MyThread1 extends Thread {  @Override  public void run() {  while(Money.money == 100000){   }   System.out.println(\"结婚基金已经不是十万了\");  } } package com.itheima.myvolatile;  public class MyThread2 extends Thread {  @Override  public void run() {  try {  Thread.sleep(10);  } catch (InterruptedException e) {  e.printStackTrace();  }   Money.money = 90000;  } } 2.3 synchronized解决 synchronized解决 :\n​\t1 ，线程获得锁\n​\t2 ，清空变量副本\n​\t3 ，拷贝共享变量最新的值到变量副本中\n​\t4 ，执行代码\n​\t5 ，将修改后变量副本中的值赋值给共享数据\n​\t6 ，释放锁\n代码实现 :\npackage com.itheima.myvolatile2;  public class Demo {  public static void main(String[] args) {  MyThread1 t1 = new MyThread1();  t1.setName(\"小路同学\");  t1.start();   MyThread2 t2 = new MyThread2();  t2.setName(\"小皮同学\");  t2.start();  } } package com.itheima.myvolatile2;  public class Money {  public static Object lock = new Object();  public static volatile int money = 100000; } package com.itheima.myvolatile2;  public class MyThread1 extends Thread {  @Override  public void run() {  while(true){  synchronized (Money.lock){  if(Money.money != 100000){  System.out.println(\"结婚基金已经不是十万了\");  break;  }  }  }  } } package com.itheima.myvolatile2;  public class MyThread2 extends Thread {  @Override  public void run() {  synchronized (Money.lock) {  try {  Thread.sleep(10);  } catch (InterruptedException e) {  e.printStackTrace();  }   Money.money = 90000;  }  } } 2.4 原子性 概述 : 所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。\n代码实现 :\npackage com.itheima.threadatom;  public class AtomDemo {  public static void main(String[] args) {  MyAtomThread atom = new MyAtomThread();   for (int i = 0; i  100; i++) {  new Thread(atom).start();  }  } } class MyAtomThread implements Runnable {  private volatile int count = 0; //送冰淇淋的数量   @Override  public void run() {  for (int i = 0; i  100; i++) {  //1,从共享数据中读取数据到本线程栈中.  //2,修改本线程栈中变量副本的值  //3,会把本线程栈中变量副本的值赋值给共享数据.  count++;  System.out.println(\"已经送了\" + count + \"个冰淇淋\");  }  } } 代码总结 : count++ 不是一个原子性操作, 他在执行的过程中,有可能被其他线程打断\n2.5 volatile关键字不能保证原子性 解决方案 : 我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。\npackage com.itheima.threadatom2;  public class AtomDemo {  public static void main(String[] args) {  MyAtomThread atom = new MyAtomThread();   for (int i = 0; i  100; i++) {  new Thread(atom).start();  }  } } class MyAtomThread implements Runnable {  private volatile int count = 0; //送冰淇淋的数量  private Object lock = new Object();   @Override  public void run() {  for (int i = 0; i  100; i++) {  //1,从共享数据中读取数据到本线程栈中.  //2,修改本线程栈中变量副本的值  //3,会把本线程栈中变量副本的值赋值给共享数据.  synchronized (lock) {  count++;  System.out.println(\"已经送了\" + count + \"个冰淇淋\");  }  }  } } 2.6 原子性_AtomicInteger 概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因为变\n量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。本次我们只讲解\n使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类：\nAtomicBoolean： 原子更新布尔类型\nAtomicInteger： 原子更新整型\nAtomicLong：\t原子更新长整型\n以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下：\npublic AtomicInteger()：\t初始化一个默认值为0的原子型Integer public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer  int get(): 获取值 int getAndIncrement(): 以原子方式将当前值加1，注意，这里返回的是自增前的值。 int incrementAndGet(): 以原子方式将当前值加1，注意，这里返回的是自增后的值。 int addAndGet(int data):\t以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。 int getAndSet(int value): 以原子方式设置为newValue的值，并返回旧值。 代码实现 :\npackage com.itheima.threadatom3;  import java.util.concurrent.atomic.AtomicInteger;  public class MyAtomIntergerDemo1 { // public AtomicInteger()：\t初始化一个默认值为0的原子型Integer // public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer  public static void main(String[] args) {  AtomicInteger ac = new AtomicInteger();  System.out.println(ac);   AtomicInteger ac2 = new AtomicInteger(10);  System.out.println(ac2);  }  } package com.itheima.threadatom3;  import java.lang.reflect.Field; import java.util.concurrent.atomic.AtomicInteger;  public class MyAtomIntergerDemo2 { // int get(): 获取值 // int getAndIncrement(): 以原子方式将当前值加1，注意，这里返回的是自增前的值。 // int incrementAndGet(): 以原子方式将当前值加1，注意，这里返回的是自增后的值。 // int addAndGet(int data):\t以原子方式将参数与对象中的值相加，并返回结果。 // int getAndSet(int value): 以原子方式设置为newValue的值，并返回旧值。  public static void main(String[] args) { // AtomicInteger ac1 = new AtomicInteger(10); // System.out.println(ac1.get());  // AtomicInteger ac2 = new AtomicInteger(10); // int andIncrement = ac2.getAndIncrement(); // System.out.println(andIncrement); // System.out.println(ac2.get());  // AtomicInteger ac3 = new AtomicInteger(10); // int i = ac3.incrementAndGet(); // System.out.println(i);//自增后的值 // System.out.println(ac3.get());  // AtomicInteger ac4 = new AtomicInteger(10); // int i = ac4.addAndGet(20); // System.out.println(i); // System.out.println(ac4.get());   AtomicInteger ac5 = new AtomicInteger(100);  int andSet = ac5.getAndSet(20);  System.out.println(andSet);  System.out.println(ac5.get());  } } 2.7 AtomicInteger-内存解析 AtomicInteger原理 : 自旋锁 + CAS 算法\nCAS算法：\n​\t有3个操作数（内存值V， 旧的预期值A，要修改的值B）\n​\t当旧的预期值A == 内存值 此时修改成功，将V改为B\n​\t当旧的预期值A！=内存值 此时修改失败，不做任何操作\n​\t并重新获取现在的最新值（这个重新获取的动作就是自旋）\n2.8 AtomicInteger-源码解析 代码实现 :\npackage com.itheima.threadatom4;  public class AtomDemo {  public static void main(String[] args) {  MyAtomThread atom = new MyAtomThread();   for (int i = 0; i  100; i++) {  new Thread(atom).start();  }  } } package com.itheima.threadatom4;  import java.util.concurrent.atomic.AtomicInteger;  public class MyAtomThread implements Runnable {  //private volatile int count = 0; //送冰淇淋的数量  //private Object lock = new Object();  AtomicInteger ac = new AtomicInteger(0);   @Override  public void run() {  for (int i = 0; i  100; i++) {  //1,从共享数据中读取数据到本线程栈中.  //2,修改本线程栈中变量副本的值  //3,会把本线程栈中变量副本的值赋值给共享数据.  //synchronized (lock) { // count++; // ac++;  int count = ac.incrementAndGet();  System.out.println(\"已经送了\" + count + \"个冰淇淋\");  // }  }  } } 源码解析 :\n//先自增，然后获取自增后的结果 public final int incrementAndGet() {  //+ 1 自增后的结果  //this 就表示当前的atomicInteger（值）  //1 自增一次  return U.getAndAddInt(this, VALUE, 1) + 1; }  public final int getAndAddInt(Object o, long offset, int delta) {  //v 旧值  int v;  //自旋的过程  do {  //不断的获取旧值  v = getIntVolatile(o, offset);  //如果这个方法的返回值为false，那么继续自旋  //如果这个方法的返回值为true，那么自旋结束  //o 表示的就是内存值  //v 旧值  //v + delta 修改后的值  } while (!weakCompareAndSetInt(o, offset, v, v + delta));  //作用：比较内存中的值，旧值是否相等，如果相等就把修改后的值写到内存中，返回true。表示修改成功。  // 如果不相等，无法把修改后的值写到内存中，返回false。表示修改失败。  //如果修改失败，那么继续自旋。  return v; } 2.9 悲观锁和乐观锁 synchronized和CAS的区别 :\n**相同点：**在多线程情况下，都可以保证共享数据的安全性。\n**不同点：**synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每次操作共享数据之前，都会上锁。（悲观锁）\n​\tcas是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。\n​\t如果别人修改过，那么我再次获取现在最新的值。\n​\t如果别人没有修改过，那么我现在直接修改共享数据的值.(乐观锁）\n3. 并发工具类 3.1 并发工具类-Hashtable ​\tHashtable出现的原因 : 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。\n代码实现 :\npackage com.itheima.mymap;  import java.util.HashMap; import java.util.Hashtable;  public class MyHashtableDemo {  public static void main(String[] args) throws InterruptedException {  HashtableString, String hm = new Hashtable();   Thread t1 = new Thread(() - {  for (int i = 0; i  25; i++) {  hm.put(i + \"\", i + \"\");  }  });    Thread t2 = new Thread(() - {  for (int i = 25; i  51; i++) {  hm.put(i + \"\", i + \"\");  }  });   t1.start();  t2.start();   System.out.println(\"----------------------------\");  //为了t1和t2能把数据全部添加完毕  Thread.sleep(1000);   //0-0 1-1 ..... 50- 50   for (int i = 0; i  51; i++) {  System.out.println(hm.get(i + \"\"));  }//0 1 2 3 .... 50    } } 3.2 并发工具类-ConcurrentHashMap基本使用 ​\tConcurrentHashMap出现的原因 : 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。\n基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。\n体系结构 :\n总结 :\n​\t1 ，HashMap是线程不安全的。多线程环境下会有数据安全问题\n​\t2 ，Hashtable是线程安全的，但是会将整张表锁起来，效率低下\n​\t3，ConcurrentHashMap也是线程安全的，效率较高。 在JDK7和JDK8中，底层原理不一样。\n代码实现 :\npackage com.itheima.mymap;  import java.util.Hashtable; import java.util.concurrent.ConcurrentHashMap;  public class MyConcurrentHashMapDemo {  public static void main(String[] args) throws InterruptedException {  ConcurrentHashMapString, String hm = new ConcurrentHashMap(100);   Thread t1 = new Thread(() - {  for (int i = 0; i  25; i++) {  hm.put(i + \"\", i + \"\");  }  });    Thread t2 = new Thread(() - {  for (int i = 25; i  51; i++) {  hm.put(i + \"\", i + \"\");  }  });   t1.start();  t2.start();   System.out.println(\"----------------------------\");  //为了t1和t2能把数据全部添加完毕  Thread.sleep(1000);   //0-0 1-1 ..... 50- 50   for (int i = 0; i  51; i++) {  System.out.println(hm.get(i + \"\"));  }//0 1 2 3 .... 50  } } 3.3 并发工具类-ConcurrentHashMap1.7原理 3.4 并发工具类-ConcurrentHashMap1.8原理 总结 :\n​\t1，如果使用空参构造创建ConcurrentHashMap对象，则什么事情都不做。 在第一次添加元素的时候创建哈希表\n​\t2，计算当前元素应存入的索引。\n​\t3，如果该索引位置为null，则利用cas算法，将本结点添加到数组中。\n​\t4，如果该索引位置不为null，则利用volatile关键字获得当前位置最新的结点地址，挂在他下面，变成链表。\n​\t5，当链表的长度大于等于8时，自动转换成红黑树6，以链表或者红黑树头结点为锁对象，配合悲观锁保证多线程操作集合时数据的安全性\n3.5 并发工具类-CountDownLatch CountDownLatch类 :\n   方法 解释     public CountDownLatch(int count) 参数传递线程数，表示等待线程数量   public void await() 让线程等待   public void countDown() 当前线程执行完毕    使用场景： 让某一条线程等待其他线程执行完毕之后再执行\n代码实现 :\npackage com.itheima.mycountdownlatch;  import java.util.concurrent.CountDownLatch;  public class ChileThread1 extends Thread {   private CountDownLatch countDownLatch;  public ChileThread1(CountDownLatch countDownLatch) {  this.countDownLatch = countDownLatch;  }   @Override  public void run() {  //1.吃饺子  for (int i = 1; i  10; i++) {  System.out.println(getName() + \"在吃第\" + i + \"个饺子\");  }  //2.吃完说一声  //每一次countDown方法的时候，就让计数器-1  countDownLatch.countDown();  } } package com.itheima.mycountdownlatch;  import java.util.concurrent.CountDownLatch;  public class ChileThread2 extends Thread {   private CountDownLatch countDownLatch;  public ChileThread2(CountDownLatch countDownLatch) {  this.countDownLatch = countDownLatch;  }  @Override  public void run() {  //1.吃饺子  for (int i = 1; i  15; i++) {  System.out.println(getName() + \"在吃第\" + i + \"个饺子\");  }  //2.吃完说一声  //每一次countDown方法的时候，就让计数器-1  countDownLatch.countDown();  } } package com.itheima.mycountdownlatch;  import java.util.concurrent.CountDownLatch;  public class ChileThread3 extends Thread {   private CountDownLatch countDownLatch;  public ChileThread3(CountDownLatch countDownLatch) {  this.countDownLatch = countDownLatch;  }  @Override  public void run() {  //1.吃饺子  for (int i = 1; i  20; i++) {  System.out.println(getName() + \"在吃第\" + i + \"个饺子\");  }  //2.吃完说一声  //每一次countDown方法的时候，就让计数器-1  countDownLatch.countDown();  } } package com.itheima.mycountdownlatch;  import java.util.concurrent.CountDownLatch;  public class MotherThread extends Thread {  private CountDownLatch countDownLatch;  public MotherThread(CountDownLatch countDownLatch) {  this.countDownLatch = countDownLatch;  }   @Override  public void run() {  //1.等待  try {  //当计数器变成0的时候，会自动唤醒这里等待的线程。  countDownLatch.await();  } catch (InterruptedException e) {  e.printStackTrace();  }  //2.收拾碗筷  System.out.println(\"妈妈在收拾碗筷\");  } } package com.itheima.mycountdownlatch;  import java.util.concurrent.CountDownLatch;  public class MyCountDownLatchDemo {  public static void main(String[] args) {  //1.创建CountDownLatch的对象，需要传递给四个线程。  //在底层就定义了一个计数器，此时计数器的值就是3  CountDownLatch countDownLatch = new CountDownLatch(3);  //2.创建四个线程对象并开启他们。  MotherThread motherThread = new MotherThread(countDownLatch);  motherThread.start();   ChileThread1 t1 = new ChileThread1(countDownLatch);  t1.setName(\"小明\");   ChileThread2 t2 = new ChileThread2(countDownLatch);  t2.setName(\"小红\");   ChileThread3 t3 = new ChileThread3(countDownLatch);  t3.setName(\"小刚\");   t1.start();  t2.start();  t3.start();  } } 总结 :\n​\t1. CountDownLatch(int count)：参数写等待线程的数量。并定义了一个计数器。\n​\t2. await()：让线程等待，当计数器为0时，会唤醒等待的线程\n​\t3. countDown()： 线程执行完毕时调用，会将计数器-1。\n3.6 并发工具类-Semaphore 使用场景 :\n​\t可以控制访问特定资源的线程数量。\n实现步骤 :\n​\t1，需要有人管理这个通道\n​\t2，当有车进来了，发通行许可证\n​\t3，当车出去了，收回通行许可证\n​\t4，如果通行许可证发完了，那么其他车辆只能等着\n代码实现 :\npackage com.itheima.mysemaphore;  import java.util.concurrent.Semaphore;  public class MyRunnable implements Runnable {  //1.获得管理员对象，  private Semaphore semaphore = new Semaphore(2);  @Override  public void run() {  //2.获得通行证  try {  semaphore.acquire();  //3.开始行驶  System.out.println(\"获得了通行证开始行驶\");  Thread.sleep(2000);  System.out.println(\"归还通行证\");  //4.归还通行证  semaphore.release();  } catch (InterruptedException e) {  e.printStackTrace();  }  } } package com.itheima.mysemaphore;  public class MySemaphoreDemo {  public static void main(String[] args) {  MyRunnable mr = new MyRunnable();   for (int i = 0; i  100; i++) {  new Thread(mr).start();  }  } } ",
  "wordCount" : "2460",
  "inLanguage": "zh",
  "datePublished": "2022-03-15T17:30:37Z",
  "dateModified": "2022-03-15T17:30:37Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://iblog.zone/archives/java%E5%A4%9A%E7%BA%BF%E7%A8%8B02/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "ylw's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://iblog.zone/images/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://iblog.zone" accesskey="h" title="ylw&#39;s blog (Alt + H)">ylw&#39;s blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://iblog.zone/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://iblog.zone/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://iblog.zone/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://iblog.zone/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://iblog.zone/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://iblog.zone">主页</a>&nbsp;»&nbsp;<a href="https://iblog.zone/posts/">Posts</a></div>
    <h1 class="post-title">
      Java多线程02
    </h1>
    <div class="post-meta"><span title='2022-03-15 17:30:37 +0000 UTC'>2022-03-15</span>&nbsp;·&nbsp;12 分钟

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#1%e7%ba%bf%e7%a8%8b%e6%b1%a0" aria-label="1.线程池">1.线程池</a><ul>
                            
                    <li>
                        <a href="#11-%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81%e4%bb%8b%e7%bb%8d" aria-label="1.1 线程状态介绍">1.1 线程状态介绍</a></li>
                    <li>
                        <a href="#12-%e7%ba%bf%e7%a8%8b%e7%9a%84%e7%8a%b6%e6%80%81-%e7%bb%83%e4%b9%a01" aria-label="1.2 线程的状态-练习1">1.2 线程的状态-练习1</a></li>
                    <li>
                        <a href="#13-%e7%ba%bf%e7%a8%8b%e7%9a%84%e7%8a%b6%e6%80%81-%e7%bb%83%e4%b9%a02" aria-label="1.3 线程的状态-练习2">1.3 线程的状态-练习2</a></li>
                    <li>
                        <a href="#14-%e7%ba%bf%e7%a8%8b%e7%9a%84%e7%8a%b6%e6%80%81-%e7%bb%83%e4%b9%a03" aria-label="1.4 线程的状态-练习3">1.4 线程的状态-练习3</a></li>
                    <li>
                        <a href="#15-%e7%ba%bf%e7%a8%8b%e6%b1%a0-%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86" aria-label="1.5 线程池-基本原理">1.5 线程池-基本原理</a></li>
                    <li>
                        <a href="#16-%e7%ba%bf%e7%a8%8b%e6%b1%a0-executors%e9%bb%98%e8%ae%a4%e7%ba%bf%e7%a8%8b%e6%b1%a0" aria-label="1.6 线程池-Executors默认线程池">1.6 线程池-Executors默认线程池</a></li>
                    <li>
                        <a href="#17-%e7%ba%bf%e7%a8%8b%e6%b1%a0-executors%e5%88%9b%e5%bb%ba%e6%8c%87%e5%ae%9a%e4%b8%8a%e9%99%90%e7%9a%84%e7%ba%bf%e7%a8%8b%e6%b1%a0" aria-label="1.7 线程池-Executors创建指定上限的线程池">1.7 线程池-Executors创建指定上限的线程池</a></li>
                    <li>
                        <a href="#18-%e7%ba%bf%e7%a8%8b%e6%b1%a0-threadpoolexecutor" aria-label="1.8 线程池-ThreadPoolExecutor">1.8 线程池-ThreadPoolExecutor</a></li>
                    <li>
                        <a href="#19-%e7%ba%bf%e7%a8%8b%e6%b1%a0-%e5%8f%82%e6%95%b0%e8%af%a6%e8%a7%a3" aria-label="1.9 线程池-参数详解">1.9 线程池-参数详解</a></li>
                    <li>
                        <a href="#110-%e7%ba%bf%e7%a8%8b%e6%b1%a0-%e9%9d%9e%e9%bb%98%e8%ae%a4%e4%bb%bb%e5%8a%a1%e6%8b%92%e7%bb%9d%e7%ad%96%e7%95%a5" aria-label="1.10 线程池-非默认任务拒绝策略">1.10 线程池-非默认任务拒绝策略</a></li></ul>
                    </li>
                    <li>
                        <a href="#2-%e5%8e%9f%e5%ad%90%e6%80%a7" aria-label="2. 原子性">2. 原子性</a><ul>
                            
                    <li>
                        <a href="#21-volatile-%e9%97%ae%e9%a2%98" aria-label="2.1 volatile-问题">2.1 volatile-问题</a></li>
                    <li>
                        <a href="#22-volatile%e8%a7%a3%e5%86%b3" aria-label="2.2 volatile解决">2.2 volatile解决</a></li>
                    <li>
                        <a href="#23-synchronized%e8%a7%a3%e5%86%b3" aria-label="2.3 synchronized解决">2.3 synchronized解决</a></li>
                    <li>
                        <a href="#24-%e5%8e%9f%e5%ad%90%e6%80%a7" aria-label="2.4 原子性">2.4 原子性</a></li>
                    <li>
                        <a href="#25-volatile%e5%85%b3%e9%94%ae%e5%ad%97%e4%b8%8d%e8%83%bd%e4%bf%9d%e8%af%81%e5%8e%9f%e5%ad%90%e6%80%a7" aria-label="2.5 volatile关键字不能保证原子性">2.5 volatile关键字不能保证原子性</a></li>
                    <li>
                        <a href="#26-%e5%8e%9f%e5%ad%90%e6%80%a7_atomicinteger" aria-label="2.6 原子性_AtomicInteger">2.6 原子性_AtomicInteger</a></li>
                    <li>
                        <a href="#27-atomicinteger-%e5%86%85%e5%ad%98%e8%a7%a3%e6%9e%90" aria-label="2.7 AtomicInteger-内存解析">2.7 AtomicInteger-内存解析</a></li>
                    <li>
                        <a href="#28-atomicinteger-%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90" aria-label="2.8 AtomicInteger-源码解析">2.8 AtomicInteger-源码解析</a></li>
                    <li>
                        <a href="#29-%e6%82%b2%e8%a7%82%e9%94%81%e5%92%8c%e4%b9%90%e8%a7%82%e9%94%81" aria-label="2.9 悲观锁和乐观锁">2.9 悲观锁和乐观锁</a></li></ul>
                    </li>
                    <li>
                        <a href="#3-%e5%b9%b6%e5%8f%91%e5%b7%a5%e5%85%b7%e7%b1%bb" aria-label="3. 并发工具类">3. 并发工具类</a><ul>
                            
                    <li>
                        <a href="#31-%e5%b9%b6%e5%8f%91%e5%b7%a5%e5%85%b7%e7%b1%bb-hashtable" aria-label="3.1 并发工具类-Hashtable">3.1 并发工具类-Hashtable</a></li>
                    <li>
                        <a href="#32-%e5%b9%b6%e5%8f%91%e5%b7%a5%e5%85%b7%e7%b1%bb-concurrenthashmap%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8" aria-label="3.2 并发工具类-ConcurrentHashMap基本使用">3.2 并发工具类-ConcurrentHashMap基本使用</a></li>
                    <li>
                        <a href="#33-%e5%b9%b6%e5%8f%91%e5%b7%a5%e5%85%b7%e7%b1%bb-concurrenthashmap17%e5%8e%9f%e7%90%86" aria-label="3.3 并发工具类-ConcurrentHashMap1.7原理">3.3 并发工具类-ConcurrentHashMap1.7原理</a></li>
                    <li>
                        <a href="#34-%e5%b9%b6%e5%8f%91%e5%b7%a5%e5%85%b7%e7%b1%bb-concurrenthashmap18%e5%8e%9f%e7%90%86" aria-label="3.4 并发工具类-ConcurrentHashMap1.8原理">3.4 并发工具类-ConcurrentHashMap1.8原理</a></li>
                    <li>
                        <a href="#35-%e5%b9%b6%e5%8f%91%e5%b7%a5%e5%85%b7%e7%b1%bb-countdownlatch" aria-label="3.5 并发工具类-CountDownLatch">3.5 并发工具类-CountDownLatch</a></li>
                    <li>
                        <a href="#36-%e5%b9%b6%e5%8f%91%e5%b7%a5%e5%85%b7%e7%b1%bb-semaphore" aria-label="3.6 并发工具类-Semaphore">3.6 并发工具类-Semaphore</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script data-cfasync="false">
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>


  <div class="post-content"><h2 id="1线程池">1.线程池<a hidden class="anchor" aria-hidden="true" href="#1线程池">#</a></h2>
<h3 id="11-线程状态介绍">1.1 线程状态介绍<a hidden class="anchor" aria-hidden="true" href="#11-线程状态介绍">#</a></h3>
<p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程</p>
<p>状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Thread</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">enum</span> State <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* 新建 */</span>
</span></span><span style="display:flex;"><span>        NEW <span style="color:#f92672">,</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* 可运行状态 */</span>
</span></span><span style="display:flex;"><span>        RUNNABLE <span style="color:#f92672">,</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* 阻塞状态 */</span>
</span></span><span style="display:flex;"><span>        BLOCKED <span style="color:#f92672">,</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* 无限等待状态 */</span>
</span></span><span style="display:flex;"><span>        WAITING <span style="color:#f92672">,</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* 计时等待 */</span>
</span></span><span style="display:flex;"><span>        TIMED_WAITING <span style="color:#f92672">,</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* 终止 */</span>
</span></span><span style="display:flex;"><span>        TERMINATED<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取当前线程的状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> State <span style="color:#a6e22e">getState</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> jdk<span style="color:#f92672">.</span><span style="color:#a6e22e">internal</span><span style="color:#f92672">.</span><span style="color:#a6e22e">misc</span><span style="color:#f92672">.</span><span style="color:#a6e22e">VM</span><span style="color:#f92672">.</span><span style="color:#a6e22e">toThreadState</span><span style="color:#f92672">(</span>threadStatus<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下</p>
<table>
<thead>
<tr>
<th>线程状态</th>
<th>具体含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td>一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread()只有线程象，没有线程特征。</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</td>
</tr>
<tr>
<td>WAITING</td>
<td>一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。</td>
</tr>
<tr>
<td>TIMED_WAITING</td>
<td>一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>一个完全运行完成的线程的状态。也称之为终止状态、结束状态</td>
</tr>
</tbody>
</table>
<p>各个状态的转换，如下图所示：</p>
<p><img loading="lazy" src="/images/Java%e5%a4%9a%e7%ba%bf%e7%a8%8b02/1591163781941.png" alt=""  />
</p>
<h3 id="12-线程的状态-练习1">1.2 线程的状态-练习1<a hidden class="anchor" aria-hidden="true" href="#12-线程的状态-练习1">#</a></h3>
<p><strong>目的 :</strong> 本案例主要演示TIME_WAITING的状态转换。</p>
<p>**需求：**编写一段代码，依次显示一个线程的这些状态：NEW -&gt; RUNNABLE -&gt; TIME_WAITING -&gt; RUNNABLE -&gt; TERMINATED</p>
<p>为了简化我们的开发，本次我们使用匿名内部类结合lambda表达式的方式使用多线程。</p>
<p><strong>代码实现</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadStateDemo01</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//定义一个内部线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Thread thread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;2.执行thread.start()之后，线程的状态：&#34;</span> <span style="color:#f92672">+</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//休眠100毫秒
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>100<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;4.执行Thread.sleep(long)完成之后，线程的状态：&#34;</span> <span style="color:#f92672">+</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//获取start()之前的状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;1.通过new初始化一个线程，但是还没有start()之前，线程的状态：&#34;</span> <span style="color:#f92672">+</span> thread<span style="color:#f92672">.</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//启动线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        thread<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//休眠50毫秒
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>50<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//因为thread1需要休眠100毫秒，所以在第50毫秒，thread处于sleep状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;3.执行Thread.sleep(long)时，线程的状态：&#34;</span> <span style="color:#f92672">+</span> thread<span style="color:#f92672">.</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//thread1和main线程主动休眠150毫秒，所以在第150毫秒,thread早已执行完毕
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>100<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;5.线程执行完毕之后，线程的状态：&#34;</span> <span style="color:#f92672">+</span> thread<span style="color:#f92672">.</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;\n&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>控制台输出</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>1<span style="color:#f92672">.</span><span style="color:#a6e22e">通过new初始化一个线程</span><span style="color:#960050;background-color:#1e0010">，</span>但是还没有start<span style="color:#f92672">()</span>之前<span style="color:#960050;background-color:#1e0010">，</span>线程的状态<span style="color:#960050;background-color:#1e0010">：</span>NEW
</span></span><span style="display:flex;"><span>2<span style="color:#f92672">.</span><span style="color:#a6e22e">执行thread</span><span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">()</span>之后<span style="color:#960050;background-color:#1e0010">，</span>线程的状态<span style="color:#960050;background-color:#1e0010">：</span>RUNNABLE
</span></span><span style="display:flex;"><span>3<span style="color:#f92672">.</span><span style="color:#a6e22e">执行Thread</span><span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span><span style="color:#66d9ef">long</span><span style="color:#f92672">)</span>时<span style="color:#960050;background-color:#1e0010">，</span>线程的状态<span style="color:#960050;background-color:#1e0010">：</span>TIMED_WAITING
</span></span><span style="display:flex;"><span>4<span style="color:#f92672">.</span><span style="color:#a6e22e">执行Thread</span><span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span><span style="color:#66d9ef">long</span><span style="color:#f92672">)</span>完成之后<span style="color:#960050;background-color:#1e0010">，</span>线程的状态<span style="color:#960050;background-color:#1e0010">：</span>RUNNABLE
</span></span><span style="display:flex;"><span>5<span style="color:#f92672">.</span><span style="color:#a6e22e">线程执行完毕之后</span><span style="color:#960050;background-color:#1e0010">，</span>线程的状态<span style="color:#960050;background-color:#1e0010">：</span>TERMINATED
</span></span></code></pre></div><h3 id="heading"><a hidden class="anchor" aria-hidden="true" href="#heading">#</a></h3>
<h3 id="13-线程的状态-练习2">1.3 线程的状态-练习2<a hidden class="anchor" aria-hidden="true" href="#13-线程的状态-练习2">#</a></h3>
<p><strong>目的 :</strong> 本案例主要演示WAITING的状态转换。</p>
<p>**需求 ：**编写一段代码，依次显示一个线程的这些状态：NEW -&gt; RUNNABLE -&gt; WAITING -&gt; RUNNABLE -&gt; TERMINATED</p>
<p><strong>代码实现 :</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadStateDemo02</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//定义一个对象，用来加锁和解锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Object obj <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//定义一个内部线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Thread thread1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;2.执行thread.start()之后，线程的状态：&#34;</span> <span style="color:#f92672">+</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>obj<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">//thread1需要休眠100毫秒
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>100<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">//thread1100毫秒之后，通过wait()方法释放obj对象是锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    obj<span style="color:#f92672">.</span><span style="color:#a6e22e">wait</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                    
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;4.被object.notify()方法唤醒之后，线程的状态：&#34;</span> <span style="color:#f92672">+</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//获取start()之前的状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;1.通过new初始化一个线程，但是还没有start()之前，线程的状态：&#34;</span> <span style="color:#f92672">+</span> thread1<span style="color:#f92672">.</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//启动线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        thread1<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//main线程休眠150毫秒
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>150<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//因为thread1在第100毫秒进入wait等待状态，所以第150秒肯定可以获取其状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;3.执行object.wait()时，线程的状态：&#34;</span> <span style="color:#f92672">+</span> thread1<span style="color:#f92672">.</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//声明另一个线程进行解锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>obj<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//唤醒等待的线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                obj<span style="color:#f92672">.</span><span style="color:#a6e22e">notify</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//main线程休眠10毫秒等待thread1线程能够苏醒
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>10<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//获取thread1运行结束之后的状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;5.线程执行完毕之后，线程的状态：&#34;</span> <span style="color:#f92672">+</span> thread1<span style="color:#f92672">.</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;\n&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>控制台输出结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>1<span style="color:#f92672">.</span><span style="color:#a6e22e">通过new初始化一个线程</span><span style="color:#960050;background-color:#1e0010">，</span>但是还没有start<span style="color:#f92672">()</span>之前<span style="color:#960050;background-color:#1e0010">，</span>线程的状态<span style="color:#960050;background-color:#1e0010">：</span>NEW
</span></span><span style="display:flex;"><span>2<span style="color:#f92672">.</span><span style="color:#a6e22e">执行thread</span><span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">()</span>之后<span style="color:#960050;background-color:#1e0010">，</span>线程的状态<span style="color:#960050;background-color:#1e0010">：</span>RUNNABLE
</span></span><span style="display:flex;"><span>3<span style="color:#f92672">.</span><span style="color:#a6e22e">执行object</span><span style="color:#f92672">.</span><span style="color:#a6e22e">wait</span><span style="color:#f92672">()</span>时<span style="color:#960050;background-color:#1e0010">，</span>线程的状态<span style="color:#960050;background-color:#1e0010">：</span>WAITING
</span></span><span style="display:flex;"><span>4<span style="color:#f92672">.</span><span style="color:#a6e22e">被object</span><span style="color:#f92672">.</span><span style="color:#a6e22e">notify</span><span style="color:#f92672">()</span>方法唤醒之后<span style="color:#960050;background-color:#1e0010">，</span>线程的状态<span style="color:#960050;background-color:#1e0010">：</span>RUNNABLE
</span></span><span style="display:flex;"><span>5<span style="color:#f92672">.</span><span style="color:#a6e22e">线程执行完毕之后</span><span style="color:#960050;background-color:#1e0010">，</span>线程的状态<span style="color:#960050;background-color:#1e0010">：</span>TERMINATED
</span></span></code></pre></div><h3 id="heading-1"><a hidden class="anchor" aria-hidden="true" href="#heading-1">#</a></h3>
<h3 id="14-线程的状态-练习3">1.4 线程的状态-练习3<a hidden class="anchor" aria-hidden="true" href="#14-线程的状态-练习3">#</a></h3>
<p><strong>目的 :</strong>   本案例主要演示BLOCKED的状态转换。</p>
<p>**需求 ：**编写一段代码，依次显示一个线程的这些状态：NEW -&gt; RUNNABLE -&gt; BLOCKED -&gt; RUNNABLE -&gt; TERMINATED</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadStateDemo03</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//定义一个对象，用来加锁和解锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Object obj2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//定义一个线程，先抢占了obj2对象的锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>obj2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>100<span style="color:#f92672">);</span>              <span style="color:#75715e">//第一个线程要持有锁100毫秒
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    obj2<span style="color:#f92672">.</span><span style="color:#a6e22e">wait</span><span style="color:#f92672">();</span>                          <span style="color:#75715e">//然后通过wait()方法进行等待状态，并释放obj2的对象锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//定义目标线程，获取等待获取obj2的锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Thread thread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;2.执行thread.start()之后，线程的状态：&#34;</span> <span style="color:#f92672">+</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>obj2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>100<span style="color:#f92672">);</span>              <span style="color:#75715e">//thread3要持有对象锁100毫秒
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    obj2<span style="color:#f92672">.</span><span style="color:#a6e22e">notify</span><span style="color:#f92672">();</span>                        <span style="color:#75715e">//然后通过notify()方法唤醒所有在ojb2上等待的线程继续执行后续操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;4.阻塞结束后，线程的状态：&#34;</span> <span style="color:#f92672">+</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//获取start()之前的状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：&#34;</span> <span style="color:#f92672">+</span> thread<span style="color:#f92672">.</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//启动线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        thread<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//先等100毫秒
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>50<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//第一个线程释放锁至少需要100毫秒，所以在第50毫秒时，thread正在因等待obj的对象锁而阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;3.因为等待锁而阻塞时，线程的状态：&#34;</span> <span style="color:#f92672">+</span> thread<span style="color:#f92672">.</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//再等300毫秒
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>300<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//两个线程的执行时间加上之前等待的50毫秒总共是250毫秒，所以第300毫秒，所有的线程都已经执行完毕
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;5.线程执行完毕之后，线程的状态：&#34;</span> <span style="color:#f92672">+</span> thread<span style="color:#f92672">.</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>控制台输出结果</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>1<span style="color:#f92672">.</span><span style="color:#a6e22e">通过new初始化一个线程</span><span style="color:#960050;background-color:#1e0010">，</span>但是还没有thread<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">()</span>之前<span style="color:#960050;background-color:#1e0010">，</span>线程的状态<span style="color:#960050;background-color:#1e0010">：</span>NEW
</span></span><span style="display:flex;"><span>2<span style="color:#f92672">.</span><span style="color:#a6e22e">执行thread</span><span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">()</span>之后<span style="color:#960050;background-color:#1e0010">，</span>线程的状态<span style="color:#960050;background-color:#1e0010">：</span>RUNNABLE
</span></span><span style="display:flex;"><span>3<span style="color:#f92672">.</span><span style="color:#a6e22e">因为等待锁而阻塞时</span><span style="color:#960050;background-color:#1e0010">，</span>线程的状态<span style="color:#960050;background-color:#1e0010">：</span>BLOCKED
</span></span><span style="display:flex;"><span>4<span style="color:#f92672">.</span><span style="color:#a6e22e">阻塞结束后</span><span style="color:#960050;background-color:#1e0010">，</span>线程的状态<span style="color:#960050;background-color:#1e0010">：</span>RUNNABLE
</span></span><span style="display:flex;"><span>5<span style="color:#f92672">.</span><span style="color:#a6e22e">线程执行完毕之后</span><span style="color:#960050;background-color:#1e0010">，</span>线程的状态<span style="color:#960050;background-color:#1e0010">：</span>TERMINATED
</span></span></code></pre></div><h3 id="15-线程池-基本原理">1.5 线程池-基本原理<a hidden class="anchor" aria-hidden="true" href="#15-线程池-基本原理">#</a></h3>
<p><strong>概述 :</strong></p>
<p>​	提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。</p>
<p>线程池存在的意义：</p>
<p>​	系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系</p>
<p>​	统资源的消耗，这样就有点&quot;舍本逐末&quot;了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就</p>
<p>​	会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。</p>
<p><strong>线程池的设计思路 :</strong></p>
<ol>
<li>准备一个任务容器</li>
<li>一次性启动多个(2个)消费者线程</li>
<li>刚开始任务容器是空的，所以线程都在wait</li>
<li>直到一个外部线程向这个任务容器中扔了一个&quot;任务&quot;，就会有一个消费者线程被唤醒</li>
<li>这个消费者线程取出&quot;任务&quot;，并且执行这个任务，执行完毕后，继续等待下一次任务的到来</li>
</ol>
<h3 id="16-线程池-executors默认线程池">1.6 线程池-Executors默认线程池<a hidden class="anchor" aria-hidden="true" href="#16-线程池-executors默认线程池">#</a></h3>
<p>概述 : JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。</p>
<p>我们可以使用Executors中所提供的<strong>静态</strong>方法来创建线程池</p>
<p>​	static ExecutorService newCachedThreadPool()   创建一个默认的线程池
​	static newFixedThreadPool(int nThreads)	    创建一个指定最多线程数量的线程池</p>
<p><strong>代码实现 :</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.mythreadpool<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//static ExecutorService newCachedThreadPool()   创建一个默认的线程池
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//static newFixedThreadPool(int nThreads)	    创建一个指定最多线程数量的线程池
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.ExecutorService<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.Executors<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThreadPoolDemo</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//1,创建一个默认的线程池对象.池子中默认是空的.默认最多可以容纳int类型的最大值.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ExecutorService executorService <span style="color:#f92672">=</span> Executors<span style="color:#f92672">.</span><span style="color:#a6e22e">newCachedThreadPool</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//Executors --- 可以帮助我们创建线程池对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//ExecutorService --- 可以帮助我们控制线程池
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        executorService<span style="color:#f92672">.</span><span style="color:#a6e22e">submit</span><span style="color:#f92672">(()-&gt;{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;在执行了&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//Thread.sleep(2000);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        executorService<span style="color:#f92672">.</span><span style="color:#a6e22e">submit</span><span style="color:#f92672">(()-&gt;{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;在执行了&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        executorService<span style="color:#f92672">.</span><span style="color:#a6e22e">shutdown</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="17-线程池-executors创建指定上限的线程池">1.7 线程池-Executors创建指定上限的线程池<a hidden class="anchor" aria-hidden="true" href="#17-线程池-executors创建指定上限的线程池">#</a></h3>
<p><strong>使用Executors中所提供的静态方法来创建线程池</strong></p>
<p>​	static ExecutorService newFixedThreadPool(int nThreads) : 创建一个指定最多线程数量的线程池</p>
<p><strong>代码实现 :</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.mythreadpool<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//static ExecutorService newFixedThreadPool(int nThreads)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//创建一个指定最多线程数量的线程池
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.ExecutorService<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.Executors<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.ThreadPoolExecutor<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThreadPoolDemo2</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//参数不是初始值而是最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ExecutorService executorService <span style="color:#f92672">=</span> Executors<span style="color:#f92672">.</span><span style="color:#a6e22e">newFixedThreadPool</span><span style="color:#f92672">(</span>10<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ThreadPoolExecutor pool <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>ThreadPoolExecutor<span style="color:#f92672">)</span> executorService<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>pool<span style="color:#f92672">.</span><span style="color:#a6e22e">getPoolSize</span><span style="color:#f92672">());</span><span style="color:#75715e">//0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        executorService<span style="color:#f92672">.</span><span style="color:#a6e22e">submit</span><span style="color:#f92672">(()-&gt;{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;在执行了&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        executorService<span style="color:#f92672">.</span><span style="color:#a6e22e">submit</span><span style="color:#f92672">(()-&gt;{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;在执行了&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>pool<span style="color:#f92672">.</span><span style="color:#a6e22e">getPoolSize</span><span style="color:#f92672">());</span><span style="color:#75715e">//2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//        executorService.shutdown();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="18-线程池-threadpoolexecutor">1.8 线程池-ThreadPoolExecutor<a hidden class="anchor" aria-hidden="true" href="#18-线程池-threadpoolexecutor">#</a></h3>
<p><strong>创建线程池对象 :</strong></p>
<p>ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略);</p>
<p><strong>代码实现 :</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.mythreadpool<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.ArrayBlockingQueue<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.Executors<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.ThreadPoolExecutor<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.TimeUnit<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThreadPoolDemo3</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//    参数一：核心线程数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    参数二：最大线程数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    参数三：空闲线程最大存活时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    参数四：时间单位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    参数五：任务队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    参数六：创建线程工厂
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    参数七：任务的拒绝策略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        ThreadPoolExecutor pool <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>2<span style="color:#f92672">,</span>5<span style="color:#f92672">,</span>2<span style="color:#f92672">,</span>TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">SECONDS</span><span style="color:#f92672">,</span><span style="color:#66d9ef">new</span> ArrayBlockingQueue<span style="color:#f92672">&lt;&gt;(</span>10<span style="color:#f92672">),</span> Executors<span style="color:#f92672">.</span><span style="color:#a6e22e">defaultThreadFactory</span><span style="color:#f92672">(),</span><span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">AbortPolicy</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>        pool<span style="color:#f92672">.</span><span style="color:#a6e22e">submit</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> MyRunnable<span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>        pool<span style="color:#f92672">.</span><span style="color:#a6e22e">submit</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> MyRunnable<span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        pool<span style="color:#f92672">.</span><span style="color:#a6e22e">shutdown</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="19-线程池-参数详解">1.9 线程池-参数详解<a hidden class="anchor" aria-hidden="true" href="#19-线程池-参数详解">#</a></h3>
<p><img loading="lazy" src="/images/Java%e5%a4%9a%e7%ba%bf%e7%a8%8b02/1591165506516.png" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ThreadPoolExecutor</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> corePoolSize<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                              <span style="color:#66d9ef">int</span> maximumPoolSize<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                              <span style="color:#66d9ef">long</span> keepAliveTime<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                              TimeUnit unit<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                              BlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> workQueue<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                              ThreadFactory threadFactory<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                              RejectedExecutionHandler handler<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>corePoolSize<span style="color:#960050;background-color:#1e0010">：</span>   核心线程的最大值<span style="color:#960050;background-color:#1e0010">，</span>不能小于0
</span></span><span style="display:flex;"><span>maximumPoolSize<span style="color:#960050;background-color:#1e0010">：</span>最大线程数<span style="color:#960050;background-color:#1e0010">，</span>不能小于等于0<span style="color:#960050;background-color:#1e0010">，</span>maximumPoolSize <span style="color:#f92672">&gt;=</span> corePoolSize
</span></span><span style="display:flex;"><span>keepAliveTime<span style="color:#960050;background-color:#1e0010">：</span>  空闲线程最大存活时间<span style="color:#f92672">,</span>不能小于0
</span></span><span style="display:flex;"><span>unit<span style="color:#960050;background-color:#1e0010">：</span>           时间单位
</span></span><span style="display:flex;"><span>workQueue<span style="color:#960050;background-color:#1e0010">：</span>      任务队列<span style="color:#960050;background-color:#1e0010">，</span>不能为null
</span></span><span style="display:flex;"><span>threadFactory<span style="color:#960050;background-color:#1e0010">：</span>  创建线程工厂<span style="color:#f92672">,</span>不能为null      
</span></span><span style="display:flex;"><span>handler<span style="color:#960050;background-color:#1e0010">：</span>        任务的拒绝策略<span style="color:#f92672">,</span>不能为null  
</span></span></code></pre></div><h3 id="110-线程池-非默认任务拒绝策略">1.10 线程池-非默认任务拒绝策略<a hidden class="anchor" aria-hidden="true" href="#110-线程池-非默认任务拒绝策略">#</a></h3>
<p>RejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ThreadPoolExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">AbortPolicy</span><span style="color:#f92672">:</span> 		    丢弃任务并抛出RejectedExecutionException异常<span style="color:#960050;background-color:#1e0010">。</span>是默认的策略<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>ThreadPoolExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">DiscardPolicy</span><span style="color:#960050;background-color:#1e0010">：</span> 		   丢弃任务<span style="color:#960050;background-color:#1e0010">，</span>但是不抛出异常 这是不推荐的做法<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>ThreadPoolExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">DiscardOldestPolicy</span><span style="color:#960050;background-color:#1e0010">：</span>    抛弃队列中等待最久的任务 然后把当前任务加入队列中<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>ThreadPoolExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">CallerRunsPolicy</span><span style="color:#f92672">:</span>        调用任务的run<span style="color:#f92672">()</span>方法绕过线程池直接执行<span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><p>注：明确线程池对多可执行的任务数 = 队列容量 + 最大线程数</p>
<p><strong>案例演示1</strong>：演示ThreadPoolExecutor.AbortPolicy任务处理策略</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadPoolExecutorDemo01</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        ThreadPoolExecutor threadPoolExecutor <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>1 <span style="color:#f92672">,</span> 3 <span style="color:#f92672">,</span> 20 <span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">SECONDS</span> <span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">new</span> ArrayBlockingQueue<span style="color:#f92672">&lt;&gt;(</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">,</span> Executors<span style="color:#f92672">.</span><span style="color:#a6e22e">defaultThreadFactory</span><span style="color:#f92672">()</span> <span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">AbortPolicy</span><span style="color:#f92672">())</span> <span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> 0 <span style="color:#f92672">;</span> x <span style="color:#f92672">&lt;</span> 5 <span style="color:#f92672">;</span> x<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            threadPoolExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">submit</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;----&gt;&gt; 执行了任务&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>控制台输出结果</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>pool<span style="color:#f92672">-</span>1<span style="color:#f92672">-</span>thread<span style="color:#f92672">-</span>1<span style="color:#f92672">----&gt;&gt;</span> 执行了任务
</span></span><span style="display:flex;"><span>pool<span style="color:#f92672">-</span>1<span style="color:#f92672">-</span>thread<span style="color:#f92672">-</span>3<span style="color:#f92672">----&gt;&gt;</span> 执行了任务
</span></span><span style="display:flex;"><span>pool<span style="color:#f92672">-</span>1<span style="color:#f92672">-</span>thread<span style="color:#f92672">-</span>2<span style="color:#f92672">----&gt;&gt;</span> 执行了任务
</span></span><span style="display:flex;"><span>pool<span style="color:#f92672">-</span>1<span style="color:#f92672">-</span>thread<span style="color:#f92672">-</span>3<span style="color:#f92672">----&gt;&gt;</span> 执行了任务
</span></span></code></pre></div><p>控制台报错，仅仅执行了4个任务，有一个任务被丢弃了</p>
<p><strong>案例演示2</strong>：演示ThreadPoolExecutor.DiscardPolicy任务处理策略</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadPoolExecutorDemo02</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        ThreadPoolExecutor threadPoolExecutor <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>1 <span style="color:#f92672">,</span> 3 <span style="color:#f92672">,</span> 20 <span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">SECONDS</span> <span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">new</span> ArrayBlockingQueue<span style="color:#f92672">&lt;&gt;(</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">,</span> Executors<span style="color:#f92672">.</span><span style="color:#a6e22e">defaultThreadFactory</span><span style="color:#f92672">()</span> <span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">DiscardPolicy</span><span style="color:#f92672">())</span> <span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> 0 <span style="color:#f92672">;</span> x <span style="color:#f92672">&lt;</span> 5 <span style="color:#f92672">;</span> x<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            threadPoolExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">submit</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;----&gt;&gt; 执行了任务&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>控制台输出结果</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>pool<span style="color:#f92672">-</span>1<span style="color:#f92672">-</span>thread<span style="color:#f92672">-</span>1<span style="color:#f92672">----&gt;&gt;</span> 执行了任务
</span></span><span style="display:flex;"><span>pool<span style="color:#f92672">-</span>1<span style="color:#f92672">-</span>thread<span style="color:#f92672">-</span>1<span style="color:#f92672">----&gt;&gt;</span> 执行了任务
</span></span><span style="display:flex;"><span>pool<span style="color:#f92672">-</span>1<span style="color:#f92672">-</span>thread<span style="color:#f92672">-</span>3<span style="color:#f92672">----&gt;&gt;</span> 执行了任务
</span></span><span style="display:flex;"><span>pool<span style="color:#f92672">-</span>1<span style="color:#f92672">-</span>thread<span style="color:#f92672">-</span>2<span style="color:#f92672">----&gt;&gt;</span> 执行了任务
</span></span></code></pre></div><p>控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了</p>
<p><strong>案例演示3</strong>：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadPoolExecutorDemo02</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        ThreadPoolExecutor threadPoolExecutor<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        threadPoolExecutor <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>1 <span style="color:#f92672">,</span> 3 <span style="color:#f92672">,</span> 20 <span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">SECONDS</span> <span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">new</span> ArrayBlockingQueue<span style="color:#f92672">&lt;&gt;(</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">,</span> Executors<span style="color:#f92672">.</span><span style="color:#a6e22e">defaultThreadFactory</span><span style="color:#f92672">()</span> <span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">DiscardOldestPolicy</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 提交5个任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> 0 <span style="color:#f92672">;</span> x <span style="color:#f92672">&lt;</span> 5 <span style="color:#f92672">;</span> x<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> x <span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            threadPoolExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">submit</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;----&gt;&gt; 执行了任务&#34;</span> <span style="color:#f92672">+</span> y<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">});</span>     
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>控制台输出结果</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>pool<span style="color:#f92672">-</span>1<span style="color:#f92672">-</span>thread<span style="color:#f92672">-</span>2<span style="color:#f92672">----&gt;&gt;</span> 执行了任务2
</span></span><span style="display:flex;"><span>pool<span style="color:#f92672">-</span>1<span style="color:#f92672">-</span>thread<span style="color:#f92672">-</span>1<span style="color:#f92672">----&gt;&gt;</span> 执行了任务0
</span></span><span style="display:flex;"><span>pool<span style="color:#f92672">-</span>1<span style="color:#f92672">-</span>thread<span style="color:#f92672">-</span>3<span style="color:#f92672">----&gt;&gt;</span> 执行了任务3
</span></span><span style="display:flex;"><span>pool<span style="color:#f92672">-</span>1<span style="color:#f92672">-</span>thread<span style="color:#f92672">-</span>1<span style="color:#f92672">----&gt;&gt;</span> 执行了任务4
</span></span></code></pre></div><p>由于任务1在线程池中等待时间最长，因此任务1被丢弃。</p>
<p><strong>案例演示4</strong>：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadPoolExecutorDemo04</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        ThreadPoolExecutor threadPoolExecutor<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        threadPoolExecutor <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>1 <span style="color:#f92672">,</span> 3 <span style="color:#f92672">,</span> 20 <span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">SECONDS</span> <span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">new</span> ArrayBlockingQueue<span style="color:#f92672">&lt;&gt;(</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">,</span> Executors<span style="color:#f92672">.</span><span style="color:#a6e22e">defaultThreadFactory</span><span style="color:#f92672">()</span> <span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">CallerRunsPolicy</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 提交5个任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> 0 <span style="color:#f92672">;</span> x <span style="color:#f92672">&lt;</span> 5 <span style="color:#f92672">;</span> x<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            threadPoolExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">submit</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;----&gt;&gt; 执行了任务&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>控制台输出结果</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>pool<span style="color:#f92672">-</span>1<span style="color:#f92672">-</span>thread<span style="color:#f92672">-</span>1<span style="color:#f92672">----&gt;&gt;</span> 执行了任务
</span></span><span style="display:flex;"><span>pool<span style="color:#f92672">-</span>1<span style="color:#f92672">-</span>thread<span style="color:#f92672">-</span>3<span style="color:#f92672">----&gt;&gt;</span> 执行了任务
</span></span><span style="display:flex;"><span>pool<span style="color:#f92672">-</span>1<span style="color:#f92672">-</span>thread<span style="color:#f92672">-</span>2<span style="color:#f92672">----&gt;&gt;</span> 执行了任务
</span></span><span style="display:flex;"><span>pool<span style="color:#f92672">-</span>1<span style="color:#f92672">-</span>thread<span style="color:#f92672">-</span>1<span style="color:#f92672">----&gt;&gt;</span> 执行了任务
</span></span><span style="display:flex;"><span>main<span style="color:#f92672">----&gt;&gt;</span> 执行了任务
</span></span></code></pre></div><p>通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。</p>
<h2 id="2-原子性">2. 原子性<a hidden class="anchor" aria-hidden="true" href="#2-原子性">#</a></h2>
<h3 id="21-volatile-问题">2.1 volatile-问题<a hidden class="anchor" aria-hidden="true" href="#21-volatile-问题">#</a></h3>
<p><strong>代码分析 :</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.myvolatile<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Demo</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        MyThread1 t1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread1<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        t1<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;小路同学&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        t1<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        MyThread2 t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread2<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        t2<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;小皮同学&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        t2<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.myvolatile<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Money</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> money <span style="color:#f92672">=</span> 100000<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.myvolatile<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread1</span> <span style="color:#66d9ef">extends</span>  Thread <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>Money<span style="color:#f92672">.</span><span style="color:#a6e22e">money</span> <span style="color:#f92672">==</span> 100000<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;结婚基金已经不是十万了&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.myvolatile<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread2</span> <span style="color:#66d9ef">extends</span> Thread <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>10<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Money<span style="color:#f92672">.</span><span style="color:#a6e22e">money</span> <span style="color:#f92672">=</span> 90000<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>程序问题 :</strong>  女孩虽然知道结婚基金是十万，但是当基金的余额发生变化的时候，女孩无法知道最新的余额。</p>
<h3 id="22-volatile解决">2.2 volatile解决<a hidden class="anchor" aria-hidden="true" href="#22-volatile解决">#</a></h3>
<p><strong>以上案例出现的问题 :</strong></p>
<p>​	当A线程修改了共享数据时，B线程没有及时获取到最新的值，如果还在使用原先的值，就会出现问题</p>
<p>​	1，堆内存是唯一的，每一个线程都有自己的线程栈。</p>
<p>​	2 ，每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中。</p>
<p>​	3 ，在线程中，每一次使用是从变量的副本中获取的。</p>
<p><strong>Volatile关键字 :</strong> 强制线程每次在使用的时候，都会看一下共享区域最新的值</p>
<p><strong>代码实现 :</strong> <strong>使用volatile关键字解决</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.myvolatile<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Demo</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        MyThread1 t1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread1<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        t1<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;小路同学&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        t1<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        MyThread2 t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread2<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        t2<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;小皮同学&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        t2<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.myvolatile<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Money</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> money <span style="color:#f92672">=</span> 100000<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.myvolatile<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread1</span> <span style="color:#66d9ef">extends</span>  Thread <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>Money<span style="color:#f92672">.</span><span style="color:#a6e22e">money</span> <span style="color:#f92672">==</span> 100000<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;结婚基金已经不是十万了&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.myvolatile<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread2</span> <span style="color:#66d9ef">extends</span> Thread <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>10<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Money<span style="color:#f92672">.</span><span style="color:#a6e22e">money</span> <span style="color:#f92672">=</span> 90000<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="23-synchronized解决">2.3 synchronized解决<a hidden class="anchor" aria-hidden="true" href="#23-synchronized解决">#</a></h3>
<p><strong>synchronized解决 :</strong></p>
<p>​	1 ，线程获得锁</p>
<p>​	2 ，清空变量副本</p>
<p>​	3 ，拷贝共享变量最新的值到变量副本中</p>
<p>​	4 ，执行代码</p>
<p>​	5 ，将修改后变量副本中的值赋值给共享数据</p>
<p>​	6 ，释放锁</p>
<p><strong>代码实现 :</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.myvolatile2<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Demo</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        MyThread1 t1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread1<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        t1<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;小路同学&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        t1<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        MyThread2 t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread2<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        t2<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;小皮同学&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        t2<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.myvolatile2<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Money</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Object lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> money <span style="color:#f92672">=</span> 100000<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.myvolatile2<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread1</span> <span style="color:#66d9ef">extends</span>  Thread <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>Money<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>Money<span style="color:#f92672">.</span><span style="color:#a6e22e">money</span> <span style="color:#f92672">!=</span> 100000<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>                    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;结婚基金已经不是十万了&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.myvolatile2<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread2</span> <span style="color:#66d9ef">extends</span> Thread <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>Money<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>10<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Money<span style="color:#f92672">.</span><span style="color:#a6e22e">money</span> <span style="color:#f92672">=</span> 90000<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="24-原子性">2.4 原子性<a hidden class="anchor" aria-hidden="true" href="#24-原子性">#</a></h3>
<p><strong>概述 :</strong> 所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。</p>
<p><strong>代码实现 :</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.threadatom<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AtomDemo</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        MyAtomThread atom <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyAtomThread<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 100<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>atom<span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyAtomThread</span> <span style="color:#66d9ef">implements</span> Runnable <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> <span style="color:#75715e">//送冰淇淋的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 100<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//1,从共享数据中读取数据到本线程栈中.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//2,修改本线程栈中变量副本的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//3,会把本线程栈中变量副本的值赋值给共享数据.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            count<span style="color:#f92672">++;</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;已经送了&#34;</span> <span style="color:#f92672">+</span> count <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;个冰淇淋&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>代码总结 :</strong> count++ 不是一个原子性操作, 他在执行的过程中,有可能被其他线程打断</p>
<h3 id="25-volatile关键字不能保证原子性">2.5 volatile关键字不能保证原子性<a hidden class="anchor" aria-hidden="true" href="#25-volatile关键字不能保证原子性">#</a></h3>
<p>解决方案 : 我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.threadatom2<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AtomDemo</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        MyAtomThread atom <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyAtomThread<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 100<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>atom<span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyAtomThread</span> <span style="color:#66d9ef">implements</span> Runnable <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> <span style="color:#75715e">//送冰淇淋的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> Object lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 100<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//1,从共享数据中读取数据到本线程栈中.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//2,修改本线程栈中变量副本的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//3,会把本线程栈中变量副本的值赋值给共享数据.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>lock<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                count<span style="color:#f92672">++;</span>
</span></span><span style="display:flex;"><span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;已经送了&#34;</span> <span style="color:#f92672">+</span> count <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;个冰淇淋&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="26-原子性_atomicinteger">2.6 原子性_AtomicInteger<a hidden class="anchor" aria-hidden="true" href="#26-原子性_atomicinteger">#</a></h3>
<p>概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因为变</p>
<p>量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。本次我们只讲解</p>
<p>使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类：</p>
<p>AtomicBoolean： 原子更新布尔类型</p>
<p>AtomicInteger：   原子更新整型</p>
<p>AtomicLong：	原子更新长整型</p>
<p>以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">AtomicInteger</span><span style="color:#f92672">()</span><span style="color:#960050;background-color:#1e0010">：</span>	   			    初始化一个默认值为0的原子型Integer
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">AtomicInteger</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> initialValue<span style="color:#f92672">)</span><span style="color:#960050;background-color:#1e0010">：</span>  初始化一个指定值的原子型Integer
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span><span style="color:#f92672">():</span>   			 				获取值
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getAndIncrement</span><span style="color:#f92672">():</span>      			 以原子方式将当前值加1<span style="color:#960050;background-color:#1e0010">，</span>注意<span style="color:#960050;background-color:#1e0010">，</span>这里返回的是自增前的值<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">incrementAndGet</span><span style="color:#f92672">():</span>     				 以原子方式将当前值加1<span style="color:#960050;background-color:#1e0010">，</span>注意<span style="color:#960050;background-color:#1e0010">，</span>这里返回的是自增后的值<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">addAndGet</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> data<span style="color:#f92672">):</span>				 以原子方式将输入的数值与实例中的值<span style="color:#960050;background-color:#1e0010">（</span>AtomicInteger里的value<span style="color:#960050;background-color:#1e0010">）</span>相加<span style="color:#960050;background-color:#1e0010">，</span>并返回结果<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getAndSet</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> value<span style="color:#f92672">):</span>   			 以原子方式设置为newValue的值<span style="color:#960050;background-color:#1e0010">，</span>并返回旧值<span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><p><strong>代码实现 :</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.threadatom3<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.atomic.AtomicInteger<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyAtomIntergerDemo1</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//    public AtomicInteger()：	               初始化一个默认值为0的原子型Integer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        AtomicInteger ac <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicInteger<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>ac<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        AtomicInteger ac2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicInteger<span style="color:#f92672">(</span>10<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>ac2<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.threadatom3<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.lang.reflect.Field<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.atomic.AtomicInteger<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyAtomIntergerDemo2</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//    int get():   		 		获取值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    int getAndIncrement():     以原子方式将当前值加1，注意，这里返回的是自增前的值。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    int incrementAndGet():     以原子方式将当前值加1，注意，这里返回的是自增后的值。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    int addAndGet(int data):	 以原子方式将参数与对象中的值相加，并返回结果。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    int getAndSet(int value):  以原子方式设置为newValue的值，并返回旧值。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//        AtomicInteger ac1 = new AtomicInteger(10);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//        System.out.println(ac1.get());
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//        AtomicInteger ac2 = new AtomicInteger(10);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//        int andIncrement = ac2.getAndIncrement();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//        System.out.println(andIncrement);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//        System.out.println(ac2.get());
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//        AtomicInteger ac3 = new AtomicInteger(10);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//        int i = ac3.incrementAndGet();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//        System.out.println(i);//自增后的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//        System.out.println(ac3.get());
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//        AtomicInteger ac4 = new AtomicInteger(10);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//        int i = ac4.addAndGet(20);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//        System.out.println(i);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//        System.out.println(ac4.get());
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        AtomicInteger ac5 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicInteger<span style="color:#f92672">(</span>100<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> andSet <span style="color:#f92672">=</span> ac5<span style="color:#f92672">.</span><span style="color:#a6e22e">getAndSet</span><span style="color:#f92672">(</span>20<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>andSet<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>ac5<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="27-atomicinteger-内存解析">2.7 AtomicInteger-内存解析<a hidden class="anchor" aria-hidden="true" href="#27-atomicinteger-内存解析">#</a></h3>
<p><strong>AtomicInteger原理 :</strong> 自旋锁  + CAS 算法</p>
<p><strong>CAS算法：</strong></p>
<p>​	有3个操作数（内存值V， 旧的预期值A，要修改的值B）</p>
<p>​	当旧的预期值A == 内存值   此时修改成功，将V改为B</p>
<p>​	当旧的预期值A！=内存值   此时修改失败，不做任何操作</p>
<p>​	并重新获取现在的最新值（这个重新获取的动作就是自旋）</p>
<h3 id="28-atomicinteger-源码解析">2.8 AtomicInteger-源码解析<a hidden class="anchor" aria-hidden="true" href="#28-atomicinteger-源码解析">#</a></h3>
<p><strong>代码实现 :</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.threadatom4<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AtomDemo</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        MyAtomThread atom <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyAtomThread<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 100<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>atom<span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.threadatom4<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.atomic.AtomicInteger<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyAtomThread</span> <span style="color:#66d9ef">implements</span> Runnable <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//private volatile int count = 0; //送冰淇淋的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//private Object lock = new Object();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    AtomicInteger ac <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicInteger<span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 100<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//1,从共享数据中读取数据到本线程栈中.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//2,修改本线程栈中变量副本的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//3,会把本线程栈中变量副本的值赋值给共享数据.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//synchronized (lock) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//                count++;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//                ac++;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> ac<span style="color:#f92672">.</span><span style="color:#a6e22e">incrementAndGet</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;已经送了&#34;</span> <span style="color:#f92672">+</span> count <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;个冰淇淋&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>           <span style="color:#75715e">// }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>源码解析 :</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//先自增，然后获取自增后的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">incrementAndGet</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//+ 1 自增后的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//this 就表示当前的atomicInteger（值）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//1    自增一次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> U<span style="color:#f92672">.</span><span style="color:#a6e22e">getAndAddInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> VALUE<span style="color:#f92672">,</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getAndAddInt</span><span style="color:#f92672">(</span>Object o<span style="color:#f92672">,</span> <span style="color:#66d9ef">long</span> offset<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> delta<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//v 旧值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> v<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//自旋的过程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">do</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//不断的获取旧值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            v <span style="color:#f92672">=</span> getIntVolatile<span style="color:#f92672">(</span>o<span style="color:#f92672">,</span> offset<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//如果这个方法的返回值为false，那么继续自旋
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//如果这个方法的返回值为true，那么自旋结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//o 表示的就是内存值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//v 旧值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//v + delta 修改后的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>weakCompareAndSetInt<span style="color:#f92672">(</span>o<span style="color:#f92672">,</span> offset<span style="color:#f92672">,</span> v<span style="color:#f92672">,</span> v <span style="color:#f92672">+</span> delta<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//作用：比较内存中的值，旧值是否相等，如果相等就把修改后的值写到内存中，返回true。表示修改成功。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//                                 如果不相等，无法把修改后的值写到内存中，返回false。表示修改失败。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//如果修改失败，那么继续自旋。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> v<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="29-悲观锁和乐观锁">2.9 悲观锁和乐观锁<a hidden class="anchor" aria-hidden="true" href="#29-悲观锁和乐观锁">#</a></h3>
<p><strong>synchronized和CAS的区别 :</strong></p>
<p>**相同点：**在多线程情况下，都可以保证共享数据的安全性。</p>
<p>**不同点：**synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每次操作共享数据之前，都会上锁。（悲观锁）</p>
<p>​	cas是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。</p>
<p>​	如果别人修改过，那么我再次获取现在最新的值。</p>
<p>​	如果别人没有修改过，那么我现在直接修改共享数据的值.(乐观锁）</p>
<h2 id="3-并发工具类">3. 并发工具类<a hidden class="anchor" aria-hidden="true" href="#3-并发工具类">#</a></h2>
<h3 id="31-并发工具类-hashtable">3.1 并发工具类-Hashtable<a hidden class="anchor" aria-hidden="true" href="#31-并发工具类-hashtable">#</a></h3>
<p>​	<strong>Hashtable出现的原因 :</strong> 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。</p>
<p><strong>代码实现 :</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.mymap<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.HashMap<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Hashtable<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyHashtableDemo</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        Hashtable<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> String<span style="color:#f92672">&gt;</span> hm <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Hashtable<span style="color:#f92672">&lt;&gt;();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Thread t1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 25<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                hm<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">,</span> i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Thread t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 25<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 51<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                hm<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">,</span> i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        t1<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        t2<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;----------------------------&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//为了t1和t2能把数据全部添加完毕
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>1000<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//0-0 1-1 ..... 50- 50
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 51<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>hm<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span><span style="color:#75715e">//0 1 2 3 .... 50
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="32-并发工具类-concurrenthashmap基本使用">3.2 并发工具类-ConcurrentHashMap基本使用<a hidden class="anchor" aria-hidden="true" href="#32-并发工具类-concurrenthashmap基本使用">#</a></h3>
<p>​	<strong>ConcurrentHashMap出现的原因 :</strong> 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。</p>
<p>基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。</p>
<p><strong>体系结构 :</strong></p>
<p><img loading="lazy" src="/images/Java%e5%a4%9a%e7%ba%bf%e7%a8%8b02/1591168965857.png" alt=""  />
</p>
<p><strong>总结 :</strong></p>
<p>​	1 ，HashMap是线程不安全的。多线程环境下会有数据安全问题</p>
<p>​	2 ，Hashtable是线程安全的，但是会将整张表锁起来，效率低下</p>
<p>​	3，ConcurrentHashMap也是线程安全的，效率较高。     在JDK7和JDK8中，底层原理不一样。</p>
<p><strong>代码实现 :</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.mymap<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Hashtable<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.ConcurrentHashMap<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyConcurrentHashMapDemo</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        ConcurrentHashMap<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> String<span style="color:#f92672">&gt;</span> hm <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ConcurrentHashMap<span style="color:#f92672">&lt;&gt;(</span>100<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Thread t1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 25<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                hm<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">,</span> i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Thread t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 25<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 51<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                hm<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">,</span> i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        t1<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        t2<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;----------------------------&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//为了t1和t2能把数据全部添加完毕
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>1000<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//0-0 1-1 ..... 50- 50
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 51<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>hm<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span><span style="color:#75715e">//0 1 2 3 .... 50
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="33-并发工具类-concurrenthashmap17原理">3.3 并发工具类-ConcurrentHashMap1.7原理<a hidden class="anchor" aria-hidden="true" href="#33-并发工具类-concurrenthashmap17原理">#</a></h3>
<p><img loading="lazy" src="/images/Java%e5%a4%9a%e7%ba%bf%e7%a8%8b02/1591169254280.png" alt=""  />
</p>
<h3 id="34-并发工具类-concurrenthashmap18原理">3.4 并发工具类-ConcurrentHashMap1.8原理<a hidden class="anchor" aria-hidden="true" href="#34-并发工具类-concurrenthashmap18原理">#</a></h3>
<p><img loading="lazy" src="/images/Java%e5%a4%9a%e7%ba%bf%e7%a8%8b02/1591169338256.png" alt=""  />
</p>
<p><strong>总结 :</strong></p>
<p>​	1，如果使用空参构造创建ConcurrentHashMap对象，则什么事情都不做。     在第一次添加元素的时候创建哈希表</p>
<p>​	2，计算当前元素应存入的索引。</p>
<p>​	3，如果该索引位置为null，则利用cas算法，将本结点添加到数组中。</p>
<p>​	4，如果该索引位置不为null，则利用volatile关键字获得当前位置最新的结点地址，挂在他下面，变成链表。</p>
<p>​	5，当链表的长度大于等于8时，自动转换成红黑树6，以链表或者红黑树头结点为锁对象，配合悲观锁保证多线程操作集合时数据的安全性</p>
<h3 id="35-并发工具类-countdownlatch">3.5 并发工具类-CountDownLatch<a hidden class="anchor" aria-hidden="true" href="#35-并发工具类-countdownlatch">#</a></h3>
<p><strong>CountDownLatch类 :</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>public CountDownLatch(int count)</td>
<td>参数传递线程数，表示等待线程数量</td>
</tr>
<tr>
<td>public void await()</td>
<td>让线程等待</td>
</tr>
<tr>
<td>public void countDown()</td>
<td>当前线程执行完毕</td>
</tr>
</tbody>
</table>
<p><strong>使用场景：</strong> 让某一条线程等待其他线程执行完毕之后再执行</p>
<p><strong>代码实现 :</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.mycountdownlatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.CountDownLatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ChileThread1</span> <span style="color:#66d9ef">extends</span> Thread <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> CountDownLatch countDownLatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ChileThread1</span><span style="color:#f92672">(</span>CountDownLatch countDownLatch<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">countDownLatch</span> <span style="color:#f92672">=</span> countDownLatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//1.吃饺子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;=</span> 10<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>getName<span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;在吃第&#34;</span> <span style="color:#f92672">+</span> i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;个饺子&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//2.吃完说一声
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//每一次countDown方法的时候，就让计数器-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        countDownLatch<span style="color:#f92672">.</span><span style="color:#a6e22e">countDown</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.mycountdownlatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.CountDownLatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ChileThread2</span> <span style="color:#66d9ef">extends</span> Thread <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> CountDownLatch countDownLatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ChileThread2</span><span style="color:#f92672">(</span>CountDownLatch countDownLatch<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">countDownLatch</span> <span style="color:#f92672">=</span> countDownLatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//1.吃饺子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;=</span> 15<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>getName<span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;在吃第&#34;</span> <span style="color:#f92672">+</span> i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;个饺子&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//2.吃完说一声
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//每一次countDown方法的时候，就让计数器-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        countDownLatch<span style="color:#f92672">.</span><span style="color:#a6e22e">countDown</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.mycountdownlatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.CountDownLatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ChileThread3</span> <span style="color:#66d9ef">extends</span> Thread <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> CountDownLatch countDownLatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ChileThread3</span><span style="color:#f92672">(</span>CountDownLatch countDownLatch<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">countDownLatch</span> <span style="color:#f92672">=</span> countDownLatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//1.吃饺子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;=</span> 20<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>getName<span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;在吃第&#34;</span> <span style="color:#f92672">+</span> i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;个饺子&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//2.吃完说一声
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//每一次countDown方法的时候，就让计数器-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        countDownLatch<span style="color:#f92672">.</span><span style="color:#a6e22e">countDown</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.mycountdownlatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.CountDownLatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MotherThread</span> <span style="color:#66d9ef">extends</span> Thread <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> CountDownLatch countDownLatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">MotherThread</span><span style="color:#f92672">(</span>CountDownLatch countDownLatch<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">countDownLatch</span> <span style="color:#f92672">=</span> countDownLatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//1.等待
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//当计数器变成0的时候，会自动唤醒这里等待的线程。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            countDownLatch<span style="color:#f92672">.</span><span style="color:#a6e22e">await</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//2.收拾碗筷
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;妈妈在收拾碗筷&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.mycountdownlatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.CountDownLatch<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyCountDownLatchDemo</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//1.创建CountDownLatch的对象，需要传递给四个线程。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//在底层就定义了一个计数器，此时计数器的值就是3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        CountDownLatch countDownLatch <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CountDownLatch<span style="color:#f92672">(</span>3<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//2.创建四个线程对象并开启他们。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        MotherThread motherThread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MotherThread<span style="color:#f92672">(</span>countDownLatch<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        motherThread<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ChileThread1 t1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ChileThread1<span style="color:#f92672">(</span>countDownLatch<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        t1<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;小明&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ChileThread2 t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ChileThread2<span style="color:#f92672">(</span>countDownLatch<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        t2<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;小红&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ChileThread3 t3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ChileThread3<span style="color:#f92672">(</span>countDownLatch<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        t3<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;小刚&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        t1<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        t2<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        t3<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>总结 :</strong></p>
<p>​	1. CountDownLatch(int count)：参数写等待线程的数量。并定义了一个计数器。</p>
<p>​	2. await()：让线程等待，当计数器为0时，会唤醒等待的线程</p>
<p>​	3. countDown()： 线程执行完毕时调用，会将计数器-1。</p>
<h3 id="36-并发工具类-semaphore">3.6 并发工具类-Semaphore<a hidden class="anchor" aria-hidden="true" href="#36-并发工具类-semaphore">#</a></h3>
<p><strong>使用场景 :</strong></p>
<p>​	可以控制访问特定资源的线程数量。</p>
<p><strong>实现步骤 :</strong></p>
<p>​	1，需要有人管理这个通道</p>
<p>​	2，当有车进来了，发通行许可证</p>
<p>​	3，当车出去了，收回通行许可证</p>
<p>​	4，如果通行许可证发完了，那么其他车辆只能等着</p>
<p><strong>代码实现 :</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.mysemaphore<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.Semaphore<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyRunnable</span> <span style="color:#66d9ef">implements</span> Runnable <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//1.获得管理员对象，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> Semaphore semaphore <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Semaphore<span style="color:#f92672">(</span>2<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//2.获得通行证
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            semaphore<span style="color:#f92672">.</span><span style="color:#a6e22e">acquire</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//3.开始行驶
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;获得了通行证开始行驶&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>2000<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;归还通行证&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//4.归还通行证
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            semaphore<span style="color:#f92672">.</span><span style="color:#a6e22e">release</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.itheima.mysemaphore<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MySemaphoreDemo</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        MyRunnable mr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyRunnable<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 100<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>mr<span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://iblog.zone/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://iblog.zone/archives/%E7%94%A8yum%E5%AE%89%E8%A3%85%E7%9A%84nginx%E6%8A%A5unknown-directive-stream/">
    <span class="title">« 上一页</span>
    <br>
    <span>用yum安装的nginx，报unknown directive “stream”</span>
  </a>
  <a class="next" href="https://iblog.zone/archives/java%E5%A4%9A%E7%BA%BF%E7%A8%8B01/">
    <span class="title">下一页 »</span>
    <br>
    <span>Java多线程01</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://iblog.zone">ylw&#39;s blog</a></span>
    <span>
	& <a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2021039488号</a>
    </span>

    总访客：<span id="busuanzi_value_site_uv"></span>
    总浏览量：<span id="busuanzi_value_site_pv"></span>
    页面访问量：<span id="busuanzi_value_page_pv"></span>

</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '复制';

        function copyingDone() {
            copybutton.innerText = '已复制！';
            setTimeout(() => {
                copybutton.innerText = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
