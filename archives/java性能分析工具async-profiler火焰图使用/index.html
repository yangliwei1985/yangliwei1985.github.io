<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Java性能分析工具Async-profiler(火焰图)使用 | ylw&#39;s blog</title>
<meta name="keywords" content="性能分析优化" />
<meta name="description" content="如果你经常遇到 Java 线上性能问题束手无策，看着线上服务 CPU 飙升一筹莫展，发现内存不断泄露满脸茫然。别慌，这里有一款低开销、自带火焰图、让你大呼好用的 Java 性能分析工具 - async-profiler。
最近 Arthas 性能分析工具上线了火焰图分析功能，Arthas 使用 async-profiler 生成 CPU/内存火焰图进行性能分析，弥补了之前内存分析的不足。在 Arthas 上使用还是比较方便的，使用方式可以看官方文档。这篇文章介绍 async-profiler 相关内容。
Arthas 火焰图官方文档：alibaba.github.io/arthas/prof…
如果你想了解更多 Arthas 信息，可以参考：Arthas - Java 线上问题定位处理的终极利器
async-profiler 介绍 async-profiler 是一款开源的 Java 性能分析工具，原理是基于 HotSpot 的 API，以微乎其微的性能开销收集程序运行中的堆栈信息、内存分配等信息进行分析。
使用 async-profiler 可以做下面几个方面的分析。
 CPU cycles Hardware and Software performance counters like cache misses, branch misses, page faults, context switches etc. Allocations in Java Heap Contented lock attempts, including both Java object monitors and ReentrantLocks  我们常用的是 CPU 性能分析和 Heap 内存分配分析。在进行 CPU 性能分析时，仅需要非常低的性能开销就可以进行分析，这也是这个工具的优点之一。">
<meta name="author" content="">
<link rel="canonical" href="https://iblog.zone/archives/java%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7async-profiler%E7%81%AB%E7%84%B0%E5%9B%BE%E4%BD%BF%E7%94%A8/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7af5e4f048c756d5896f15b3f7cd7ee898ea1b3b101fcb40abfb5216ca230ecf.css" integrity="sha256-evXk8EjHVtWJbxWz981&#43;6JjqGzsQH8tAq/tSFsojDs8=" rel="preload stylesheet" as="style">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://iblog.zone/images/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://iblog.zone/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="https://iblog.zone/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="https://iblog.zone/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="https://iblog.zone/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel='stylesheet' href='//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>

<meta property="og:title" content="Java性能分析工具Async-profiler(火焰图)使用" />
<meta property="og:description" content="如果你经常遇到 Java 线上性能问题束手无策，看着线上服务 CPU 飙升一筹莫展，发现内存不断泄露满脸茫然。别慌，这里有一款低开销、自带火焰图、让你大呼好用的 Java 性能分析工具 - async-profiler。
最近 Arthas 性能分析工具上线了火焰图分析功能，Arthas 使用 async-profiler 生成 CPU/内存火焰图进行性能分析，弥补了之前内存分析的不足。在 Arthas 上使用还是比较方便的，使用方式可以看官方文档。这篇文章介绍 async-profiler 相关内容。
Arthas 火焰图官方文档：alibaba.github.io/arthas/prof…
如果你想了解更多 Arthas 信息，可以参考：Arthas - Java 线上问题定位处理的终极利器
async-profiler 介绍 async-profiler 是一款开源的 Java 性能分析工具，原理是基于 HotSpot 的 API，以微乎其微的性能开销收集程序运行中的堆栈信息、内存分配等信息进行分析。
使用 async-profiler 可以做下面几个方面的分析。
 CPU cycles Hardware and Software performance counters like cache misses, branch misses, page faults, context switches etc. Allocations in Java Heap Contented lock attempts, including both Java object monitors and ReentrantLocks  我们常用的是 CPU 性能分析和 Heap 内存分配分析。在进行 CPU 性能分析时，仅需要非常低的性能开销就可以进行分析，这也是这个工具的优点之一。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://iblog.zone/archives/java%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7async-profiler%E7%81%AB%E7%84%B0%E5%9B%BE%E4%BD%BF%E7%94%A8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-10T10:36:59&#43;00:00" />
<meta property="article:modified_time" content="2022-02-10T10:36:59&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java性能分析工具Async-profiler(火焰图)使用"/>
<meta name="twitter:description" content="如果你经常遇到 Java 线上性能问题束手无策，看着线上服务 CPU 飙升一筹莫展，发现内存不断泄露满脸茫然。别慌，这里有一款低开销、自带火焰图、让你大呼好用的 Java 性能分析工具 - async-profiler。
最近 Arthas 性能分析工具上线了火焰图分析功能，Arthas 使用 async-profiler 生成 CPU/内存火焰图进行性能分析，弥补了之前内存分析的不足。在 Arthas 上使用还是比较方便的，使用方式可以看官方文档。这篇文章介绍 async-profiler 相关内容。
Arthas 火焰图官方文档：alibaba.github.io/arthas/prof…
如果你想了解更多 Arthas 信息，可以参考：Arthas - Java 线上问题定位处理的终极利器
async-profiler 介绍 async-profiler 是一款开源的 Java 性能分析工具，原理是基于 HotSpot 的 API，以微乎其微的性能开销收集程序运行中的堆栈信息、内存分配等信息进行分析。
使用 async-profiler 可以做下面几个方面的分析。
 CPU cycles Hardware and Software performance counters like cache misses, branch misses, page faults, context switches etc. Allocations in Java Heap Contented lock attempts, including both Java object monitors and ReentrantLocks  我们常用的是 CPU 性能分析和 Heap 内存分配分析。在进行 CPU 性能分析时，仅需要非常低的性能开销就可以进行分析，这也是这个工具的优点之一。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://iblog.zone/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Java性能分析工具Async-profiler(火焰图)使用",
      "item": "https://iblog.zone/archives/java%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7async-profiler%E7%81%AB%E7%84%B0%E5%9B%BE%E4%BD%BF%E7%94%A8/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java性能分析工具Async-profiler(火焰图)使用",
  "name": "Java性能分析工具Async-profiler(火焰图)使用",
  "description": "如果你经常遇到 Java 线上性能问题束手无策，看着线上服务 CPU 飙升一筹莫展，发现内存不断泄露满脸茫然。别慌，这里有一款低开销、自带火焰图、让你大呼好用的 Java 性能分析工具 - async-profiler。\n最近 Arthas 性能分析工具上线了火焰图分析功能，Arthas 使用 async-profiler 生成 CPU/内存火焰图进行性能分析，弥补了之前内存分析的不足。在 Arthas 上使用还是比较方便的，使用方式可以看官方文档。这篇文章介绍 async-profiler 相关内容。\nArthas 火焰图官方文档：alibaba.github.io/arthas/prof…\n如果你想了解更多 Arthas 信息，可以参考：Arthas - Java 线上问题定位处理的终极利器\nasync-profiler 介绍 async-profiler 是一款开源的 Java 性能分析工具，原理是基于 HotSpot 的 API，以微乎其微的性能开销收集程序运行中的堆栈信息、内存分配等信息进行分析。\n使用 async-profiler 可以做下面几个方面的分析。\n CPU cycles Hardware and Software performance counters like cache misses, branch misses, page faults, context switches etc. Allocations in Java Heap Contented lock attempts, including both Java object monitors and ReentrantLocks  我们常用的是 CPU 性能分析和 Heap 内存分配分析。在进行 CPU 性能分析时，仅需要非常低的性能开销就可以进行分析，这也是这个工具的优点之一。",
  "keywords": [
    "性能分析优化"
  ],
  "articleBody": "如果你经常遇到 Java 线上性能问题束手无策，看着线上服务 CPU 飙升一筹莫展，发现内存不断泄露满脸茫然。别慌，这里有一款低开销、自带火焰图、让你大呼好用的 Java 性能分析工具 - async-profiler。\n最近 Arthas 性能分析工具上线了火焰图分析功能，Arthas 使用 async-profiler 生成 CPU/内存火焰图进行性能分析，弥补了之前内存分析的不足。在 Arthas 上使用还是比较方便的，使用方式可以看官方文档。这篇文章介绍 async-profiler 相关内容。\nArthas 火焰图官方文档：alibaba.github.io/arthas/prof…\n如果你想了解更多 Arthas 信息，可以参考：Arthas - Java 线上问题定位处理的终极利器\nasync-profiler 介绍 async-profiler 是一款开源的 Java 性能分析工具，原理是基于 HotSpot 的 API，以微乎其微的性能开销收集程序运行中的堆栈信息、内存分配等信息进行分析。\n使用 async-profiler 可以做下面几个方面的分析。\n CPU cycles Hardware and Software performance counters like cache misses, branch misses, page faults, context switches etc. Allocations in Java Heap Contented lock attempts, including both Java object monitors and ReentrantLocks  我们常用的是 CPU 性能分析和 Heap 内存分配分析。在进行 CPU 性能分析时，仅需要非常低的性能开销就可以进行分析，这也是这个工具的优点之一。\n在进行 Heap 分配分析时，async-profiler 工具会收集内存分配信息，而不是去检测占用 CPU 的代码。async-profiler 不使用侵入性的技术，例如字节码检测工具或者探针检测等，这也说明 async-profiler 的内存分配分析像 CPU 性能分析一样，不会产生太大的性能开销，同时也不用写出庞大的堆栈文件再去进行进一步处理，。\nasync-profile 目前支持 Linux 和 macOS 平台（macOS 下只能分析用户空间的代码）。\n Linux / x64 / x86 / ARM / AArch64 macOS / x64  async-profiler 工具在采样后可以生成采样结果的日志报告，也可以生成 SVG 格式的火焰图，在之前生成火焰图要使用 FlameGraph 工具。现在已经不需要了，从 1.2 版本开始，就已经内置了开箱即用的 SVG 文件生成功能。\n其他信息可以看官方文档：github.com/jvm-profili…\nasync-profiler 安装 下载 async-profiler 工具可以在官方的 Github 上直接下载编译好的文件，如果你就是想体验手动挡的感觉，也可以克隆项目，手动编译一下，不得不说这个工具十分的易用，我在手动编译的过程十分顺滑，没有出现任何问题。\n如果你想下载编译好的，可以到这里下载。\ngithub.com/jvm-profili…\n如果想体验手动挡的感觉，可以克隆整个项目，进项项目编译。\n手动编译的环境要求。\n JDK GCC  下面是手动安装的操作命令。\ngit clone https://github.com/jvm-profiling-tools/async-profiler cd async-profiler make 执行 make 命令编译后会在项目的目录下生成一个 build 文件夹，里面存放着编译的结果。下面是我手动编译的过程输出。\n➜ develop git clone https://github.com/jvm-profiling-tools/async-profiler Cloning into 'async-profiler'... remote: Enumerating objects: 69, done. remote: Counting objects: 100% (69/69), done. remote: Compressing objects: 100% (54/54), done. remote: Total 1805 (delta 34), reused 32 (delta 15), pack-reused 1736 Receiving objects: 100% (1805/1805), 590.78 KiB | 23.00 KiB/s, done. Resolving deltas: 100% (1288/1288), done. ➜ develop cd async-profiler ➜ async-profiler git:(master) make mkdir -p build g++ -O2 -D_XOPEN_SOURCE -D_DARWIN_C_SOURCE -DPROFILER_VERSION=\\\"1.6\\\" -I/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/include -I/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/include/darwin -fPIC -shared -o build/libasyncProfiler.so src/*.cpp -ldl -lpthread gcc -O2 -DJATTACH_VERSION=\\\"1.5\\\" -o build/jattach src/jattach/jattach.c mkdir -p build/classes /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/bin/javac -source 6 -target 6 -d build/classes src/java/one/profiler/AsyncProfiler.java src/java/one/profiler/AsyncProfilerMXBean.java src/java/one/profiler/Counter.java src/java/one/profiler/Events.java 警告: [options] 未与 -source 1.6 一起设置引导类路径 1 个警告 /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/bin/jar cvf build/async-profiler.jar -C build/classes . 已添加清单 正在添加: one/(输入 = 0) (输出 = 0)(存储了 0%) 正在添加: one/profiler/(输入 = 0) (输出 = 0)(存储了 0%) 正在添加: one/profiler/AsyncProfiler.class(输入 = 1885) (输出 = 908)(压缩了 51%) 正在添加: one/profiler/Events.class(输入 = 405) (输出 = 286)(压缩了 29%) 正在添加: one/profiler/Counter.class(输入 = 845) (输出 = 473)(压缩了 44%) 正在添加: one/profiler/AsyncProfilerMXBean.class(输入 = 631) (输出 = 344)(压缩了 45%) rm -rf build/classes ➜ async-profiler git:(master) async-profiler 使用 运行项目里的 profiler.sh 可以看到 async-profiler 的使用帮助文档。\n➜ async-profiler git:(master) ./profiler.sh Usage: ./profiler.sh [action] [options]  Actions:  start start profiling and return immediately  resume resume profiling without resetting collected data  stop stop profiling  status print profiling status  list list profiling events supported by the target JVM  collect collect profile for the specified period of time  and then stop (default action) Options:  -e event profiling event: cpu|alloc|lock|cache-misses etc.  -d duration run profiling for  seconds  -f filename dump output to   -i interval sampling interval in nanoseconds  -j jstackdepth maximum Java stack depth  -b bufsize frame buffer size  -t profile different threads separately  -s simple class names instead of FQN  -g print method signatures  -a annotate Java method names  -o fmt output format: summary|traces|flat|collapsed|svg|tree|jfr  -v, --version display version string   --title string SVG title  --width px SVG width  --height px SVG frame height  --minwidth px skip frames smaller than px  --reverse generate stack-reversed FlameGraph / Call tree   --all-kernel only include kernel-mode events  --all-user only include user-mode events  --sync-walk use synchronous JVMTI stack walker (dangerous!)   is a numeric process ID of the target JVM  or 'jps' keyword to find running JVM automatically  Example: ./profiler.sh -d 30 -f profile.svg 3456  ./profiler.sh start -i 999000 jps  ./profiler.sh stop -o summary,flat jps 可以看到使用的方式是：Usage: ./profiler.sh [action] [options] ，也就是 命令+操作+参数+PID。\n常用的使用的几个步骤：\n 查看 java 进程的 PID（可以使用 jps ）。 使用 ./profiler.sh start 开始采样。 使用 ./profiler.sh status 查看已经采样的时间。 使用 ./profiler.sh stop 停止采样，输出结果。  这种方式使用起来多费劲啊，而且最后输出的是文本结果，看起来更是费劲，为了不那么费劲，可以使用帮助里给的采样后生成 SVG 文件例子。\n./profiler.sh -d 30 -f profile.svg 3456 这个命令的意思是，对 PID 为 3456 的 java 进程采样 30 秒，然后生成 profile.svg 结果文件。\n默认情况下是分析 CPU 性能，如果要进行其他分析，可以使用 -e 参数。\n-e event profiling event: cpu|alloc|lock|cache-misses etc. 可以看到支持的分析事件有 CPU、Alloc、Lock、Cache-misses 。\nasync-profiler 案例 上面说完了 async-profiler 工具的作用和使用方式，既然能进行 CPU 性能分析和 Heap 内存分配分析，那么我们就写几个不一般的方法分析试试看。看看是不是有像上面介绍的那么好用。\nJava 案例编码 很简单的几个方法，hotmethod 方法写了几个常见操作，三个方法中很明显 hotmethod3 方法里的生成 UUID 和 replace（需要正则匹配）操作消耗的 CPU 性能会较多。allocate 方法里因为要不断的创建长度为 6万的数组，消耗的内存空间一定是最多的。\nimport java.util.ArrayList; import java.util.Random; import java.util.UUID;  /** *  * 模拟热点代码 * * @Author niujinpeng */ public class HotCode {   private static volatile int value;   private static Object array;   public static void main(String[] args) {  while (true) {  hotmethod1();  hotmethod2();  hotmethod3();  allocate();  }  }   /** * 生成 6万长度的数组 */  private static void allocate() {  array = new int[6 * 1000];  array = new Integer[6 * 1000];  }   /** * 生成一个UUID */  private static void hotmethod3() {  ArrayListString list = new ArrayList();  UUID uuid = UUID.randomUUID();  String str = uuid.toString().replace(\"-\", \"\");  list.add(str);  }   /** * 数字累加 */  private static void hotmethod2() {  value++;  }   /** * 生成一个随机数 */  private static void hotmethod1() {  Random random = new Random();  int anInt = random.nextInt();  } } CPU 性能分析 运行上面的程序，然后使用 JPS 命令查看 PID 信息。\n➜ develop jps 2800 Jps 2449 HotCode 2450 Launcher 805 RemoteMavenServer36 470 NutstoreGUI 699 ➜ develop 上面运行的类名是 HotCode，可以看到对应的 PID 是 2449。\n使用 ./profiler.sh -d 20 -f 2449.svg 2449 命令对 2449 号进程采样20秒，然后得到生成的 2449.svg 文件，然后我们使用浏览器打开这个文件，可以看到 CPU 的使用火焰图。\n关于火焰图怎么看，一言以蔽之：火焰图里，横条越长，代表使用的越多，从下到上是调用堆栈信息。在这个图里可以看到 main 方法上面的调用中 hotmethod3 方法的 CPU 使用是最多的，点击这个方法。还可能看到更详细的信息。\n可以看到 replace 方法占用的 CPU 最多，也是程序中性能问题所在，是需要注意的地方。\nHeap 内存分析 还是上面运行的程序，进程 PID 还是 2449，这次使用 -e 参数分析内存使用情况。\n命令：./profiler.sh -d 20 -e alloc -f 2449-alloc.svg 2449\n命令的意思是收集进程号是 2449 的进程的内存信息 20 秒，然后输出为 2449-alloc.svg 文件。20秒后得到 svg 文件使用浏览器打开，可以看到内存分配情况。\n依旧是横条越长，代表使用的越多，从下到上是调用堆栈信息。从图里可以看出来 main 方法调用的 allocate 方法使用的内存最多，这个方法里的 Integer 类型数组占用的内存又最多，为 71%。\n文中测试代码已经上传到 Github：github.com/niumoo/lab-…\n",
  "wordCount" : "809",
  "inLanguage": "zh",
  "datePublished": "2022-02-10T10:36:59Z",
  "dateModified": "2022-02-10T10:36:59Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://iblog.zone/archives/java%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7async-profiler%E7%81%AB%E7%84%B0%E5%9B%BE%E4%BD%BF%E7%94%A8/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "ylw's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://iblog.zone/images/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://iblog.zone" accesskey="h" title="ylw&#39;s blog (Alt + H)">ylw&#39;s blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://iblog.zone/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://iblog.zone/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://iblog.zone/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://iblog.zone/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://iblog.zone/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://iblog.zone">主页</a>&nbsp;»&nbsp;<a href="https://iblog.zone/posts/">Posts</a></div>
    <h1 class="post-title">
      Java性能分析工具Async-profiler(火焰图)使用
    </h1>
    <div class="post-meta"><span title='2022-02-10 10:36:59 +0000 UTC'>2022-02-10</span>&nbsp;·&nbsp;4 分钟

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#async-profiler-%e4%bb%8b%e7%bb%8d" aria-label="async-profiler 介绍">async-profiler 介绍</a></li>
                    <li>
                        <a href="#async-profiler-%e5%ae%89%e8%a3%85" aria-label="async-profiler 安装">async-profiler 安装</a></li>
                    <li>
                        <a href="#async-profiler-%e4%bd%bf%e7%94%a8" aria-label="async-profiler 使用">async-profiler 使用</a></li>
                    <li>
                        <a href="#async-profiler-%e6%a1%88%e4%be%8b" aria-label="async-profiler 案例">async-profiler 案例</a><ul>
                            
                    <li>
                        <a href="#java-%e6%a1%88%e4%be%8b%e7%bc%96%e7%a0%81" aria-label="Java 案例编码">Java 案例编码</a></li>
                    <li>
                        <a href="#cpu-%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90" aria-label="CPU 性能分析">CPU 性能分析</a></li>
                    <li>
                        <a href="#heap-%e5%86%85%e5%ad%98%e5%88%86%e6%9e%90" aria-label="Heap 内存分析">Heap 内存分析</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script data-cfasync="false">
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>


  <div class="post-content"><p>如果你经常遇到  Java 线上性能问题束手无策，看着线上服务 CPU 飙升一筹莫展，发现内存不断泄露满脸茫然。别慌，这里有一款低开销、自带<strong>火焰图</strong>、让你大呼好用的 Java 性能分析工具 - <strong>async-profiler</strong>。</p>
<p>最近 Arthas 性能分析工具上线了<strong>火焰图</strong>分析功能，Arthas 使用  <strong>async-profiler</strong> 生成 CPU/内存火焰图进行性能分析，弥补了之前内存分析的不足。在 Arthas 上使用还是比较方便的，使用方式可以看官方文档。这篇文章介绍  <strong>async-profiler</strong> 相关内容。</p>
<p>Arthas 火焰图官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Falibaba.github.io%2Farthas%2Fprofiler.html">alibaba.github.io/arthas/prof…</a></p>
<p>如果你想了解更多 Arthas 信息，可以参考：<a href="https://link.juejin.cn?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI1MDIxNjQ1OQ%3D%3D%26mid%3D2247483907%26idx%3D1%26sn%3D653ecea3697873ad1f5c4f567034a1c3%26chksm%3De984eb67def362715c0a01bc08e1491f7e8f892e92826406484174da264cb06bbc1c05cf30f6%26scene%3D21%23wechat_redirect">Arthas - Java 线上问题定位处理的终极利器</a></p>
<h2 id="async-profiler-介绍">async-profiler 介绍<a hidden class="anchor" aria-hidden="true" href="#async-profiler-介绍">#</a></h2>
<p>async-profiler 是一款开源的 Java <strong>性能分析工具</strong>，原理是基于 HotSpot 的 API，以<strong>微乎其微的性能开销</strong>收集程序运行中的堆栈信息、内存分配等信息进行分析。</p>
<p>使用 async-profiler 可以做下面几个方面的分析。</p>
<ul>
<li><strong>CPU cycles</strong></li>
<li>Hardware and Software performance counters like cache misses, branch misses, page faults, context switches etc.</li>
<li><strong>Allocations in Java Heap</strong></li>
<li>Contented lock attempts, including both Java object monitors and ReentrantLocks</li>
</ul>
<p>我们常用的是 CPU 性能分析和 Heap 内存分配分析。在进行 CPU 性能分析时，仅需要<strong>非常低的性能开销</strong>就可以进行分析，这也是这个工具的优点之一。</p>
<p>在进行 Heap 分配分析时，async-profiler 工具会收集内存分配信息，而不是去检测占用 CPU 的代码。async-profiler 不使用侵入性的技术，例如字节码检测工具或者探针检测等，这也说明 async-profiler 的内存分配分析像 CPU 性能分析一样，不会产生太大的性能开销，同时也不用写出<strong>庞大的堆栈文件</strong>再去进行进一步处理，。</p>
<p>async-profile 目前支持 Linux 和 macOS 平台（macOS 下只能分析用户空间的代码）。</p>
<ul>
<li><strong>Linux</strong> / x64 / x86 / ARM / AArch64</li>
<li><strong>macOS</strong> / x64</li>
</ul>
<p>async-profiler 工具在采样后可以生成采样结果的日志报告，也可以生成 SVG 格式的<strong>火焰图</strong>，在之前生成<strong>火焰图</strong>要使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbrendangregg%2FFlameGraph">FlameGraph</a> 工具。现在已经不需要了，从 1.2 版本开始，就已经内置了开箱即用的 SVG 文件生成功能。</p>
<p>其他信息可以看官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjvm-profiling-tools%2Fasync-profiler">github.com/jvm-profili…</a></p>
<h2 id="async-profiler-安装">async-profiler 安装<a hidden class="anchor" aria-hidden="true" href="#async-profiler-安装">#</a></h2>
<p>下载 async-profiler 工具可以在官方的 Github 上直接下载编译好的文件，如果你就是想体验手动挡的感觉，也可以克隆项目，手动编译一下，不得不说这个工具十分的易用，我在手动编译的过程十分顺滑，没有出现任何问题。</p>
<p>如果你想下载编译好的，可以到这里下载。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjvm-profiling-tools%2Fasync-profiler%2Freleases">github.com/jvm-profili…</a></p>
<p>如果想体验手动挡的感觉，可以克隆整个项目，进项项目编译。</p>
<p>手动编译的环境要求。</p>
<ul>
<li>JDK</li>
<li>GCC</li>
</ul>
<p>下面是手动安装的操作命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git clone https://github.com/jvm-profiling-tools/async-profiler
</span></span><span style="display:flex;"><span>cd async-profiler
</span></span><span style="display:flex;"><span>make
</span></span></code></pre></div><p>执行 make 命令编译后会在项目的目录下生成一个 build 文件夹，里面存放着编译的结果。下面是我手动编译的过程输出。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>➜  develop git clone https://github.com/jvm-profiling-tools/async-profiler
</span></span><span style="display:flex;"><span>Cloning into <span style="color:#e6db74">&#39;async-profiler&#39;</span>...
</span></span><span style="display:flex;"><span>remote: Enumerating objects: 69, <span style="color:#66d9ef">done</span>.
</span></span><span style="display:flex;"><span>remote: Counting objects: 100% <span style="color:#f92672">(</span>69/69<span style="color:#f92672">)</span>, <span style="color:#66d9ef">done</span>.
</span></span><span style="display:flex;"><span>remote: Compressing objects: 100% <span style="color:#f92672">(</span>54/54<span style="color:#f92672">)</span>, <span style="color:#66d9ef">done</span>.
</span></span><span style="display:flex;"><span>remote: Total <span style="color:#ae81ff">1805</span> <span style="color:#f92672">(</span>delta 34<span style="color:#f92672">)</span>, reused <span style="color:#ae81ff">32</span> <span style="color:#f92672">(</span>delta 15<span style="color:#f92672">)</span>, pack-reused <span style="color:#ae81ff">1736</span>
</span></span><span style="display:flex;"><span>Receiving objects: 100% <span style="color:#f92672">(</span>1805/1805<span style="color:#f92672">)</span>, 590.78 KiB | 23.00 KiB/s, <span style="color:#66d9ef">done</span>.
</span></span><span style="display:flex;"><span>Resolving deltas: 100% <span style="color:#f92672">(</span>1288/1288<span style="color:#f92672">)</span>, <span style="color:#66d9ef">done</span>.
</span></span><span style="display:flex;"><span>➜  develop cd async-profiler
</span></span><span style="display:flex;"><span>➜  async-profiler git:<span style="color:#f92672">(</span>master<span style="color:#f92672">)</span> make
</span></span><span style="display:flex;"><span>mkdir -p build
</span></span><span style="display:flex;"><span>g++ -O2 -D_XOPEN_SOURCE -D_DARWIN_C_SOURCE -DPROFILER_VERSION<span style="color:#f92672">=</span><span style="color:#ae81ff">\&#34;</span>1.6<span style="color:#ae81ff">\&#34;</span> -I/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/include -I/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/include/darwin -fPIC -shared -o build/libasyncProfiler.so src/*.cpp -ldl -lpthread
</span></span><span style="display:flex;"><span>gcc -O2 -DJATTACH_VERSION<span style="color:#f92672">=</span><span style="color:#ae81ff">\&#34;</span>1.5<span style="color:#ae81ff">\&#34;</span> -o build/jattach src/jattach/jattach.c
</span></span><span style="display:flex;"><span>mkdir -p build/classes
</span></span><span style="display:flex;"><span>/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/bin/javac -source <span style="color:#ae81ff">6</span> -target <span style="color:#ae81ff">6</span> -d build/classes src/java/one/profiler/AsyncProfiler.java src/java/one/profiler/AsyncProfilerMXBean.java src/java/one/profiler/Counter.java src/java/one/profiler/Events.java
</span></span><span style="display:flex;"><span>警告: <span style="color:#f92672">[</span>options<span style="color:#f92672">]</span> 未与 -source 1.6 一起设置引导类路径
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span> 个警告
</span></span><span style="display:flex;"><span>/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/bin/jar cvf build/async-profiler.jar -C build/classes .
</span></span><span style="display:flex;"><span>已添加清单
</span></span><span style="display:flex;"><span>正在添加: one/<span style="color:#f92672">(</span>输入 <span style="color:#f92672">=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>输出 <span style="color:#f92672">=</span> 0<span style="color:#f92672">)(</span>存储了 0%<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>正在添加: one/profiler/<span style="color:#f92672">(</span>输入 <span style="color:#f92672">=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>输出 <span style="color:#f92672">=</span> 0<span style="color:#f92672">)(</span>存储了 0%<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>正在添加: one/profiler/AsyncProfiler.class<span style="color:#f92672">(</span>输入 <span style="color:#f92672">=</span> 1885<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>输出 <span style="color:#f92672">=</span> 908<span style="color:#f92672">)(</span>压缩了 51%<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>正在添加: one/profiler/Events.class<span style="color:#f92672">(</span>输入 <span style="color:#f92672">=</span> 405<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>输出 <span style="color:#f92672">=</span> 286<span style="color:#f92672">)(</span>压缩了 29%<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>正在添加: one/profiler/Counter.class<span style="color:#f92672">(</span>输入 <span style="color:#f92672">=</span> 845<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>输出 <span style="color:#f92672">=</span> 473<span style="color:#f92672">)(</span>压缩了 44%<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>正在添加: one/profiler/AsyncProfilerMXBean.class<span style="color:#f92672">(</span>输入 <span style="color:#f92672">=</span> 631<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>输出 <span style="color:#f92672">=</span> 344<span style="color:#f92672">)(</span>压缩了 45%<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>rm -rf build/classes
</span></span><span style="display:flex;"><span>➜  async-profiler git:<span style="color:#f92672">(</span>master<span style="color:#f92672">)</span>
</span></span></code></pre></div><h2 id="async-profiler-使用">async-profiler 使用<a hidden class="anchor" aria-hidden="true" href="#async-profiler-使用">#</a></h2>
<p>运行项目里的 profiler.sh 可以看到 async-profiler 的使用帮助文档。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>➜  async-profiler git:<span style="color:#f92672">(</span>master<span style="color:#f92672">)</span> ./profiler.sh
</span></span><span style="display:flex;"><span>Usage: ./profiler.sh <span style="color:#f92672">[</span>action<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>options<span style="color:#f92672">]</span> &lt;pid&gt;
</span></span><span style="display:flex;"><span>Actions:
</span></span><span style="display:flex;"><span>  start             start profiling and <span style="color:#66d9ef">return</span> immediately
</span></span><span style="display:flex;"><span>  resume            resume profiling without resetting collected data
</span></span><span style="display:flex;"><span>  stop              stop profiling
</span></span><span style="display:flex;"><span>  status            print profiling status
</span></span><span style="display:flex;"><span>  list              list profiling events supported by the target JVM
</span></span><span style="display:flex;"><span>  collect           collect profile <span style="color:#66d9ef">for</span> the specified period of time
</span></span><span style="display:flex;"><span>                    and <span style="color:#66d9ef">then</span> stop <span style="color:#f92672">(</span>default action<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Options:
</span></span><span style="display:flex;"><span>  -e event          profiling event: cpu|alloc|lock|cache-misses etc.
</span></span><span style="display:flex;"><span>  -d duration       run profiling <span style="color:#66d9ef">for</span> &lt;duration&gt; seconds
</span></span><span style="display:flex;"><span>  -f filename       dump output to &lt;filename&gt;
</span></span><span style="display:flex;"><span>  -i interval       sampling interval in nanoseconds
</span></span><span style="display:flex;"><span>  -j jstackdepth    maximum Java stack depth
</span></span><span style="display:flex;"><span>  -b bufsize        frame buffer size
</span></span><span style="display:flex;"><span>  -t                profile different threads separately
</span></span><span style="display:flex;"><span>  -s                simple class names instead of FQN
</span></span><span style="display:flex;"><span>  -g                print method signatures
</span></span><span style="display:flex;"><span>  -a                annotate Java method names
</span></span><span style="display:flex;"><span>  -o fmt            output format: summary|traces|flat|collapsed|svg|tree|jfr
</span></span><span style="display:flex;"><span>  -v, --version     display version string
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  --title string    SVG title
</span></span><span style="display:flex;"><span>  --width px        SVG width
</span></span><span style="display:flex;"><span>  --height px       SVG frame height
</span></span><span style="display:flex;"><span>  --minwidth px     skip frames smaller than px
</span></span><span style="display:flex;"><span>  --reverse         generate stack-reversed FlameGraph / Call tree
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  --all-kernel      only include kernel-mode events
</span></span><span style="display:flex;"><span>  --all-user        only include user-mode events
</span></span><span style="display:flex;"><span>  --sync-walk       use synchronous JVMTI stack walker <span style="color:#f92672">(</span>dangerous!<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&lt;pid&gt; is a numeric process ID of the target JVM
</span></span><span style="display:flex;"><span>      or <span style="color:#e6db74">&#39;jps&#39;</span> keyword to find running JVM automatically
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Example: ./profiler.sh -d <span style="color:#ae81ff">30</span> -f profile.svg <span style="color:#ae81ff">3456</span>
</span></span><span style="display:flex;"><span>         ./profiler.sh start -i <span style="color:#ae81ff">999000</span> jps
</span></span><span style="display:flex;"><span>         ./profiler.sh stop -o summary,flat jps
</span></span></code></pre></div><p>可以看到使用的方式是：Usage: ./profiler.sh [action] [options] ，也就是 <strong>命令+操作+参数+PID</strong>。</p>
<p>常用的使用的几个步骤：</p>
<ol>
<li>查看 java 进程的 PID（可以使用 jps ）。</li>
<li>使用 ./profiler.sh start  开始采样。</li>
<li>使用 ./profiler.sh status  查看已经采样的时间。</li>
<li>使用 ./profiler.sh stop  停止采样，输出结果。</li>
</ol>
<p>这种方式使用起来多费劲啊，而且最后输出的是文本结果，看起来更是费劲，为了不那么费劲，可以使用帮助里给的采样后生成 SVG 文件例子。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>./profiler.sh -d <span style="color:#ae81ff">30</span> -f profile.svg <span style="color:#ae81ff">3456</span>
</span></span></code></pre></div><p>这个命令的意思是，对 PID 为 3456 的 java 进程采样 30 秒，然后生成 profile.svg 结果文件。</p>
<p>默认情况下是分析 CPU 性能，如果要进行其他分析，可以使用 -e 参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>-e event     profiling event: cpu|alloc|lock|cache-misses etc.
</span></span></code></pre></div><p>可以看到支持的分析事件有 CPU、Alloc、Lock、Cache-misses 。</p>
<h2 id="async-profiler-案例">async-profiler 案例<a hidden class="anchor" aria-hidden="true" href="#async-profiler-案例">#</a></h2>
<p>上面说完了 async-profiler 工具的作用和使用方式，既然能进行 CPU 性能分析和 Heap 内存分配分析，那么我们就写几个不一般的方法分析试试看。看看是不是有像上面介绍的那么好用。</p>
<h3 id="java-案例编码">Java 案例编码<a hidden class="anchor" aria-hidden="true" href="#java-案例编码">#</a></h3>
<p>很简单的几个方法，hotmethod 方法写了几个常见操作，三个方法中很明显 hotmethod3 方法里的生成 UUID 和 replace（需要正则匹配）操作消耗的 CPU 性能会较多。allocate 方法里因为要不断的创建长度为 6万的数组，消耗的内存空间一定是最多的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.ArrayList<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Random<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.UUID<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * &lt;p&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 模拟热点代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @Author niujinpeng
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HotCode</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> value<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Object array<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            hotmethod1<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            hotmethod2<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            hotmethod3<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            allocate<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 生成 6万长度的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">allocate</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        array <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>6 <span style="color:#f92672">*</span> 1000<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>        array <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">[</span>6 <span style="color:#f92672">*</span> 1000<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 生成一个UUID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hotmethod3</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        ArrayList<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
</span></span><span style="display:flex;"><span>        UUID uuid <span style="color:#f92672">=</span> UUID<span style="color:#f92672">.</span><span style="color:#a6e22e">randomUUID</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        String str <span style="color:#f92672">=</span> uuid<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">().</span><span style="color:#a6e22e">replace</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;-&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>str<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 数字累加
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hotmethod2</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        value<span style="color:#f92672">++;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 生成一个随机数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hotmethod1</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        Random random <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Random<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> anInt <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="cpu-性能分析">CPU 性能分析<a hidden class="anchor" aria-hidden="true" href="#cpu-性能分析">#</a></h3>
<p>运行上面的程序，然后使用 JPS 命令查看 PID 信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>➜  develop jps
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2800</span> Jps
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2449</span> HotCode
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2450</span> Launcher
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">805</span> RemoteMavenServer36
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">470</span> NutstoreGUI
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">699</span>
</span></span><span style="display:flex;"><span>➜  develop
</span></span></code></pre></div><p>上面运行的类名是 HotCode，可以看到对应的 PID 是 2449。</p>
<p>使用 <code>./profiler.sh -d 20 -f 2449.svg 2449</code> 命令对 2449 号进程采样20秒，然后得到生成的 2449.svg 文件，然后我们使用浏览器打开这个文件，可以看到 CPU 的使用<strong>火焰图</strong>。</p>
<p><img loading="lazy" src="/images/Java%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e5%b7%a5%e5%85%b7Async-profiler-%e7%81%ab%e7%84%b0%e5%9b%be-%e4%bd%bf%e7%94%a8/image-20191208225253486.png" alt=""  />
</p>
<p>关于火焰图怎么看，一言以蔽之：<strong>火焰图里，横条越长，代表使用的越多，从下到上是调用堆栈信息</strong>。在这个图里可以看到 main 方法上面的调用中 hotmethod3 方法的 CPU 使用是最多的，点击这个方法。还可能看到更详细的信息。</p>
<p><img loading="lazy" src="/images/Java%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e5%b7%a5%e5%85%b7Async-profiler-%e7%81%ab%e7%84%b0%e5%9b%be-%e4%bd%bf%e7%94%a8/9bebba62a3e84a8891e55c713fdaef17_tplv-k3u1fbpfcp-watermark.awebp" alt=""  />
</p>
<p>可以看到 replace 方法占用的 CPU 最多，也是程序中性能问题所在，是需要注意的地方。</p>
<h3 id="heap-内存分析">Heap 内存分析<a hidden class="anchor" aria-hidden="true" href="#heap-内存分析">#</a></h3>
<p>还是上面运行的程序，进程 PID 还是 2449，这次使用 -e 参数分析内存使用情况。</p>
<p>命令：<code>./profiler.sh -d 20 -e alloc -f 2449-alloc.svg 2449</code></p>
<p>命令的意思是收集进程号是 2449 的进程的内存信息 20 秒，然后输出为 2449-alloc.svg 文件。20秒后得到 svg 文件使用浏览器打开，可以看到内存分配情况。</p>
<p><img loading="lazy" src="/images/Java%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e5%b7%a5%e5%85%b7Async-profiler-%e7%81%ab%e7%84%b0%e5%9b%be-%e4%bd%bf%e7%94%a8/122a0be2a78c4a16985b097551106e83_tplv-k3u1fbpfcp-watermark.awebp" alt=""  />
</p>
<p>依旧是横条越长，代表使用的越多，从下到上是调用堆栈信息。从图里可以看出来 main 方法调用的 allocate 方法使用的内存最多，这个方法里的 Integer 类型数组占用的内存又最多，为 71%。</p>
<p>文中测试代码已经上传到 Github：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fniumoo%2Flab-notes">github.com/niumoo/lab-…</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://iblog.zone/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96/">性能分析优化</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://iblog.zone/archives/firewall%E9%98%B2%E7%81%AB%E5%A2%99%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">
    <span class="title">« 上一页</span>
    <br>
    <span>Firewall防火墙常用操作</span>
  </a>
  <a class="next" href="https://iblog.zone/archives/redis-shake%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E8%BF%81%E7%A7%BB%E5%B7%A5%E5%85%B7/">
    <span class="title">下一页 »</span>
    <br>
    <span>redis-shake数据同步&amp;迁移工具</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://iblog.zone">ylw&#39;s blog</a></span>
    <span>
	& <a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备2021039488号</a>
    </span>

    总访客：<span id="busuanzi_value_site_uv"></span>
    总浏览量：<span id="busuanzi_value_site_pv"></span>
    页面访问量：<span id="busuanzi_value_page_pv"></span>

</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '复制';

        function copyingDone() {
            copybutton.innerText = '已复制！';
            setTimeout(() => {
                copybutton.innerText = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
